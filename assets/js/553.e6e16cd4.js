(window.webpackJsonp=window.webpackJsonp||[]).push([[553],{964:function(e,t,a){"use strict";a.r(t);var o=a(46),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("For JSON-RPC methods which currently accept a default block parameter, additionally allow the parameter to be a block hash.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP can be considered a generalization of "),a("RouterLink",{attrs:{to:"/zh/eip-234.html"}},[e._v("EIP-234")]),e._v(". It would enable clients to unambiguously specify the block they want to query for certain JSON-RPC methods, even if the block is not in the canonical chain. This allows clients to maintain a coherent picture of blockchain state that they are interested in, even in the presence of reorgs, without requiring that the node maintain a persistent connection with the client or store any client-specific state.")],1),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("The following JSON-RPC methods are affected:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("eth_getBalance")])]),e._v(" "),a("li",[a("code",[e._v("eth_getStorageAt")])]),e._v(" "),a("li",[a("code",[e._v("eth_getTransactionCount")])]),e._v(" "),a("li",[a("code",[e._v("eth_getCode")])]),e._v(" "),a("li",[a("code",[e._v("eth_call")])]),e._v(" "),a("li",[a("code",[e._v("eth_getProof")])])]),e._v(" "),a("p",[e._v("The following options, quoted from the "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC#the-default-block-parameter",target:"_blank",rel:"noopener noreferrer"}},[e._v("JSON-RPC spec"),a("OutboundLink")],1),e._v(", are currently possible for the defaultBlock parameter:")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("HEX String - an integer block number")]),e._v(" "),a("li",[e._v('String "earliest" for the earliest/genesis block')]),e._v(" "),a("li",[e._v('String "latest" - for the latest mined block')]),e._v(" "),a("li",[e._v('String "pending" - for the pending state/transactions')])])]),e._v(" "),a("p",[e._v("Since there is no way to clearly distinguish between a DATA parameter and a QUANTITY parameter, this EIP proposes a new scheme for the block parameter. The following option is additionally allowed:")]),e._v(" "),a("ul",[a("li",[e._v("OBJECT\n"),a("ul",[a("li",[a("code",[e._v("blockNumber")]),e._v(": QUANTITY - a block number")]),e._v(" "),a("li",[a("code",[e._v("blockHash")]),e._v(": DATA - a block hash")])])])]),e._v(" "),a("p",[e._v("If the block is not found, the callee SHOULD raise a JSON-RPC error (the recommended error code is "),a("code",[e._v("-32001: Resource not found")]),e._v(").")]),e._v(" "),a("p",[e._v("If the tag is "),a("code",[e._v("blockHash")]),e._v(", an additional boolean field may be supplied to the block parameter, "),a("code",[e._v("requireCanonical")]),e._v(", which defaults to "),a("code",[e._v("false")]),e._v(" and defines whether the block must be a canonical block according to the callee. If "),a("code",[e._v("requireCanonical")]),e._v(" is "),a("code",[e._v("false")]),e._v(", the callee should raise a JSON-RPC error only if the block is not found (as described above). If "),a("code",[e._v("requireCanonical")]),e._v(" is "),a("code",[e._v("true")]),e._v(", the callee SHOULD additionally raise a JSON-RPC error if the block is not in the canonical chain (the recommended error code is "),a("code",[e._v("-32000: Invalid input")]),e._v(" and in any case should be different than the error code for the block not found case so that the caller can distinguish the cases). The block-not-found check SHOULD take precedence over the block-is-canonical check, so that if the block is not found the callee raises block-not-found rather than block-not-canonical.")]),e._v(" "),a("p",[e._v("To maintain backwards compatibility, the block number MAY be specified either as a hex string or using the new block parameter scheme. In other words, the following are equivalent for the default block parameter:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('"earliest"')])]),e._v(" "),a("li",[a("code",[e._v('"0x0"')])]),e._v(" "),a("li",[a("code",[e._v('{ "blockNumber": "0x0" }')])]),e._v(" "),a("li",[a("code",[e._v('{ "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3" }')]),e._v(" (hash of the genesis block on the Ethereum main chain)")]),e._v(" "),a("li",[a("code",[e._v('{ "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3", "requireCanonical": true }')])]),e._v(" "),a("li",[a("code",[e._v('{ "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3", "requireCanonical": false }')])])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Currently, the state-querying JSON-RPC methods specified above have no option to unambiguously specify which block to query the state for. This can cause issues for applications which need to make multiple calls to the RPC. For instance, a wallet which just executed a transfer may want to display the balances of both the sender and recipient. If there is a re-org in between when the balance of the sender is queried via "),a("code",[e._v("eth_getBalance")]),e._v(" and when the balance of the recipient is queried, the balances may not reconcile. As a slightly more complicated example, the UI for a decentralized exchange (which hosts orders on-chain) may walk a list of orders by calling "),a("code",[e._v("eth_call")]),e._v(" for each of them to get the order data. Another type of use case is where an application needs to make a decision based on multiple pieces of state, e.g. a payout predicated on simultaneous ownership of two NFTs.")]),e._v(" "),a("p",[e._v("In order to ensure that the state is coherent (i.e., "),a("code",[e._v("eth_call")]),e._v(" was called with exactly the same block for every call), the application may currently use one of several strategies:")]),e._v(" "),a("ul",[a("li",[e._v("Decide on a block number to use (e.g., the latest block number known to the application). After each "),a("code",[e._v("eth_call")]),e._v(" using that block number, call "),a("code",[e._v("eth_getBlockByNumber")]),e._v(", also with that block number. If the block hash does not match the known hash for that block number, rollback the current activity and retry from the beginning. This adds "),a("code",[e._v("O(n)")]),e._v(" invocations as baseline overhead and another "),a("code",[e._v("O(n)")]),e._v(" invocations for every retry needed. Moreover, there is no way to detect the (unlikely but possible) case that the relevant block was reorged out before "),a("code",[e._v("eth_call")]),e._v(", and then reorged back in before "),a("code",[e._v("eth_getBlockByNumber")]),e._v(".")]),e._v(" "),a("li",[e._v("Rely on logs, which "),a("em",[e._v("can")]),e._v(" be queried unambiguously thanks to the "),a("code",[e._v("blockHash")]),e._v(" parameter. However, this requires semantic support from the smart contract; if the smart contract does not emit appropriate events, the client will not be able to reconstruct the specific state it is interested in.")]),e._v(" "),a("li",[e._v("Rely on non-standard extensions like "),a("code",[e._v("parity_subscribe")]),e._v(". This requires a persistent connection between the client and node (via IPC or websockets), increases coupling between the client and the node, and cannot handle use cases where there are dependencies between invocations of "),a("code",[e._v("eth_call")]),e._v(", for example, walking a linked list.")])]),e._v(" "),a("p",[e._v("Allowing "),a("code",[e._v("eth_call")]),e._v(" and friends to unambiguously specify the block to be queried give the application developer a robust and intuitive way to solve these problems. Multiple sequential queries will query the same state, enabling the application developer to not worry about inconsistencies in their view of the blockchain state.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("Backwards compatible.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockNumber": "0x0" }')]),e._v(" -> return storage at given address in genesis block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3" }')]),e._v(" -> return storage at given address in genesis block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3", "requireCanonical": false }')]),e._v(" -> return storage at given address in genesis block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3", "requireCanonical": true }')]),e._v(" -> return storage at given address in genesis block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-existent-block-hash>" }')]),e._v(" -> raise block-not-found error")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-existent-block-hash>", "requireCanonical": false }')]),e._v(" -> raise block-not-found error")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-existent-block-hash>", "requireCanonical": true }')]),e._v(" -> raise block-not-found error")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-canonical-block-hash>" }')]),e._v(" -> return storage at given address in specified block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-canonical-block-hash>", "requireCanonical": false }')]),e._v(" -> return storage at given address in specified block")]),e._v(" "),a("li",[a("code",[e._v('eth_getStorageAt [ "0x<address>", { "blockHash": "0x<non-canonical-block-hash>", "requireCanonical": true }')]),e._v(" -> raise block-not-canonical error")])]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("It is supported by Geth 1.9.6 ("),a("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/pull/19491",target:"_blank",rel:"noopener noreferrer"}},[e._v("PR"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=r.exports}}]);