(window.webpackJsonp=window.webpackJsonp||[]).push([[462],{870:function(e,t,a){"use strict";a.r(t);var s=a(46),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Support for efficient transient storage in EVM. It is like regular storage ("),a("code",[e._v("SLOAD")]),e._v("/"),a("code",[e._v("SSTORE")]),e._v("), but with the lifetime limited to one Ethereum transaction. Notable use case is efficient reentrancy lock.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This proposal introduces transient storage, which behaves similar to storage, but the updates will only persist within one Ethereum transaction. Transient storage is accessible to smart contracts via new opcodes: "),a("code",[e._v("TLOAD")]),e._v(" and "),a("code",[e._v("TSTORE")]),e._v(" (“T” stands for Transient).")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Running a transaction in Ethereum can generate multiple nested frames of execution, each created by "),a("code",[e._v("CALL")]),e._v(" (or similar) instructions. Contracts can be re-entered during the same transaction, in which case there are more than one frame belonging to one contract. Currently, these frames can communicate in two ways - via inputs/outputs passed via "),a("code",[e._v("CALL")]),e._v(" instructions, and via storage updates. If there is an intermediate frame belonging to another contract, communication via inputs/outputs is not secure. Notable example is a reentrancy lock which cannot rely on the intermediate frame to pass through the state of the lock. Communication via storage ("),a("code",[e._v("SSTORE")]),e._v("/"),a("code",[e._v("SLOAD")]),e._v(") is costly. Transient storage is a dedicated and gas efficient solution to the problem of inter frame communication.")]),e._v(" "),a("p",[e._v("Language support could be added in relatively easy way. For example, in Solidity, a qualifier “transient” can be introduced (similar to the existing qualifiers “memory” and “storage”). Since addressing scheme of "),a("code",[e._v("TSTORE")]),e._v(" and "),a("code",[e._v("TLOAD")]),e._v(" is the same as for "),a("code",[e._v("SSTORE")]),e._v(" and "),a("code",[e._v("SLOAD")]),e._v(", code generation routines that exist for storage variables, can be easily generalised to also support transient storage.")]),e._v(" "),a("p",[e._v("Potential use cases unlocked by this EIP include:")]),e._v(" "),a("ol",[a("li",[e._v("Reentrancy lock")]),e._v(" "),a("li",[e._v("Passing error codes and messages from the execution frames up the execution stack")]),e._v(" "),a("li",[e._v("More generic libraries that use callbacks, for example generalised sorting with functions "),a("code",[e._v("Less")]),e._v(" and "),a("code",[e._v("Swap")]),e._v(" defined.")]),e._v(" "),a("li",[e._v("Shared memory (borrowed from early draft of similar EIP by @holiman). When implementing contract-proxies using "),a("code",[e._v("DELEGATECALL")]),e._v(", all direct arguments are relayed from the caller to the callee via the "),a("code",[e._v("CALLDATA")]),e._v(", leaving no room for meta-data between the proxy and the proxee. Also, the proxy must be careful about "),a("code",[e._v("storage")]),e._v(" access to avoid collision with "),a("code",[e._v("target")]),e._v(" "),a("code",[e._v("storage")]),e._v("-slots. Since "),a("code",[e._v("transient storage")]),e._v(" would be shared, it would be possible to use "),a("code",[e._v("transient storage")]),e._v(" to pass information between the "),a("code",[e._v("proxy")]),e._v(" and the "),a("code",[e._v("target")]),e._v(".")])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Two new opcodes are added to EVM, "),a("code",[e._v("TLOAD")]),e._v(" and "),a("code",[e._v("TSTORE")]),e._v(".")]),e._v(" "),a("p",[e._v("They use the same arguments on stack as "),a("code",[e._v("SLOAD")]),e._v(" ("),a("code",[e._v("0x54")]),e._v(") and "),a("code",[e._v("SSTORE")]),e._v(" ("),a("code",[e._v("0x55")]),e._v(").")]),e._v(" "),a("p",[a("code",[e._v("TLOAD")]),e._v(" pops one 32-byte word from the top of the stack, treats this value as the address, fetches 32-byte word from the transient storage at that address, and pops the value on top of the stack.")]),e._v(" "),a("p",[a("code",[e._v("TSTORE")]),e._v(" pops two 32-byte words from the top of the stack. The word on the top is the address, and the next is the value. "),a("code",[e._v("TSTORE")]),e._v(" saves the value at the given address in the transient storage.")]),e._v(" "),a("p",[e._v("Addressing is the same as "),a("code",[e._v("SLOAD")]),e._v(" and "),a("code",[e._v("SSTORE")]),e._v(". i.e. each 32-byte address points to a unique 32-byte word.")]),e._v(" "),a("p",[e._v("Gas cost for both is 8 units of gas, regardless of values stored.")]),e._v(" "),a("p",[e._v("The effects of transient storage are discarded at the end of the transaction.")]),e._v(" "),a("p",[e._v('Transient storage is private to the contract that owns it, in the same way as "regular" storage is. Only owning contract frames may access their transient storage. And when they do, all the frames access the same transient store, in the same way as "regular" storage, but unlike "memory".')]),e._v(" "),a("p",[e._v("When transient storage is used in the context of "),a("code",[e._v("DELEGATECALL")]),e._v(" or "),a("code",[e._v("CALLCODE")]),e._v(", then the owning contract of the transient storage is the contract that issued "),a("code",[e._v("DELEGATECALL")]),e._v(" or "),a("code",[e._v("CALLCODE")]),e._v(" instruction (the caller). When transient storage is used in the context of "),a("code",[e._v("CALL")]),e._v(" or "),a("code",[e._v("STATICCALL")]),e._v(", then the owning contract of the transient storage is the contract that is the target of the "),a("code",[e._v("CALL")]),e._v(" or "),a("code",[e._v("STATICCALL")]),e._v(" instruction (the callee).")]),e._v(" "),a("p",[e._v("Transient storage does not interact with reverts or invalid transactions, that means if a frame reverts, its effects on the transient storage remain until the end of the transaction.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("There is a proposal to alleviate the cost of inter-frame communication by reducing the cost of "),a("code",[e._v("SSTORE")]),e._v(" when it modifies the same item multiple times within the same transaction (EIP-1087).")]),e._v(" "),a("p",[e._v("Relative cons of the transient storage: new opcodes; new code in the clients; new concept for the yellow paper (more to update); requires separation of concerns (persistence and inter-frame communication) when programming.")]),e._v(" "),a("p",[e._v("Relative pros of the transient storage:  cheaper to use; does not change the semantics of the existing operations; very simple gas accounting rules;")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("This EIP requires a hard fork to implement.")]),e._v(" "),a("p",[e._v("Since this EIP does not change semantics of any existing opcodes, it does not pose risk of backwards incompatibility for existing deployed contracts.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("TBD")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("Most straightforward implementation would be a dictionary (map), similar to what exists for the ‘dirty’ storage, with the difference that it gets re-initialised at the start of each transaction, and does not get persisted.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);