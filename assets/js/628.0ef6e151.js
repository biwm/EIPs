(window.webpackJsonp=window.webpackJsonp||[]).push([[628],{1044:function(e,t,o){"use strict";o.r(t);var a=o(46),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"abstract"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("eth")]),e._v(" network protocol has two ways to propagate a newly mined block: it can be broadcast to a peer in its entirety (via "),o("code",[e._v("NewBlock (0x07)")]),e._v(" "),o("a",{attrs:{href:"https://github.com/ethereum/devp2p/blob/master/caps/eth.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("in "),o("code",[e._v("eth/64")]),e._v(" and prior"),o("OutboundLink")],1),e._v(") or it can be announced only (via "),o("code",[e._v("NewBlockHashes (0x01)")]),e._v("). This duality allows nodes to do the high-bandwidth broadcasting (10s-100s KB) for a square root number of peers; and the low-bandwidth announcing (10s-100s B) for the remaining linear number of peers. The square root broadcast is enough to reach all well connected nodes, but the linear announce is needed to get across degenerate topologies. This works well.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("eth")]),e._v(" protocol, however, does not have a similar dual mechanism for propagating transactions, so nodes need to rely on broadcasting (via "),o("code",[e._v("Transactions (0x02)")]),e._v("). To cater for degenerate topologies, transactions cannot be broadcast square rooted, rather they need to be transferred linearly to all peers. With N peers, each node will transfer the same transaction N times (counting both directions), whereas 1 would be enough in a perfect world. This is a significant waste.")]),e._v(" "),o("p",[e._v("A similar issue arises when a new network connection is made between two nodes, as they need to sync up their transaction pools, but the pool is just a soup of dangling transactions. Without a way to deduplicate transactions remotely, each node is forced to naively transfer their entire list of transactions to the other side. With pools containing thousands of transactions, a naive transfer amounts to 10s-100s MB, most of which is useless. There is no better way, however.")]),e._v(" "),o("p",[e._v("This EIP introduces three additional message types into the "),o("code",[e._v("eth")]),e._v(" protocol (releasing a new version, "),o("code",[e._v("eth/65")]),e._v("): "),o("code",[e._v("NewPooledTransactionHashes (0x08)")]),e._v(" to announce a set of transactions without their content; "),o("code",[e._v("GetPooledTransactions (0x09)")]),e._v(" to request a batch of transactions by their announced hash; and "),o("code",[e._v("PooledTransactions (0x0a)")]),e._v(" to reply to a transaction request. This permits reducing the bandwidth used for transaction propagation from linear complexity in the number of peers to square root; and also reducing the initial transaction exchange from 10s-100s MB to "),o("code",[e._v("len(pool) * 32B ~= 128KB")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"motivation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),o("p",[e._v("With transaction throughput (and size) picking up in Ethereum, transaction propagation is the current dominant component of the used network resources. Most of these resources are however wasted, as the "),o("code",[e._v("eth")]),e._v(" protocol does not have a mechanism to deduplicate transactions remotely, so the same data is transferred over and over again across all network connections.")]),e._v(" "),o("p",[e._v("This EIP proposes a tiny extension to the "),o("code",[e._v("eth")]),e._v(" protocol, which permits nodes to agree on the set of transactions that need to be transferred across a network connection, before doing the costly exchange. This should help reduce the global (operational) bandwidth usage of the Ethereum network by at least an order of magnitude.")]),e._v(" "),o("h2",{attrs:{id:"specification"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),o("p",[e._v("Add three new message types to the "),o("code",[e._v("eth")]),e._v(" protocol:")]),e._v(" "),o("ul",[o("li",[o("code",[e._v("NewPooledTransactionHashes (0x08): [hash_0: B_32, hash_1: B_32, ...]")]),e._v(" "),o("ul",[o("li",[e._v("Specify one or more transactions that have appeared in the network and which have "),o("strong",[e._v("not yet been included in a block")]),e._v(". To be maximally helpful, nodes should inform peers of all transactions that they may not be aware of.")]),e._v(" "),o("li",[e._v("There is "),o("strong",[e._v("no protocol violating hard cap")]),e._v(" on the number of hashes a node may announce to a remote peer (apart from the 10MB "),o("code",[e._v("devp2p")]),e._v(" network packet limit), but 4096 seems a sane chunk (128KB) to avoid a single packet hogging a network connection.")]),e._v(" "),o("li",[e._v("Nodes should only announce hashes of transactions that the remote peer could reasonably be considered not to know, but it is better to be over zealous than to have a nonce gap in the pool.")])])]),e._v(" "),o("li",[o("code",[e._v("GetPooledTransactions (0x09): [hash_0: B_32, hash_1: B_32, ...]")]),e._v(" "),o("ul",[o("li",[e._v("Specify one or more transactions to retrieve from a remote peer's "),o("strong",[e._v("transaction pool")]),e._v(".")]),e._v(" "),o("li",[e._v("There is "),o("strong",[e._v("no protocol violating hard cap")]),e._v(" on the number of transactions a node may request from a remote peer (apart from the 10MB "),o("code",[e._v("devp2p")]),e._v(" network packet limit), but the recipient may enforce an arbitrary cap on the reply (size or serving time), which "),o("strong",[e._v("must not")]),e._v(" be considered a protocol violation. To keep wasted bandwidth down (unanswered hashes), 256 seems like a sane upper limit.")])])]),e._v(" "),o("li",[o("code",[e._v("PooledTransactions (0x0a): [[nonce: P, receivingAddress: B_20, value: P, ...], ...]")]),e._v(" "),o("ul",[o("li",[e._v("Specify transactions "),o("strong",[e._v("from the local transaction pool")]),e._v(" that the remote node requested via a "),o("code",[e._v("GetPooledTransactions (0x09)")]),e._v(" message. The items in the list are transactions in the format described in the main Ethereum specification.")]),e._v(" "),o("li",[e._v("The transactions "),o("strong",[e._v("must")]),e._v(" be in same order as in the request, but it is "),o("strong",[e._v("ok")]),e._v(" to skip transactions that are not available. This way if the response size limit is reached, requesters will know which hashes to request again (everything from the last returned transaction) and which to assume unavailable (all gaps before the last returned transaction).")]),e._v(" "),o("li",[e._v("A peer may respond with an empty reply "),o("strong",[e._v("iff")]),e._v(" none of the hashes match transactions in its pool. It is allowed to announce a transaction that will not be served later if it gets included in a block in between.")])])])]),e._v(" "),o("h2",{attrs:{id:"rationale"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),o("p",[o("strong",[e._v("Q: Why limit "),o("code",[e._v("GetPooledTransactions (0x09)")]),e._v(" to retrieving items from the pool?")])]),e._v(" "),o("p",[e._v("Apart from the transaction pool, transactions in Ethereum are always bundled together by the hundreds in block bodies and existing network retrievals honor this data layout. Allowing direct access to individual transactions in the database has no actionable use case, but would expose costly database reads into the network.")]),e._v(" "),o("p",[e._v("For transaction propagation purposes there is no reason to allow disk access, as any transaction finalized to disk will be broadcast inside a block anyway, so at worse there is a few hundred millisecond delay when a node gets the transaction.")]),e._v(" "),o("p",[e._v("Block propagation may be made a bit more optimal by transferring the contained transactions on demand only, but that is a whole EIP in itself, so better relax the protocol when all the requirements are known and not in advance. It would probably be enough to maintain a set of transactions included in recent blocks in memory.")]),e._v(" "),o("p",[o("strong",[e._v("Q: Should "),o("code",[e._v("NewPooledTransactionHashes (0x08)")]),e._v(" deduplicate from disk?")])]),e._v(" "),o("p",[e._v("Similarly to "),o("code",[e._v("GetPooledTransactions (0x09)")]),e._v(", "),o("code",[e._v("NewPooledTransactionHashes (0x08)")]),e._v(" should also only operate on the transaction pool and should ignore the disk altogether. During healthy network conditions, a transaction will propagate through much faster than it's included in a block, so it will essentially be non-existent that a newly announced transaction is already on disk. By avoiding disk deduplication, we can avoid a DoS griefing by remote transaction announces.")]),e._v(" "),o("p",[e._v("If we want to be really correct and avoid even the slightest data race when deduplicating announcements, we can use the same recently-included-transactions trick that we discussed above to discard announcements that have recently become stale.")]),e._v(" "),o("p",[o("strong",[e._v("Q: Why not reuse "),o("code",[e._v("Transaction (0x02)")]),e._v(" instead of a new "),o("code",[e._v("PooledTransactions (0x0a)")]),e._v("?")])]),e._v(" "),o("p",[e._v("Originally this EIP reused the existing "),o("code",[e._v("Transaction (0x02)")]),e._v(" message as the reply to the "),o("code",[e._v("GetPooledTransactions (0x09)")]),e._v(" request. This makes client code more complicated, because nodes constantly gossip "),o("code",[e._v("Transaction (0x02)")]),e._v(" messages to each other as broadcasts, so it's hard to match up which of the many messages is the actual reply to the request.")]),e._v(" "),o("p",[e._v("By keeping "),o("code",[e._v("Transaction (0x02)")]),e._v(" and "),o("code",[e._v("PooledTransactions (0x0a)")]),e._v(" as separate messages, we can also leave the protocol more flexible for future optimizations (e.g. adding request IDs, which are meaningless for gossip broadcasts).")]),e._v(" "),o("h2",{attrs:{id:"backwards-compatibility"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),o("p",[e._v("This EIP extends the "),o("code",[e._v("eth")]),e._v(" protocol in a backwards incompatible way and requires rolling out a new version, "),o("code",[e._v("eth/65")]),e._v(". However, "),o("code",[e._v("devp2p")]),e._v(" supports running multiple versions of the same wire protocol side-by-side, so rolling out "),o("code",[e._v("eth/65")]),e._v(" does not require client coordination, since non-updated clients can keep using "),o("code",[e._v("eth/64")]),e._v(".")]),e._v(" "),o("p",[e._v("This EIP does not change the consensus engine, thus does "),o("em",[e._v("not")]),e._v(" require a hard fork.")]),e._v(" "),o("h2",{attrs:{id:"test-cases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),o("p",[e._v("TODO")]),e._v(" "),o("h2",{attrs:{id:"implementation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),o("p",[e._v("Geth: https://github.com/ethereum/go-ethereum/pull/20234")]),e._v(" "),o("h2",{attrs:{id:"copyright"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),o("p",[e._v("Copyright and related rights waived via "),o("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),o("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);