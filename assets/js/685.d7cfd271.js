(window.webpackJsonp=window.webpackJsonp||[]).push([[685],{1106:function(v,_,t){"use strict";t.r(_);var e=t(46),a=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"摘要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[v._v("#")]),v._v(" 摘要")]),v._v(" "),t("p",[v._v("这是一个添加新操作码 "),t("code",[v._v("CALLDEPTH")]),v._v(" 的建议。 "),t("code",[v._v("CALLDEPTH")]),v._v(" 操作码将返回剩余的可用调用堆栈深度。")]),v._v(" "),t("h1",{attrs:{id:"动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[v._v("#")]),v._v(" 动机")]),v._v(" "),t("p",[v._v("调用堆栈限制了一个合约可以调用其他合约的深度。目前的限制是 "),t("code",[v._v("256")]),v._v("。如果一个合约调用另一个合约（通过 "),t("code",[v._v("CALL")]),v._v(" 或 "),t("code",[v._v("CALLCODE")]),v._v("），如果已经达到调用堆栈深度限制，操作将失败。")]),v._v(" "),t("p",[v._v("这种行为使得合约有可能受到“调用堆栈攻击”[1]。在这种攻击中，攻击者首先创建一个合适的堆栈深度，例如通过递归调用。在这一步之后，攻击者调用目标合约。如果目标调用另一个合同，该调用将失败。如果没有正确地检查返回值以确定调用是否成功，那么结果可能是有害的。")]),v._v(" "),t("p",[v._v("例子：")]),v._v(" "),t("ol",[t("li",[v._v("合约 "),t("code",[v._v("A")]),v._v(" 希望被定期调用，并在每个块中向调用方支付 Ether。")]),v._v(" "),t("li",[v._v("当合约 "),t("code",[v._v("A")]),v._v(" 被调用时，它调用合约 "),t("code",[v._v("B")]),v._v(" 和 "),t("code",[v._v("C")]),v._v("，这将消耗大量的 gas。调用之后，合约 "),t("code",[v._v("A")]),v._v(" 将 Ether 支付给调用方。")]),v._v(" "),t("li",[v._v("恶意用户 "),t("code",[v._v("X")]),v._v(" 在调用 A 之前确保堆栈深度较浅。对 "),t("code",[v._v("B")]),v._v(" 和 "),t("code",[v._v("C")]),v._v(" 的调用都失败了，但 "),t("code",[v._v("X")]),v._v(" 仍然可以获得奖励。")])]),v._v(" "),t("p",[v._v("有两种方法可以防止这种情况：")]),v._v(" "),t("ol",[t("li",[v._v("调用后检查返回值。")]),v._v(" "),t("li",[v._v("通过实验检查调用堆栈深度。由 Piper Merriam 编写的[2]库可以解决这个问题。但这种方法的 gas 成本很高。")])]),v._v(" "),t("p",[v._v("[1] 又称“浅栈攻击”和“栈攻击”。然而，准确地说，“堆栈（stack）”一词在 EVM 中有不同的含义，不能与“调用堆栈（call stack）”混淆。")]),v._v(" "),t("p",[v._v("[2] https://github.com/pipermerriam/ethereum-stack-depth-lib")]),v._v(" "),t("h1",{attrs:{id:"规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#规范"}},[v._v("#")]),v._v(" 规范")]),v._v(" "),t("p",[v._v("操作码 "),t("code",[v._v("CALLDEPTH")]),v._v(" 应该返回剩余的调用堆栈深度。值 "),t("code",[v._v("0")]),v._v(" 表示调用堆栈已耗尽，不能再进行调用。")]),v._v(" "),t("h1",{attrs:{id:"基本原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本原理"}},[v._v("#")]),v._v(" 基本原理")]),v._v(" "),t("p",[v._v("实际的调用堆栈深度以及调用堆栈深度限制在执行期间存在于 EVM 中，但在 EVM 中不可用。实现应该相当简单，并将提供一种廉价的方法来防止调用堆栈攻击。")]),v._v(" "),t("h1",{attrs:{id:"实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[v._v("#")]),v._v(" 实现")]),v._v(" "),t("p",[v._v("没有实现。")])])}),[],!1,null,null,null);_.default=a.exports}}]);