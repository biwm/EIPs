(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{691:function(t,e,a){"use strict";a.r(e);var s=a(46),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[t._v("#")]),t._v(" Simple Summary")]),t._v(" "),a("p",[t._v("Add a "),a("code",[t._v("IS_STATIC (0x4A)")]),t._v(" opcode that pushes "),a("code",[t._v("1")]),t._v(" if the current context is static (ie. the execution is in a "),a("code",[t._v("STATICCALL")]),t._v(" or a descendant thereof, so state-changing operations are not possible), and "),a("code",[t._v("0")]),t._v(" if it is not.")]),t._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),a("p",[t._v("The main intended use case is to allow account abstraction (EIP 2938) to be extended so that accounts can allow static calls from the outside (which are harmless to AA's security model) but not state-changing calls.")]),t._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),a("p",[t._v("Add a "),a("code",[t._v("IS_STATIC (0x4A)")]),t._v(" opcode that pushes "),a("code",[t._v("1")]),t._v(" if the current context is static (ie. the execution is in a "),a("code",[t._v("STATICCALL")]),t._v(" or a descendant thereof, so state-changing operations are not possible), and "),a("code",[t._v("0")]),t._v(" if it is not.")]),t._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),a("p",[t._v("Determining staticness is already possibly using the following hacky technique: make a "),a("code",[t._v("CALL")]),t._v(" with limited gas, and inside that "),a("code",[t._v("CALL")]),t._v(" issue one "),a("code",[t._v("LOG")]),t._v(" and exit. If the context is static, the "),a("code",[t._v("CALL")]),t._v(" would fail and leave a 0 on the stack; if the context is non-static, the "),a("code",[t._v("CALL")]),t._v(" would succeed. However, this technique is fragile against changes to gas costs, and is needlessly wasteful. Hence, the status quo neither allows a reasonably effective way of determining whether or not the context is static, nor provides any kind of invariant that executions that do not fail outright will execute the same way in a static and non-static context. This EIP provides a cleaner way of determining staticness.")]),t._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[t._v("#")]),t._v(" Backwards Compatibility")]),t._v(" "),a("p",[t._v("TBD")]),t._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[t._v("#")]),t._v(" Security Considerations")]),t._v(" "),a("p",[t._v("TBD")]),t._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[t._v("#")]),t._v(" Copyright")]),t._v(" "),a("p",[t._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CC0"),a("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);e.default=i.exports}}]);