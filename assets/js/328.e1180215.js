(window.webpackJsonp=window.webpackJsonp||[]).push([[328],{731:function(e,t,o){"use strict";o.r(t);var a=o(46),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"simple-summary"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),o("p",[e._v("Introduces four new opcodes for loading data from and storing data to memory offset by a frame pointer.")]),e._v(" "),o("h2",{attrs:{id:"abstract"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),o("p",[e._v("This EIP introduces four new opcodes, "),o("code",[e._v("MLOADFP")]),e._v(", "),o("code",[e._v("MSTOREFP")]),e._v(", "),o("code",[e._v("GETFP")]),e._v(" and "),o("code",[e._v("SETFP")]),e._v(' that allow for more efficient memory access offset by a user-controlled quantity called the "frame pointer". This permits compilers to more efficiently offload ephemeral data such as local variables to memory instead of the EVM\'s evaluation stack, which has a number of benefits, including the effective elimination of restrictions on the number of local variables in a function.')]),e._v(" "),o("h2",{attrs:{id:"motivation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),o("p",[e._v("In most commonly used VMs, ephemeral data such as local variables, function arguments, and return addresses is stored in a region of memory called the stack. In contrast to the EVM's evaluation stack, this area of memory is randomly accessible, and thus can store an arbitrary amount of data, which can be referenced from anywhere they remain in scope. Although this model is possible in the current EVM design, it is made difficult by the linear model of memory (addressed in "),o("RouterLink",{attrs:{to:"/eip-3336.html"}},[e._v("EIP-3336")]),e._v(") and by the lack of opcodes for relative memory access commonly found in other architectures. This EIP proposes new opcodes that permit this form of memory use, without imposing undue burden on EVM implementers or on runtime efficiency.")],1),e._v(" "),o("p",[e._v("In the current EVM model, a compiler wishing to use this pattern would have to store the frame pointer - which points to the start or end of the current memory stack frame - in memory, and load it each time they wish to reference it. For example, loading a value from memory offset by the frame pointer would require the following sequence of operations:")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Opcode")]),e._v(" "),o("th",[e._v("Gas used")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[o("code",[e._v("PUSHn x")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("PUSH1 0")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MLOAD")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("ADD")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MLOAD")])]),e._v(" "),o("td",[e._v("3")])])])]),e._v(" "),o("p",[e._v("This consumes a total of 15 gas, and takes up at least 7 bytes of bytecode each time it is referenced. In contrast, after this EIP, the equivalent sequence of operations is:")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Opcode")]),e._v(" "),o("th",[e._v("Gas used")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[o("code",[e._v("PUSH1 x")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MLOADFP")])]),e._v(" "),o("td",[e._v("3")])])])]),e._v(" "),o("p",[e._v("This consumes only 6 gas, and takes at least 3 bytes of bytecode. The effort required from the EVM implementation is equivalent, costing only one extra addition operation over a regular "),o("code",[e._v("MLOAD")]),e._v(". The alternative of storing values on the stack, which requires 3 gas and 1 byte of bytecode for a "),o("code",[e._v("DUPn")]),e._v(" operation, but it is now at most twice as efficient rather than 5 times as efficient, making storing values in memory a viable alternative.")]),e._v(" "),o("p",[e._v("Likewise, before this EIP a frame-pointer relative store requires the following sequence of operations:")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Opcode")]),e._v(" "),o("th",[e._v("Gas used")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[o("code",[e._v("PUSHn x")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("PUSH1 0")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MLOAD")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("ADD")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MSTORE")])]),e._v(" "),o("td",[e._v("3")])])])]),e._v(" "),o("p",[e._v("This consumes 15 gas and at least 7 bytes of bytecode. After this EIP, the equivalent sequence of operations is:")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Opcode")]),e._v(" "),o("th",[e._v("Gas used")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[o("code",[e._v("PUSHn x")])]),e._v(" "),o("td",[e._v("3")])]),e._v(" "),o("tr",[o("td",[o("code",[e._v("MSTOREFP")])]),e._v(" "),o("td",[e._v("3")])])])]),e._v(" "),o("p",[e._v("Consuming only 6 gas and at least 3 bytes of bytecode, while once again only requiring EVM implementations to do one extra addition operation. The alternative of storing values on the stack requires 6 gas and 2 bytes of bytecode for the sequence "),o("code",[e._v("SWAPn POP")]),e._v(", making it no more efficient than memory storage.")]),e._v(" "),o("h2",{attrs:{id:"specification"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),o("h3",{attrs:{id:"parameters"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),o("table",[o("thead",[o("tr",[o("th",[e._v("Constant")]),e._v(" "),o("th",[e._v("Value")])])]),e._v(" "),o("tbody",[o("tr",[o("td",[o("code",[e._v("FORK_BLOCK")])]),e._v(" "),o("td",[e._v("TBD")])])])]),e._v(" "),o("p",[e._v("For blocks where "),o("code",[e._v("block.number >= FORK_BLOCK")]),e._v(", the following changes apply.")]),e._v(" "),o("h3",{attrs:{id:"frame-pointer"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#frame-pointer"}},[e._v("#")]),e._v(" Frame pointer")]),e._v(" "),o("p",[e._v('A new EVM internal state variable called the "frame pointer" is introduced. This is a signed integer that starts at 0.')]),e._v(" "),o("h3",{attrs:{id:"setfp-opcode"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#setfp-opcode"}},[e._v("#")]),e._v(" "),o("code",[e._v("SETFP")]),e._v(" opcode")]),e._v(" "),o("p",[e._v("A new opcode, "),o("code",[e._v("SETFP")]),e._v(" is introduced with value "),o("code",[e._v("0x5c")]),e._v(". This opcode costs "),o("code",[e._v("G_low")]),e._v(" (3 gas) and takes one argument from the stack. The argument is stored as the new value of the frame pointer.")]),e._v(" "),o("h3",{attrs:{id:"getfp-opcode"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#getfp-opcode"}},[e._v("#")]),e._v(" "),o("code",[e._v("GETFP")]),e._v(" opcode")]),e._v(" "),o("p",[e._v("A new opcode, "),o("code",[e._v("GETFP")]),e._v(" is introduced with value "),o("code",[e._v("0x5d")]),e._v(". This opcode costs "),o("code",[e._v("G_low")]),e._v(" (3 gas) and takes no arguments. It takes the current value of the frame pointer and pushes it to the stack.")]),e._v(" "),o("h3",{attrs:{id:"mloadfp-opcode"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mloadfp-opcode"}},[e._v("#")]),e._v(" "),o("code",[e._v("MLOADFP")]),e._v(" opcode")]),e._v(" "),o("p",[e._v("A new opcode "),o("code",[e._v("MLOADFP")]),e._v(" is introduced with value "),o("code",[e._v("0x5e")]),e._v(". This opcode acts in all ways identical to "),o("code",[e._v("MLOAD")]),e._v(", except that the value of the frame pointer is added to the address before loading data from memory. An attempt to load data from a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.")]),e._v(" "),o("h3",{attrs:{id:"mstorefp-opcode"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mstorefp-opcode"}},[e._v("#")]),e._v(" "),o("code",[e._v("MSTOREFP")]),e._v(" opcode")]),e._v(" "),o("p",[e._v("A new opcode "),o("code",[e._v("MSTOREFP")]),e._v(" is introduced with value "),o("code",[e._v("0x5f")]),e._v(". This opcode acts in all ways identical to "),o("code",[e._v("MSTORE")]),e._v(", except that the value of the frame pointer is added to the address before storing data to memory. An attempt to store data to a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.")]),e._v(" "),o("h2",{attrs:{id:"rationale"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),o("h3",{attrs:{id:"cost-of-new-opcodes"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cost-of-new-opcodes"}},[e._v("#")]),e._v(" Cost of new opcodes")]),e._v(" "),o("p",[e._v("The cost of the new opcodes "),o("code",[e._v("MLOADFP")]),e._v(" and "),o("code",[e._v("MSTOREFP")]),e._v(" reflects the cost of "),o("code",[e._v("MLOAD")]),e._v(" and "),o("code",[e._v("MSTORE")]),e._v(". They are generally equivalent in cost with the exception of an extra addition operation, which imposes negligible cost.")]),e._v(" "),o("p",[e._v("The cost of the new opcodes "),o("code",[e._v("SETFP")]),e._v(" and "),o("code",[e._v("GETFP")]),e._v(" is based on other common low-cost opcodes such as "),o("code",[e._v("PUSH")]),e._v(" and "),o("code",[e._v("POP")]),e._v(".")]),e._v(" "),o("h3",{attrs:{id:"absence-of-mstore8fp"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#absence-of-mstore8fp"}},[e._v("#")]),e._v(" Absence of "),o("code",[e._v("MSTORE8FP")])]),e._v(" "),o("p",[o("code",[e._v("MSTORE8FP")]),e._v(" opcode was not included because it is expected that it would be used infrequently, and there is a desire to minimise the size of the instruction set and to conserve opcodes for future use.")]),e._v(" "),o("h2",{attrs:{id:"backwards-compatibility"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),o("p",[e._v("This EIP exclusively introduces new opcodes, and as a result should not impact any existing programs unless they operate under the assumption that these opcodes are undefined, which we believe will not be the case.")]),e._v(" "),o("h2",{attrs:{id:"security-considerations"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),o("p",[e._v("DoS risks are mitigated by correct pricing of opcodes to reflect current execution costs. No other security considerations pertain to this EIP.")]),e._v(" "),o("h2",{attrs:{id:"copyright"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),o("p",[e._v("Copyright and related rights waived via "),o("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),o("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);