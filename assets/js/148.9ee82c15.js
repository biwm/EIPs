(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{540:function(e,t,a){"use strict";a.r(t);var n=a(46),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Introduce account versioning for smart contracts so upgrading the VM\nor introducing new VMs can be easier.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This defines a method of hard forking while maintaining the exact\nfunctionality of existing account by allowing multiple versions of the\nvirtual machines to execute in the same block. This is also useful to\ndefine future account state structures when we introduce the on-chain\nWebAssembly virtual machine.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("By allowing account versioning, we can execute different virtual\nmachine for contracts created at different times. This allows breaking\nfeatures to be implemented while making sure existing contracts work\nas expected.")]),e._v(" "),a("p",[e._v("Note that this specification might not apply to all hard forks. We\nhave emergency hard forks in the past due to network attacks. Whether\nthey should maintain existing account compatibility should be\nevaluated in individual basis. If the attack can only be executed once\nagainst some particular contracts, then the scheme defined here might\nstill be applicable. Otherwise, having a plain emergency hard fork\nmight still be a good idea.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("h3",{attrs:{id:"account-state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#account-state"}},[e._v("#")]),e._v(" Account State")]),e._v(" "),a("p",[e._v("Re-define account state stored in the world state trie to have 5\nitems: "),a("code",[e._v("nonce")]),e._v(", "),a("code",[e._v("balance")]),e._v(", "),a("code",[e._v("storageRoot")]),e._v(", "),a("code",[e._v("codeHash")]),e._v(", and\n"),a("code",[e._v("version")]),e._v(". The newly added field "),a("code",[e._v("version")]),e._v(" is a 256-bit "),a("strong",[e._v("scalar")]),e._v('. We\nuse the definition of "scalar" from Yellow Paper. Note that this is\nthe same type as '),a("code",[e._v("nonce")]),e._v(" and "),a("code",[e._v("balance")]),e._v(", and it is equivalent to a RLP\nvariable-sized byte array with no leading zero, of maximum length 32.")]),e._v(" "),a("p",[e._v("When "),a("code",[e._v("version")]),e._v(" is zero, the account is RLP-encoded with the first 4\nitems. When "),a("code",[e._v("version")]),e._v(" is not zero, the account is RLP-encoded with 5\nitems.")]),e._v(" "),a("p",[e._v("Account versions can also optionally define additional account state\nRLP fields, whose meaning are specified through its "),a("code",[e._v("version")]),e._v('\nfield. In those cases, the parsing strategy is defined in "Additional\nFields in Account State RLP" section.')]),e._v(" "),a("h3",{attrs:{id:"contract-execution"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contract-execution"}},[e._v("#")]),e._v(" Contract Execution")]),e._v(" "),a("p",[e._v("When fetching an account code from state, we always fetch the\nassociated version field together. We refer to this as the "),a("em",[e._v("code's\nversion")]),e._v(" below. The code of the account is always executed in the\n"),a("em",[e._v("code's version")]),e._v(".")]),e._v(" "),a("p",[e._v("In particular, this means that for "),a("code",[e._v("DELEGATECALL")]),e._v(" and "),a("code",[e._v("CALLCODE")]),e._v(", the\nversion of the execution call frame is the same as\ndelegating/receiving contract's version.")]),e._v(" "),a("h3",{attrs:{id:"contract-deployment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contract-deployment"}},[e._v("#")]),e._v(" Contract Deployment")]),e._v(" "),a("p",[e._v("In Ethereum, a contract has a deployment method, either by a contract\ncreation transaction, or by another contract. If we regard this\ndeployment method a contract's "),a("em",[e._v("parent")]),e._v(", then we find them forming a\nfamily of contracts, with the "),a("em",[e._v("root")]),e._v(" being a contract creation\ntransaction.")]),e._v(" "),a("p",[e._v("We let a family of contracts to always have the same "),a("code",[e._v("version")]),e._v(". That\nis, "),a("code",[e._v("CREATE")]),e._v(" and "),a("code",[e._v("CREATE2")]),e._v(" will always deploy contract that has the\nsame "),a("code",[e._v("version")]),e._v(" as the "),a("em",[e._v("code's version")]),e._v(".")]),e._v(" "),a("p",[e._v("In other words, "),a("code",[e._v("CREATE")]),e._v(" and "),a("code",[e._v("CREATE2")]),e._v(" will execute the init code\nusing the current "),a("em",[e._v("code's version")]),e._v(", and deploy the contract of the\ncurrent "),a("em",[e._v("code's version")]),e._v(". This holds even if the to-be-deployed code\nis empty.")]),e._v(" "),a("h3",{attrs:{id:"validation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validation"}},[e._v("#")]),e._v(" Validation")]),e._v(" "),a("p",[e._v("A new phrase, "),a("em",[e._v("validation")]),e._v(" is added to contract deployment (by\n"),a("code",[e._v("CREATE")]),e._v(" / "),a("code",[e._v("CREATE2")]),e._v(" opcodes, or by contract creation\ntransaction). When "),a("code",[e._v("version")]),e._v(" is "),a("code",[e._v("0")]),e._v(", the phrase does nothing and\nalways succeeds. Future VM versions can define additional validation\nthat has to be passed.")]),e._v(" "),a("p",[e._v("If the validation phrase fails, deployment does not proceed and return\nout-of-gas.")]),e._v(" "),a("h3",{attrs:{id:"contract-creation-transaction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#contract-creation-transaction"}},[e._v("#")]),e._v(" Contract Creation Transaction")]),e._v(" "),a("p",[e._v("Define "),a("code",[e._v("LATEST_VERSION")]),e._v(" in a hard fork to be the latest supported VM\nversion. A contract creation transaction is always executed in\n"),a("code",[e._v("LATEST_VERSION")]),e._v(" (which means the "),a("em",[e._v("code's version")]),e._v(" is\n"),a("code",[e._v("LATEST_VERSION")]),e._v("), and deploys contracts of "),a("code",[e._v("LATEST_VERSION")]),e._v(". Before a\ncontract creation transaction is executed, run "),a("em",[e._v("validation")]),e._v(" on the\ncontract creation code. If it does not pass, return out-of-gas.")]),e._v(" "),a("h3",{attrs:{id:"precompiled-contract-and-externally-owned-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#precompiled-contract-and-externally-owned-address"}},[e._v("#")]),e._v(" Precompiled Contract and Externally-owned Address")]),e._v(" "),a("p",[e._v("Precompiled contracts and externally-owned addresses do not have\n"),a("code",[e._v("version")]),e._v(". If a message-call transaction or "),a("code",[e._v("CALL")]),e._v(" / "),a("code",[e._v("CALLCODE")]),e._v(" /\n"),a("code",[e._v("STATICCALL")]),e._v(" / "),a("code",[e._v("DELEGATECALL")]),e._v(" touches a new externally-owned address\nor a non-existing precompiled contract address, it is always created\nwith "),a("code",[e._v("version")]),e._v(" field being "),a("code",[e._v("0")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"additional-fields-in-account-state-rlp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#additional-fields-in-account-state-rlp"}},[e._v("#")]),e._v(" Additional Fields in Account State RLP")]),e._v(" "),a("p",[e._v("In the future we may need to associate more information into an\naccount, and we already have some EIPs that define new additional\nfields in the account state RLP. In this section, we define the\nparsing strategy when additional fields are added.")]),e._v(" "),a("ul",[a("li",[e._v("Check the RLP list length, if it is 4, then set account version to\n"),a("code",[e._v("0")]),e._v(", and do not parse any additional fields.")]),e._v(" "),a("li",[e._v("If the RLP list length more than 4, set the account version to the\nscalar at position "),a("code",[e._v("4")]),e._v(" (counting from "),a("code",[e._v("0")]),e._v(").\n"),a("ul",[a("li",[e._v("Check version specification for the number of additional fields\ndefined "),a("code",[e._v("N")]),e._v(", if the RLP list length is not equal to "),a("code",[e._v("5 + N")]),e._v(",\nreturn parse error.")]),e._v(" "),a("li",[e._v("Parse RLP position "),a("code",[e._v("5")]),e._v(" to "),a("code",[e._v("4 + N")]),e._v(" as the meaning specified in\nadditional fields.")])])])]),e._v(" "),a("h2",{attrs:{id:"extensions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extensions"}},[e._v("#")]),e._v(" Extensions")]),e._v(" "),a("p",[e._v('In relation to the above "Specification" section, we have defined the\nbase account versioning layer. The base account versioning layer is\nalready useful by itself and can handle most EVM improvements. Below\nwe define two specifications that can be deployed separately, which\nimproves functionality of base layer account versioning.')]),e._v(" "),a("p",[e._v('Note that this section is provided only for documentation\npurpose. When "enabling EIP-1702", those extensions should not be\nenabled unless the extension specification is also included.')]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://specs.corepaper.org/44-vertxn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("44-VERTXN: Account Versioning Extension for Contract Creation\nTransaction"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://specs.corepaper.org/45-verop/",target:"_blank",rel:"noopener noreferrer"}},[e._v("45-VEROP: Account Versioning Extension for CREATE and\nCREATE2"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"usage-template"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#usage-template"}},[e._v("#")]),e._v(" Usage Template")]),e._v(" "),a("p",[e._v("This section defines how other EIPs might use this account\nversioning specification. Note that currently we only define the usage\ntemplate for base layer.")]),e._v(" "),a("p",[e._v("Account versioning is usually applied directly to a hard fork\nmeta. EIPs in the hard fork are grouped by the virtual machine\ntype, for example, EVM and eWASM. For each of them, we define:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Version")]),e._v(": a non-zero scalar less than "),a("code",[e._v("2^256")]),e._v(" that uniquely\nidentifies this version. Note that it does not need to be\nsequential.")]),e._v(" "),a("li",[a("strong",[e._v("Parent version")]),e._v(": the base that all new features derived\nfrom. With parent version of "),a("code",[e._v("0")]),e._v(" we define the base to be legacy\nVM. Note that once a version other than "),a("code",[e._v("0")]),e._v(" is defined, the legacy\nVM's feature set must be frozen. When defining an entirely new VM\n(such as eWASM), parent version does not apply.")]),e._v(" "),a("li",[a("strong",[e._v("Features")]),e._v(": all additional features that are enabled upon this\nversion.")])]),e._v(" "),a("p",[e._v("If a meta EIP includes EIPs that provide additional account state RLP\nfields, we also define:")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Account fields")]),e._v(": all account fields up to the end of this meta\nEIP, excluding the basic 5 fields ("),a("code",[e._v("nonce")]),e._v(", "),a("code",[e._v("balance")]),e._v(",\n"),a("code",[e._v("storageRoot")]),e._v(", "),a("code",[e._v("codeHash")]),e._v(" and "),a("code",[e._v("version")]),e._v("). If EIPs included that are\nspecific to modifying account fields do not modify VM execution\nlogic, it is recommended that we specify an additional version whose\nexecution logic is the same as previous version, but only the\naccount fields are changed.")])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("This introduces account versioning via a new RLP item in account\nstate. The design above gets account versioning by making the contract\n"),a("em",[e._v("family")]),e._v(" always have the same version. In this way, versions are only\nneeded to be provided by contract creation transaction, and there is\nno restrictions on formats of code for any version. If we want to\nsupport multiple newest VMs (for example, EVM and WebAssembly running\ntogether), then this will requires extensions such as 44-VERTXN and\n45-VEROP.")]),e._v(" "),a("p",[e._v("Alternatively, account versioning can also be done through:")]),e._v(" "),a("ul",[a("li",[a("strong",[a("a",{attrs:{href:"https://specs.corepaper.org/26-ver/",target:"_blank",rel:"noopener noreferrer"}},[e._v("26-VER"),a("OutboundLink")],1)]),e._v(" and\n"),a("strong",[a("a",{attrs:{href:"https://specs.corepaper.org/40-unused/",target:"_blank",rel:"noopener noreferrer"}},[e._v("40-UNUSED"),a("OutboundLink")],1)]),e._v(": This makes an\naccount's versioning soly dependent on its code header prefix. If\nwith only 26-VER, it is not possible to certify any code is valid,\nbecause current VM allows treating code as data. This can be fixed\nby 40-UNUSED, but the drawback is that it's potentially backward\nincompatible.")]),e._v(" "),a("li",[a("strong",[e._v("EIP-1891")]),e._v(": Instead of writing version field into account RLP\nstate, we write it in a separate contract. This can accomplish the\nsame thing as this EIP and potentially reduces code complexity, but\nthe drawback is that every code execution will require an additional\ntrie traversal, which impacts performance.")])]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("Account versioning is fully backwards compatible, and it does not\nchange how current contracts are executed.")]),e._v(" "),a("h2",{attrs:{id:"discussions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#discussions"}},[e._v("#")]),e._v(" Discussions")]),e._v(" "),a("h3",{attrs:{id:"performance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance"}},[e._v("#")]),e._v(" Performance")]),e._v(" "),a("p",[e._v("Currently nearly all full node implementations uses config parameters\nto decide which virtual machine version to use. Switching virtual\nmachine version is simply an operation that changes a pointer using a\ndifferent set of config parameters. As a result, this scheme has\nnearly zero impact to performance.")]),e._v(" "),a("h3",{attrs:{id:"webassembly"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webassembly"}},[e._v("#")]),e._v(" WebAssembly")]),e._v(" "),a("p",[e._v("This scheme can also be helpful when we deploy on-chain WebAssembly\nvirtual machine. In that case, WASM contracts and EVM contracts can\nco-exist and the execution boundary and interaction model are clearly\ndefined as above.")]),e._v(" "),a("h2",{attrs:{id:"test-cases-and-implementations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases-and-implementations"}},[e._v("#")]),e._v(" Test Cases and Implementations")]),e._v(" "),a("p",[e._v("To be added.")]),e._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("p",[e._v("The source of this specification can be found at\n"),a("a",{attrs:{href:"https://specs.corepaper.org/43-ver/",target:"_blank",rel:"noopener noreferrer"}},[e._v("43-VER"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);