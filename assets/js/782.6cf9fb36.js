(window.webpackJsonp=window.webpackJsonp||[]).push([[782],{1208:function(e,t,a){"use strict";a.r(t);var s=a(46),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Signing data is a solved problem if all we care about are bytestrings. Unfortunately in the real world we care about complex meaningful messages. Hashing structured data is non-trivial and errors result in loss of the security properties of the system.")]),e._v(" "),a("p",[e._v('As such, the adage "don\'t roll your own crypto" applies. Instead, a peer-reviewed well-tested standard method needs to be used. This EIP aims to be that standard.')]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This is a standard for hashing and signing of typed structured data as opposed to just bytestrings. It includes a")]),e._v(" "),a("ul",[a("li",[e._v("theoretical framework for correctness of encoding functions,")]),e._v(" "),a("li",[e._v("specification of structured data similar to and compatible with Solidity structs,")]),e._v(" "),a("li",[e._v("safe hashing algorithm for instances of those structures,")]),e._v(" "),a("li",[e._v("safe inclusion of those instances in the set of signable messages,")]),e._v(" "),a("li",[e._v("an extensible mechanism for domain separation,")]),e._v(" "),a("li",[e._v("new RPC call "),a("code",[e._v("eth_signTypedData")]),e._v(", and")]),e._v(" "),a("li",[e._v("an optimized implementation of the hashing algorithm in EVM.")])]),e._v(" "),a("p",[e._v("It does not include replay protection.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("This EIP aims to improve the usability of off-chain message signing for use on-chain. We are seeing growing adoption of off-chain message signing as it saves gas and reduces the number of transactions on the blockchain. Currently signed messages are an opaque hex string displayed to the user with little context about the items that make up the message.")]),e._v(" "),a("img",{staticStyle:{"padding-bottom":"20px","padding-top":"20px"},attrs:{src:"https://github.com/ethereum/EIPs/blob/master/assets/eip-712/eth_sign.png?raw=true",width:"60%"}}),e._v(" "),a("p",[e._v("Here we outline a scheme to encode data along with its structure which allows it to be displayed to the user for verification when signing. Below is an example of what a user could be shown when signing an EIP712 message.")]),e._v(" "),a("img",{staticStyle:{"padding-bottom":"20px","padding-top":"20px"},attrs:{src:"https://github.com/ethereum/EIPs/blob/master/assets/eip-712/eth_signTypedData.png?raw=true",width:"60%"}}),e._v(" "),a("h3",{attrs:{id:"signatures-and-hashing-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signatures-and-hashing-overview"}},[e._v("#")]),e._v(" Signatures and Hashing overview")]),e._v(" "),a("p",[e._v("A signature scheme consists of hashing algorithm and a signing algorithm. The signing algorithm of choice in Ethereum is "),a("code",[e._v("secp256k1")]),e._v(". The hashing algorithm of choice is "),a("code",[e._v("keccak256")]),e._v(", this is a function from bytestrings, ùîπ‚Å∏‚Åø, to 256-bit strings, ùîπ¬≤‚Åµ‚Å∂.")]),e._v(" "),a("p",[e._v("A good hashing algorithm should satisfy security properties such as determinism, second pre-image resistance and collision resistance. The "),a("code",[e._v("keccak256")]),e._v(" function satisfies the above criteria "),a("em",[e._v("when applied to bytestrings")]),e._v(". If we want to apply it to other sets we first need to map this set to bytestrings. It is critically important that this encoding function is "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Deterministic_algorithm",target:"_blank",rel:"noopener noreferrer"}},[e._v("deterministic"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Injective_function",target:"_blank",rel:"noopener noreferrer"}},[e._v("injective"),a("OutboundLink")],1),e._v(". If it is not deterministic then the hash might differ from the moment of signing to the moment of verifying, causing the signature to incorrectly be rejected. If it is not injective then there are two different elements in our input set that hash to the same value, causing a signature to be valid for a different unrelated message.")]),e._v(" "),a("h3",{attrs:{id:"transactions-and-bytestrings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactions-and-bytestrings"}},[e._v("#")]),e._v(" Transactions and bytestrings")]),e._v(" "),a("p",[e._v("An illustrative example of the above breakage can be found in Ethereum. Ethereum has two kinds of messages, transactions "),a("code",[e._v("ùïã")]),e._v(" and bytestrings "),a("code",[e._v("ùîπ‚Å∏‚Åø")]),e._v(". These are signed using "),a("code",[e._v("eth_sendTransaction")]),e._v(" and "),a("code",[e._v("eth_sign")]),e._v(" respectively. Originally the encoding function "),a("code",[e._v("encode : ùïã ‚à™ ùîπ‚Å∏‚Åø ‚Üí ùîπ‚Å∏‚Åø")]),e._v(" was defined as follows:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("encode(t : ùïã) = RLP_encode(t)")])]),e._v(" "),a("li",[a("code",[e._v("encode(b : ùîπ‚Å∏‚Åø) = b")])])]),e._v(" "),a("p",[e._v("While individually they satisfy the required properties, together they do not. If we take "),a("code",[e._v("b = RLP_encode(t)")]),e._v(" we have a collision. This is mitigated in Geth "),a("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/pull/2940",target:"_blank",rel:"noopener noreferrer"}},[e._v("PR 2940"),a("OutboundLink")],1),e._v(" by modifying the second leg of the encoding function:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('encode(b : ùîπ‚Å∏‚Åø) = "\\x19Ethereum Signed Message:\\n" ‚Äñ len(b) ‚Äñ b')]),e._v(" where "),a("code",[e._v("len(b)")]),e._v(" is the ascii-decimal encoding of the number of bytes in "),a("code",[e._v("b")]),e._v(".")])]),e._v(" "),a("p",[e._v("This solves the collision between the legs since "),a("code",[e._v("RLP_encode(t : ùïã)")]),e._v(" never starts with "),a("code",[e._v("\\x19")]),e._v(". There is still the risk of the new encoding function not being deterministic or injective. It is instructive to consider those in detail.")]),e._v(" "),a("p",[e._v("As is, the definition above is not deterministic. For a 4-byte string "),a("code",[e._v("b")]),e._v(" both encodings with "),a("code",[e._v('len(b) = "4"')]),e._v(" and "),a("code",[e._v('len(b) = "004"')]),e._v(" are valid. This can be solved by further requiring that the decimal encoding of the length has no leading zeros and "),a("code",[e._v('len("") = "0"')]),e._v(".")]),e._v(" "),a("p",[e._v("The above definition is not obviously collision free. Does a bytestring starting with "),a("code",[e._v('"\\x19Ethereum Signed Message:\\n42a‚Ä¶"')]),e._v(" mean a 42-byte string starting with "),a("code",[e._v("a")]),e._v(" or a 4-byte string starting with "),a("code",[e._v("2a")]),e._v("?. This was pointed out in "),a("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/issues/14794",target:"_blank",rel:"noopener noreferrer"}},[e._v("Geth issue #14794"),a("OutboundLink")],1),e._v(" and motivated Trezor to "),a("a",{attrs:{href:"https://github.com/trezor/trezor-mcu/issues/163",target:"_blank",rel:"noopener noreferrer"}},[e._v("not implement the standard"),a("OutboundLink")],1),e._v(" as-is. Fortunately this does not lead to actual collisions as the total length of the encoded bytestring provides sufficient information to disambiguate the cases.")]),e._v(" "),a("p",[e._v("Both determinism and injectiveness would be trivially true if "),a("code",[e._v("len(b)")]),e._v(" was left out entirely. The point is, it is difficult to map arbitrary sets to bytestrings without introducing security issues in the encoding function. Yet the current design of "),a("code",[e._v("eth_sign")]),e._v(" still takes a bytestring as input and expects implementors to come up with an encoding.")]),e._v(" "),a("h3",{attrs:{id:"arbitrary-messages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arbitrary-messages"}},[e._v("#")]),e._v(" Arbitrary messages")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("eth_sign")]),e._v(" call assumes messages to be bytestrings. In practice we are not hashing bytestrings but the collection of all semantically different messages of all different DApps "),a("code",[e._v("ùïÑ")]),e._v(". Unfortunately, this set is impossible to formalize. Instead we approximate it with the set of typed named structures "),a("code",[e._v("ùïä")]),e._v(". This standard formalizes the set "),a("code",[e._v("ùïä")]),e._v(" and provides a deterministic injective encoding function for it.")]),e._v(" "),a("p",[e._v("Just encoding structs is not enough. It is likely that two different DApps use identical structs. When this happens, a signed message intended for one DApp would also be valid for the other. The signatures are compatible. This can be intended behaviour, in which case everything is fine as long as the DApps took replay attacks into consideration. If it is not intended, there is a security problem.")]),e._v(" "),a("p",[e._v("The way to solve this is by introducing a domain separator, a 256-bit number. This is a value unique to each domain that is 'mixed in' the signature. It makes signatures from different domains incompatible. The domain separator is designed to include bits of DApp unique information such as the name of the DApp, the intended validator contract address, the expected DApp domain name, etc. The user and user-agent can use this information to mitigate phishing attacks, where a malicious DApp tries to trick the user into signing a message for another DApp.")]),e._v(" "),a("h3",{attrs:{id:"note-on-replay-attacks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#note-on-replay-attacks"}},[e._v("#")]),e._v(" Note on replay attacks")]),e._v(" "),a("p",[e._v("This standard is only about signing messages and verifying signatures. In many practical applications, signed messages are used to authorize an action, for example an exchange of tokens. It is "),a("em",[e._v("very important")]),e._v(" that implementers make sure the application behaves correctly when it sees the same signed message twice. For example, the repeated message should be rejected or the authorized action should be idempotent. How this is implemented is specific to the application and out of scope for this standard.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("The set of signable messages is extended from transactions and bytestrings "),a("code",[e._v("ùïã ‚à™ ùîπ‚Å∏‚Åø")]),e._v(" to also include structured data "),a("code",[e._v("ùïä")]),e._v(". The new set of signable messages is thus "),a("code",[e._v("ùïã ‚à™ ùîπ‚Å∏‚Åø ‚à™ ùïä")]),e._v(". They are encoded to bytestrings suitable for hashing and signing as follows:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("encode(transaction : ùïã) = RLP_encode(transaction)")])]),e._v(" "),a("li",[a("code",[e._v('encode(message : ùîπ‚Å∏‚Åø) = "\\x19Ethereum Signed Message:\\n" ‚Äñ len(message) ‚Äñ message')]),e._v(" where "),a("code",[e._v("len(message)")]),e._v(" is the "),a("em",[e._v("non-zero-padded")]),e._v(" ascii-decimal encoding of the number of bytes in "),a("code",[e._v("message")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v('encode(domainSeparator : ùîπ¬≤‚Åµ‚Å∂, message : ùïä) = "\\x19\\x01" ‚Äñ domainSeparator ‚Äñ hashStruct(message)')]),e._v(" where "),a("code",[e._v("domainSeparator")]),e._v(" and "),a("code",[e._v("hashStruct(message)")]),e._v(" are defined below.")])]),e._v(" "),a("p",[e._v("This encoding is deterministic because the individual components are. The encoding is injective because the three cases always differ in first byte. ("),a("code",[e._v("RLP_encode(transaction)")]),e._v(" does not start with "),a("code",[e._v("\\x19")]),e._v(".)")]),e._v(" "),a("p",[e._v("The encoding is compliant with "),a("RouterLink",{attrs:{to:"/zh/eip-191.html"}},[e._v("EIP-191")]),e._v(". The 'version byte' is fixed to "),a("code",[e._v("0x01")]),e._v(", the 'version specific data' is the 32-byte domain separator "),a("code",[e._v("domainSeparator")]),e._v(" and the 'data to sign' is the 32-byte "),a("code",[e._v("hashStruct(message)")]),e._v(".")],1),e._v(" "),a("h3",{attrs:{id:"definition-of-typed-structured-data-s"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-typed-structured-data-s"}},[e._v("#")]),e._v(" Definition of typed structured data "),a("code",[e._v("ùïä")])]),e._v(" "),a("p",[e._v("To define the set of all structured data, we start with defining acceptable types. Like ABIv2 these are closely related to Solidity types. It is illustrative to adopt Solidity notation to explain the definitions. The standard is specific to the Ethereum Virtual Machine, but aims to be agnostic to higher level languages. Example:")]),e._v(" "),a("div",{staticClass:"language-Solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Mail")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" to"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("string")]),e._v(" contents"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[a("strong",[e._v("Definition")]),e._v(": A "),a("em",[e._v("struct type")]),e._v(" has valid identifier as name and contains zero or more member variables. Member variables have a member type and a name.")]),e._v(" "),a("p",[a("strong",[e._v("Definition")]),e._v(": A "),a("em",[e._v("member type")]),e._v(" can be either an atomic type, a dynamic type or a reference type.")]),e._v(" "),a("p",[a("strong",[e._v("Definition")]),e._v(": The "),a("em",[e._v("atomic types")]),e._v(" are "),a("code",[e._v("bytes1")]),e._v(" to "),a("code",[e._v("bytes32")]),e._v(", "),a("code",[e._v("uint8")]),e._v(" to "),a("code",[e._v("uint256")]),e._v(", "),a("code",[e._v("int8")]),e._v(" to "),a("code",[e._v("int256")]),e._v(", "),a("code",[e._v("bool")]),e._v(" and "),a("code",[e._v("address")]),e._v(". These correspond to their definition in Solidity. Note that there are no aliases "),a("code",[e._v("uint")]),e._v(" and "),a("code",[e._v("int")]),e._v(". Note that contract addresses are always plain "),a("code",[e._v("address")]),e._v(". Fixed point numbers are not supported by the standard. Future versions of this standard may add new atomic types.")]),e._v(" "),a("p",[a("strong",[e._v("Definition")]),e._v(": The "),a("em",[e._v("dynamic types")]),e._v(" are "),a("code",[e._v("bytes")]),e._v(" and "),a("code",[e._v("string")]),e._v(". These are like the atomic types for the purposed of type declaration, but their treatment in encoding is different.")]),e._v(" "),a("p",[a("strong",[e._v("Definition")]),e._v(": The "),a("em",[e._v("reference types")]),e._v(" are arrays and structs. Arrays are either fixed size or dynamic and denoted by "),a("code",[e._v("Type[n]")]),e._v(" or "),a("code",[e._v("Type[]")]),e._v(" respectively. Structs are references to other structs by their name. The standard supports recursive struct types.")]),e._v(" "),a("p",[a("strong",[e._v("Definition")]),e._v(": The set of structured typed data "),a("code",[e._v("ùïä")]),e._v(" contains all the instances of all the struct types.")]),e._v(" "),a("h3",{attrs:{id:"definition-of-hashstruct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-hashstruct"}},[e._v("#")]),e._v(" Definition of "),a("code",[e._v("hashStruct")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("hashStruct")]),e._v(" function is defined as")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("hashStruct(s : ùïä) = keccak256(typeHash ‚Äñ encodeData(s))")]),e._v(" where "),a("code",[e._v("typeHash = keccak256(encodeType(typeOf(s)))")])])]),e._v(" "),a("p",[a("strong",[e._v("Note")]),e._v(": The "),a("code",[e._v("typeHash")]),e._v(" is a constant for a given struct type and does not need to be runtime computed.")]),e._v(" "),a("h3",{attrs:{id:"definition-of-encodetype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-encodetype"}},[e._v("#")]),e._v(" Definition of "),a("code",[e._v("encodeType")])]),e._v(" "),a("p",[e._v("The type of a struct is encoded as "),a("code",[e._v('name ‚Äñ "(" ‚Äñ member‚ÇÅ ‚Äñ "," ‚Äñ member‚ÇÇ ‚Äñ "," ‚Äñ ‚Ä¶ ‚Äñ member‚Çô ")"')]),e._v(" where each member is written as "),a("code",[e._v('type ‚Äñ " " ‚Äñ name')]),e._v(". For example, the above "),a("code",[e._v("Mail")]),e._v(" struct is encoded as "),a("code",[e._v("Mail(address from,address to,string contents)")]),e._v(".")]),e._v(" "),a("p",[e._v("If the struct type references other struct types (and these in turn reference even more struct types), then the set of referenced struct types is collected, sorted by name and appended to the encoding. An example encoding is "),a("code",[e._v("Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"definition-of-encodedata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-encodedata"}},[e._v("#")]),e._v(" Definition of "),a("code",[e._v("encodeData")])]),e._v(" "),a("p",[e._v("The encoding of a struct instance is "),a("code",[e._v("enc(value‚ÇÅ) ‚Äñ enc(value‚ÇÇ) ‚Äñ ‚Ä¶ ‚Äñ enc(value‚Çô)")]),e._v(", i.e. the concatenation of the encoded member values in the order that they appear in the type. Each encoded member value is exactly 32-byte long.")]),e._v(" "),a("p",[e._v("The atomic values are encoded as follows: Boolean "),a("code",[e._v("false")]),e._v(" and "),a("code",[e._v("true")]),e._v(" are encoded as "),a("code",[e._v("uint256")]),e._v(" values "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("1")]),e._v(" respectively. Addresses are encoded as "),a("code",[e._v("uint160")]),e._v(". Integer values are sign-extended to 256-bit and encoded in big endian order. "),a("code",[e._v("bytes1")]),e._v(" to "),a("code",[e._v("bytes31")]),e._v(" are arrays with a beginning (index "),a("code",[e._v("0")]),e._v(") and an end (index "),a("code",[e._v("length - 1")]),e._v("), they are zero-padded at the end to "),a("code",[e._v("bytes32")]),e._v(" and encoded in beginning to end order. This corresponds to their encoding in ABI v1 and v2.")]),e._v(" "),a("p",[e._v("The dynamic values "),a("code",[e._v("bytes")]),e._v(" and "),a("code",[e._v("string")]),e._v(" are encoded as a "),a("code",[e._v("keccak256")]),e._v(" hash of their contents.")]),e._v(" "),a("p",[e._v("The array values are encoded as the "),a("code",[e._v("keccak256")]),e._v(" hash of the concatenated "),a("code",[e._v("encodeData")]),e._v(" of their contents (i.e. the encoding of "),a("code",[e._v("SomeType[5]")]),e._v(" is identical to that of a struct containing five members of type "),a("code",[e._v("SomeType")]),e._v(").")]),e._v(" "),a("p",[e._v("The struct values are encoded recursively as "),a("code",[e._v("hashStruct(value)")]),e._v(". This is undefined for cyclical data.")]),e._v(" "),a("h3",{attrs:{id:"definition-of-domainseparator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definition-of-domainseparator"}},[e._v("#")]),e._v(" Definition of "),a("code",[e._v("domainSeparator")])]),e._v(" "),a("div",{staticClass:"language-Solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[e._v("domainSeparator "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("hashStruct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("eip712Domain"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("where the type of "),a("code",[e._v("eip712Domain")]),e._v(" is a struct named "),a("code",[e._v("EIP712Domain")]),e._v(" with one or more of the below fields. Protocol designers only need to include the fields that make sense for their signing domain. Unused fields are left out of the struct type.")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("string name")]),e._v(" the user readable name of signing domain, i.e. the name of the DApp or the protocol.")]),e._v(" "),a("li",[a("code",[e._v("string version")]),e._v(" the current major version of the signing domain. Signatures from different versions are not compatible.")]),e._v(" "),a("li",[a("code",[e._v("uint256 chainId")]),e._v(" the "),a("RouterLink",{attrs:{to:"/zh/eip-155.html"}},[e._v("EIP-155")]),e._v(" chain id. The user-agent "),a("em",[e._v("should")]),e._v(" refuse signing if it does not match the currently active chain.")],1),e._v(" "),a("li",[a("code",[e._v("address verifyingContract")]),e._v(" the address of the contract that will verify the signature. The user-agent "),a("em",[e._v("may")]),e._v(" do contract specific phishing prevention.")]),e._v(" "),a("li",[a("code",[e._v("bytes32 salt")]),e._v(" an disambiguating salt for the protocol. This can be used as a domain separator of last resort.")])]),e._v(" "),a("p",[e._v("Future extensions to this standard can add new fields with new user-agent behaviour constraints. User-agents are free to use the provided information to inform/warn users or refuse signing. Dapp implementers should not add private fields, new fields should be proposed through the EIP process.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("EIP712Domain")]),e._v(" fields should be the order as above, skipping any absent fields. Future field additions must be in alphabetical order and come after the above fields. User-agents should accept fields in any order as specified by the "),a("code",[e._v("EIPT712Domain")]),e._v(" type.")]),e._v(" "),a("h3",{attrs:{id:"specification-of-the-eth-signtypeddata-json-rpc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-of-the-eth-signtypeddata-json-rpc"}},[e._v("#")]),e._v(" Specification of the "),a("code",[e._v("eth_signTypedData")]),e._v(" JSON RPC")]),e._v(" "),a("p",[e._v("The method "),a("code",[e._v("eth_signTypedData")]),e._v(" is added to the "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC",target:"_blank",rel:"noopener noreferrer"}},[e._v("Ethereum JSON-RPC"),a("OutboundLink")],1),e._v(". The method parallels "),a("code",[e._v("eth_sign")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"eth-signtypeddata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eth-signtypeddata"}},[e._v("#")]),e._v(" eth_signTypedData")]),e._v(" "),a("p",[e._v("The sign method calculates an Ethereum specific signature with: "),a("code",[e._v('sign(keccak256("\\x19Ethereum Signed Message:\\n" + len(message) + message)))')]),e._v(".")]),e._v(" "),a("p",[e._v("By adding a prefix to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.")]),e._v(" "),a("p",[a("strong",[e._v("Note")]),e._v(" the address to sign with must be unlocked.")]),e._v(" "),a("h5",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("Address")]),e._v(" - 20 Bytes - Address of the account that will sign the messages.")]),e._v(" "),a("li",[a("code",[e._v("TypedData")]),e._v(" - Typed structured data to be signed.")])]),e._v(" "),a("p",[e._v("Typed data is a JSON object containing type information, domain separator parameters and the message object. Below is the "),a("a",{attrs:{href:"https://json-schema.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("json-schema"),a("OutboundLink")],1),e._v(" definition for "),a("code",[e._v("TypedData")]),e._v(" param.")]),e._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'object'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  properties"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    types"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'object'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      properties"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        EIP712Domain"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'array'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      additionalProperties"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'array'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        items"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n          type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'object'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n          properties"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            name"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'string'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'string'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n          required"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'name'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'type'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n      required"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'EIP712Domain'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    primaryType"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'string'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    domain"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'object'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    message"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'object'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  required"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'types'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'primaryType'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'domain'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'message'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br")])]),a("h5",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[a("code",[e._v("DATA")]),e._v(": Signature. As in "),a("code",[e._v("eth_sign")]),e._v(" it is a hex encoded 129 byte array starting with "),a("code",[e._v("0x")]),e._v(". It encodes the "),a("code",[e._v("r")]),e._v(", "),a("code",[e._v("s")]),e._v(" and "),a("code",[e._v("v")]),e._v(" parameters from appendix F of the "),a("a",{attrs:{href:"https://ethereum.github.io/yellowpaper/paper.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("yellow paper"),a("OutboundLink")],1),e._v(" in big-endian format. Bytes 0...64 contain the "),a("code",[e._v("r")]),e._v(" parameter, bytes 64...128 the "),a("code",[e._v("s")]),e._v(" parameter and the last byte the "),a("code",[e._v("v")]),e._v(" parameter. Note that the "),a("code",[e._v("v")]),e._v(" parameter includes the chain id as specified in "),a("RouterLink",{attrs:{to:"/zh/eip-155.html"}},[e._v("EIP-155")]),e._v(".")],1),e._v(" "),a("h5",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),a("p",[e._v("Request:")]),e._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[e._v("curl")]),e._v(" -X POST --data "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('\'{"jsonrpc":"2.0","method":"eth_signTypedData","params":["0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826", {"types":{"EIP712Domain":[{"name":"name","type":"string"},{"name":"version","type":"string"},{"name":"chainId","type":"uint256"},{"name":"verifyingContract","type":"address"}],"Person":[{"name":"name","type":"string"},{"name":"wallet","type":"address"}],"Mail":[{"name":"from","type":"Person"},{"name":"to","type":"Person"},{"name":"contents","type":"string"}]},"primaryType":"Mail","domain":{"name":"Ether Mail","version":"1","chainId":1,"verifyingContract":"0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"},"message":{"from":{"name":"Cow","wallet":"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"},"to":{"name":"Bob","wallet":"0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB"},"contents":"Hello, Bob!"}}],"id":1}\'')]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Result:")]),e._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"jsonrpc"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"2.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"result"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("An example how to use Solidity ecrecover to verify the signature calculated with "),a("code",[e._v("eth_signTypedData")]),e._v(" can be found in the EIP712 "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("Example.js"),a("OutboundLink")],1),e._v(". The contract is deployed on the testnet Ropsten and Rinkeby.")]),e._v(" "),a("h4",{attrs:{id:"personal-signtypeddata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#personal-signtypeddata"}},[e._v("#")]),e._v(" personal_signTypedData")]),e._v(" "),a("p",[e._v("There also should be a corresponding "),a("code",[e._v("personal_signTypedData")]),e._v(" method which accepts the password for an account as the last argument.")]),e._v(" "),a("h3",{attrs:{id:"specification-of-the-web3-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification-of-the-web3-api"}},[e._v("#")]),e._v(" Specification of the Web3 API")]),e._v(" "),a("p",[e._v("Two methods are added to "),a("a",{attrs:{href:"https://web3js.readthedocs.io/en/1.0/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Web 3 version 1"),a("OutboundLink")],1),e._v(" that parallel the "),a("code",[e._v("web3.eth.sign")]),e._v(" and "),a("code",[e._v("web3.eth.personal.sign")]),e._v(" methods.")]),e._v(" "),a("h4",{attrs:{id:"web3-eth-signtypeddata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web3-eth-signtypeddata"}},[e._v("#")]),e._v(" web3.eth.signTypedData")]),e._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("web3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("eth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("signTypedData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("typedData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" address "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Signs typed data using a specific account. This account needs to be unlocked.")]),e._v(" "),a("h5",{attrs:{id:"parameters-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters-2"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("Object")]),e._v(" - Domain separator and typed data to sign. Structured according to the JSON-Schema specified above in the "),a("code",[e._v("eth_signTypedData")]),e._v(" JSON RPC call.")]),e._v(" "),a("li",[a("code",[e._v("String|Number")]),e._v(" - Address to sign data with. Or an address or index of a local wallet in :ref:"),a("code",[e._v("web3.eth.accounts.wallet <eth_accounts_wallet>")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("Function")]),e._v(" - (optional) Optional callback, returns an error object as first parameter and the result as second.")])]),e._v(" "),a("hr"),e._v(" "),a("h2",{attrs:{id:"note-the-2-address-parameter-can-also-be-an-address-or-index-from-the-web3-eth-accounts-wallet-eth-accounts-wallet-it-will-then-sign-locally-using-the-private-key-of-this-account"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#note-the-2-address-parameter-can-also-be-an-address-or-index-from-the-web3-eth-accounts-wallet-eth-accounts-wallet-it-will-then-sign-locally-using-the-private-key-of-this-account"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Note")]),e._v(" The 2. "),a("code",[e._v("address")]),e._v(" parameter can also be an address or index from the "),a("code",[e._v("web3.eth.accounts.wallet <eth_accounts_wallet>")]),e._v(". It will then sign locally using the private key of this account.")]),e._v(" "),a("h5",{attrs:{id:"returns-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-2"}},[e._v("#")]),e._v(" Returns")]),e._v(" "),a("p",[a("code",[e._v("Promise")]),e._v(" returns "),a("code",[e._v("String")]),e._v(" - The signature as returned by "),a("code",[e._v("eth_signTypedData")]),e._v(".")]),e._v(" "),a("h5",{attrs:{id:"example-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example-2"}},[e._v("#")]),e._v(" Example")]),e._v(" "),a("p",[e._v("See the "),a("code",[e._v("eth_signTypedData")]),e._v(" JSON-API example above for the value of "),a("code",[e._v("typedData")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("web3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("eth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("signTypedData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("typedData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("log"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0x4355c47d63924e8a72e509b65029052eb6c299d53a04e167c5775fd466751c9d07299936d304c153f6443dfa05f40ff007d72911b6f72307f996231605b915621c"')]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("h4",{attrs:{id:"web3-eth-personal-signtypeddata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web3-eth-personal-signtypeddata"}},[e._v("#")]),e._v(" web3.eth.personal.signTypedData")]),e._v(" "),a("div",{staticClass:"language-JavaScript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("web3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("eth"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("personal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("signTypedData")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("typedData"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" address"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" password "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" callback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Identical to "),a("code",[e._v("web3.eth.signTypedData")]),e._v(" except for an additional "),a("code",[e._v("password")]),e._v(" parameter analogous to "),a("code",[e._v("web3.eth.personal.sign")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("encode")]),e._v(" function is extended with a new case for the new types. The first byte of the encoding distinguishes the cases. For the same reason it is not safe to start immediately with the domain separator or a "),a("code",[e._v("typeHash")]),e._v(". While hard, it may be possible to construct a "),a("code",[e._v("typeHash")]),e._v(" that also happens to be a prefix of a valid RLP encoded transaction.")]),e._v(" "),a("p",[e._v("The domain separator prevents collision of otherwise identical structures. It is possible that two DApps come up with an identical structure like "),a("code",[e._v("Transfer(address from,address to,uint256 amount)")]),e._v(" that should not be compatible. By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.")]),e._v(" "),a("p",[e._v("The domain separator also allows for multiple distinct signatures use-cases on the same struct instance within a given DApp. In the previous example, perhaps signatures from both "),a("code",[e._v("from")]),e._v(" and "),a("code",[e._v("to")]),e._v(" are required. By providing two distinct domain separators these signatures can be distinguished from each other.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 1")]),e._v(": Use the target contract address as domain separator. This solves the first problem, contracts coming up with identical types, but does not address the second use-case. The standard does suggest implementors to use the target contract address where this is appropriate.")]),e._v(" "),a("p",[e._v("The function "),a("code",[e._v("hashStruct")]),e._v(" starts with a "),a("code",[e._v("typeHash")]),e._v(" to separate types. By giving different types a different prefix the "),a("code",[e._v("encodeData")]),e._v(" function only has to be injective within a given type. It is okay for "),a("code",[e._v("encodeData(a)")]),e._v(" to equal "),a("code",[e._v("encodeData(b)")]),e._v(" as long as "),a("code",[e._v("typeOf(a)")]),e._v(" is not "),a("code",[e._v("typeOf(b)")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"rationale-for-typehash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale-for-typehash"}},[e._v("#")]),e._v(" Rationale for "),a("code",[e._v("typeHash")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("typeHash")]),e._v(" is designed to turn into a compile time constant in Solidity. For example:")]),e._v(" "),a("div",{staticClass:"language-Solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("constant")]),e._v(" MAIL_TYPEHASH "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Mail(address from,address to,string contents)"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("For the type hash several alternatives were considered and rejected for the reasons:")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 2")]),e._v(": Use ABIv2 function signatures. "),a("code",[e._v("bytes4")]),e._v(" is not enough to be collision resistant. Unlike function signatures, there is negligible runtime cost incurred by using longer hashes.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 3")]),e._v(": ABIv2 function signatures modified to be 256-bit. While this captures type info, it does not capture any of the semantics other than the function. This is already causing a practical collision between ERC20's and ERC721's "),a("code",[e._v("transfer(address,uint256)")]),e._v(", where in the former the "),a("code",[e._v("uint256")]),e._v(" refers to an amount and the latter to a unique id. In general ABIv2 favors compatibility where a hashing standard should prefer incompatibility.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 4")]),e._v(": 256-bit ABIv2 signatures extended with parameter names and struct names. The "),a("code",[e._v("Mail")]),e._v(" example from a above would be encoded as "),a("code",[e._v("Mail(Person(string name,address wallet) from,Person(string name,address wallet) to,string contents)")]),e._v(". This is longer than the proposed solution. And indeed, the length of the string can grow exponentially in the length of the input (consider "),a("code",[e._v("struct A{B a;B b;}; struct B {C a;C b;}; ‚Ä¶")]),e._v("). It also does not allow a recursive struct type (consider "),a("code",[e._v("struct List {uint256 value; List next;}")]),e._v(").")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 5")]),e._v(": Include natspec documentation. This would include even more semantic information in the schemaHash and further reduces chances of collision. It makes extending and amending documentation a breaking changes, which contradicts common assumptions. It also makes the schemaHash mechanism very verbose.")]),e._v(" "),a("h3",{attrs:{id:"rationale-for-encodedata"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale-for-encodedata"}},[e._v("#")]),e._v(" Rationale for "),a("code",[e._v("encodeData")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("encodeData")]),e._v(" is designed to allow easy implementation of "),a("code",[e._v("hashStruct")]),e._v(" in Solidity:")]),e._v(" "),a("div",{staticClass:"language-Solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("hashStruct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Mail "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("memory")]),e._v(" mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("pure")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("returns")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("abi"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("encode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n        MAIL_TYPEHASH"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("to"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("contents"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("it also allows for an efficient in-place implementation in EVM")]),e._v(" "),a("div",{staticClass:"language-Solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("hashStruct")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Mail "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("memory")]),e._v(" mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("pure")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("returns")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" hash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Compute sub-hashes")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" typeHash "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" MAIL_TYPEHASH"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("bytes32")]),e._v(" contentsHash "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("contents"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("assembly")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Back up select memory")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" temp1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mload")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" temp2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mload")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("128")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Write typeHash and sub-hashes")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" typeHash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" contentsHash"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Compute hash")]),e._v("\n        hash "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("keccak256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("128")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Restore memory")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sub")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" temp1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("mstore")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("mail"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" temp2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br")])]),a("p",[e._v("The in-place implementation makes strong but reasonable assumptions on the memory layout of structs in memory. Specifically it assumes structs are not allocated below address 32, that members are stored in order, that all values are padded to 32-byte boundaries, and that dynamic and reference types are stored as a 32-byte pointers.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 6")]),e._v(": Tight packing. This is the default behaviour in Soldity when calling "),a("code",[e._v("keccak256")]),e._v(" with multiple arguments. It minimizes the number of bytes to be hashed but requires complicated packing instructions in EVM to do so. It does not allow in-place computation.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 7")]),e._v(": ABIv2 encoding. Especially with the upcoming "),a("code",[e._v("abi.encode")]),e._v(" it should be easy to use "),a("code",[e._v("abi.encode")]),e._v(" as the "),a("code",[e._v("encodeData")]),e._v(" function. The ABIv2 standard by itself fails the determinism security criteria. There are several valid ABIv2 encodings of the same data. ABIv2 does not allow in-place computation.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 8")]),e._v(": Leave "),a("code",[e._v("typeHash")]),e._v(" out of "),a("code",[e._v("hashStruct")]),e._v(" and instead combine it with the domain separator. This is more efficient, but then the semantics of the Solidity "),a("code",[e._v("keccak256")]),e._v(" hash function are not injective.")]),e._v(" "),a("p",[a("strong",[e._v("Alternative 9")]),e._v(": Support cyclical data structures. The current standard is optimized for tree-like data structures and undefined for cyclical data structures. To support cyclical data a stack containing the path to the current node needs to be maintained and a stack offset substituted when a cycle is detected. This is prohibitively more complex to specify and implement. It also breaks composability where the hashes of the member values are used to construct the hash of the struct (the hash of the member values would depend on the path). It is possible to extend the standard in a compatible way to define hashes of cyclical data.")]),e._v(" "),a("p",[e._v("Similarly, a straightforward implementation is sub-optimal for directed acyclic graphs. A simple recursion through the members can visit the same node twice. Memoization can optimize this.")]),e._v(" "),a("h2",{attrs:{id:"rationale-for-domainseparator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale-for-domainseparator"}},[e._v("#")]),e._v(" Rationale for "),a("code",[e._v("domainSeparator")])]),e._v(" "),a("p",[e._v("Since different domains have different needs, an extensible scheme is used where the DApp specifies a "),a("code",[e._v("EIP712Domain")]),e._v(" struct type and an instance "),a("code",[e._v("eip712Domain")]),e._v(" which it passes to the user-agent. The user-agent can then apply different verification measures depending on the fields that are there.")]),e._v(" "),a("p",[e._v("A field "),a("code",[e._v("string eip719dsl")]),e._v(" can be added and be rejected if the value does not match the hash of the "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/719",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP-719"),a("OutboundLink")],1),e._v(" DSL interface string.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("The RPC calls, web3 methods and "),a("code",[e._v("SomeStruct.typeHash")]),e._v(" parameter are currently undefined. Defining them should not affect the behaviour of existing DApps.")]),e._v(" "),a("p",[e._v("The Solidity expression "),a("code",[e._v("keccak256(someInstance)")]),e._v(" for an instance "),a("code",[e._v("someInstance")]),e._v(" of a struct type "),a("code",[e._v("SomeStruct")]),e._v(" is valid syntax. It currently evaluates to the "),a("code",[e._v("keccak256")]),e._v(" hash of the memory address of the instance. This behaviour should be considered dangerous. In some scenarios it will appear to work correctly but in others it will fail determinism and/or injectiveness. DApps that depend on the current behaviour should be considered dangerously broken.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("An example contract can be found in "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/blob/master/assets/eip-712/Example.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Example.sol"),a("OutboundLink")],1),e._v(" and an example implementation of signing in JavaScript in [Example.js][ex-js]")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("To be done before this EIP can be considered accepted:")]),e._v(" "),a("ul",[a("li",[e._v("[x] Finalize specification of structure hashing")]),e._v(" "),a("li",[e._v("[x] Domain separators")]),e._v(" "),a("li",[e._v("[x] Add test vectors")]),e._v(" "),a("li",[e._v("[x] Review specification")])]),e._v(" "),a("p",[e._v('To be done before this EIP can be considered "Final":')]),e._v(" "),a("ul",[a("li",[e._v("[x] Implement "),a("code",[e._v("eth_signTypedData")]),e._v(" in major RPC providers.")]),e._v(" "),a("li",[e._v("[x] Implement "),a("code",[e._v("web3.eth.signTypedData")]),e._v(" in Web3 providers.")]),e._v(" "),a("li",[e._v("[x] Implement "),a("code",[e._v("keccak256")]),e._v(" struct hashing in Solidity.")])]),e._v(" "),a("p",[a("strong",[e._v("Rationale for marking goals as done:")])]),e._v(" "),a("ul",[a("li",[a("code",[e._v("eth_signTypedData")])])]),e._v(" "),a("p",[e._v("MetaMask has had a series of "),a("code",[e._v("eth_signTypedData")]),e._v(" since 2017 ("),a("a",{attrs:{href:"https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290",target:"_blank",rel:"noopener noreferrer"}},[e._v("article"),a("OutboundLink")],1),e._v("), and is an accepted standard in the wallet ecosystem.")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("web3.eth.signTypedData")])])]),e._v(" "),a("p",[e._v("While this api does "),a("strong",[e._v("not")]),e._v(" exist in the web3.js library as of this writing, it is included as an experimental feature in the Ethers library "),a("a",{attrs:{href:"https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(". It can also be called from the Web3.js library by using the "),a("code",[e._v("sendAsync")]),e._v(" method:")]),e._v(" "),a("div",{staticClass:"language-javascript line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[e._v("web3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("currentProvider"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("sendAsync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  method"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'eth_signTypedData'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  params"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("msgParams"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" from"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("In addition, the "),a("code",[e._v("signTypedData")]),e._v(" function is of limited utility in web3 convenience libraries, as it is generally relevant to the interface that stores the private keys used for signing, and with the excepetionof burner wallets, this is almost always done in practice within a wallet.")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("keccak256")]),e._v(" struct hashing")])]),e._v(" "),a("p",[e._v("While the "),a("code",[e._v("keccak256")]),e._v(" function in Solidity cannot be invoked directly on structs, the introduction of "),a("code",[e._v("abi.encode")]),e._v(" gives a sufficient and well-accepted avenue to hashing structs.")]),e._v(" "),a("ul",[a("li",[e._v("review of specification")])]),e._v(" "),a("p",[e._v("In the time since EIP-712 has been proposed, it has enjoyed wide ecosystem adoption, and has become the foundation for a number of other EIPs building on top of it. (For example, ERC20 token Permits (transaction-less token approvals) in "),a("RouterLink",{attrs:{to:"/zh/eip-2612.html"}},[e._v("EIP-2612")]),e._v(".) MetaMask uses EIP-712 for more readable output to present users, and other wallets have followed suit. The widespread traction and use of this EIP over the course of years justify regarding as sufficiently reviewed.")],1),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);