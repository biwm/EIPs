(window.webpackJsonp=window.webpackJsonp||[]).push([[620],{1036:function(e,t,o){"use strict";o.r(t);var i=o(46),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"abstract"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),o("p",[e._v("The "),o("RouterLink",{attrs:{to:"/zh/eip-2124.html"}},[o("code",[e._v("forkid")]),e._v(" (EIP-2124)")]),e._v(" was designed to permit two Ethereum nodes to quickly and cheaply decide if they are compatible or not, not only at a genesis/networking level, but also from the perspective of the currently passed network updates (i.e. forks).")],1),e._v(" "),o("p",[o("RouterLink",{attrs:{to:"/zh/eip-2124.html"}},[e._v("EIP-2124")]),e._v(" only defines how the "),o("code",[e._v("forkid")]),e._v(" is calculated and validated, but does not specify how the "),o("code",[e._v("forkid")]),e._v(" should be exchanged between peers. This EIP specifies the inclusion of the "),o("code",[e._v("forkid")]),e._v(" as a new field in the Ethereum wire protocol ("),o("code",[e._v("eth")]),e._v(") handshake (releasing a new version, "),o("code",[e._v("eth/64")]),e._v(").")],1),e._v(" "),o("p",[e._v("By cross-validating "),o("code",[e._v("forkid")]),e._v(" during the handshake, incompatible nodes can disconnect before expensive block exchanges and validations take place (PoW check, EVM execution, state reconstruction). This further prevents peer slots from being taken up by nodes that are incompatible, but have not yet been detected as such.")]),e._v(" "),o("h2",{attrs:{id:"motivation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),o("p",[e._v("From a micro perspective, cutting off incompatible nodes from one another ensures that a node only spends its resources on tasks that are genuinely useful to it. The sooner we can decide the remote peer is useless, the less time and processing we expend in vain.")]),e._v(" "),o("p",[e._v("From a macro perspective, keeping incompatible nodes partitioned from one another ensures that disjoint clusters retain more resources for maintaining their own chain, thus raising the quality of service for all networks globally.")]),e._v(" "),o("h2",{attrs:{id:"specification"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),o("p",[e._v("The specification is tiny since most parts are already specified in EIP-2124. "),o("code",[e._v("eth/63")]),e._v(" is not specified as an EIP, but is maintained "),o("a",{attrs:{href:"https://github.com/ethereum/devp2p/blob/master/caps/eth.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("ul",[o("li",[e._v("Implement "),o("code",[e._v("forkid")]),e._v(" generation and validation per "),o("RouterLink",{attrs:{to:"/zh/eip-2124.html"}},[e._v("EIP-2124")]),e._v(".")],1),e._v(" "),o("li",[e._v("Advertise a new "),o("code",[e._v("eth")]),e._v(" protocol capability (version) at "),o("code",[e._v("eth/64")]),e._v(".\n"),o("ul",[o("li",[e._v("The old "),o("code",[e._v("eth/63")]),e._v(" protocol should still be kept alive side-by-side, until "),o("code",[e._v("eth/64")]),e._v(" is sufficiently adopted by implementors.")])])]),e._v(" "),o("li",[e._v("Redefine "),o("code",[e._v("Status (0x00)")]),e._v(" for "),o("code",[e._v("eth/64")]),e._v(" to add a trailing "),o("code",[e._v("forkid")]),e._v(" field:\n"),o("ul",[o("li",[e._v("Old packet: "),o("code",[e._v("[protocolVersion, networkId, td, bestHash, genesisHash]")])]),e._v(" "),o("li",[e._v("New packet: "),o("code",[e._v("[protocolVersion, networkId, td, bestHash, genesisHash, forkid]")]),e._v(", where "),o("code",[e._v("forkid")]),e._v(" is "),o("code",[e._v("[forkHash: [4]byte, forkNext: uint64]")]),e._v(" (fields per "),o("RouterLink",{attrs:{to:"/zh/eip-2124.html"}},[e._v("EIP-2124")]),e._v(" ).")],1)])])]),e._v(" "),o("p",[e._v("Whenever two peers connect using the "),o("code",[e._v("eth/64")]),e._v(" protocol, the updated "),o("code",[e._v("Status")]),e._v(" message must be sent as the protocol handshake, and each peer must validate the remote "),o("code",[e._v("forkid")]),e._v(", disconnecting at a detected incompatibility.")]),e._v(" "),o("h2",{attrs:{id:"rationale"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),o("h5",{attrs:{id:"eip-2124-mentions-advertising-the-forkid-in-the-discovery-protocol-too-how-does-that-compare-to-advertising-in-the-eth-protocol-why-is-the-redundancy-needed"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#eip-2124-mentions-advertising-the-forkid-in-the-discovery-protocol-too-how-does-that-compare-to-advertising-in-the-eth-protocol-why-is-the-redundancy-needed"}},[e._v("#")]),e._v(" EIP-2124 mentions advertising the "),o("code",[e._v("forkid")]),e._v(" in the discovery protocol too. How does that compare to advertising in the "),o("code",[e._v("eth")]),e._v(" protocol? Why is the redundancy needed?")]),e._v(" "),o("p",[e._v("Advertising and validating the "),o("code",[e._v("forkid")]),e._v(" in the discovery protocol is a more optimal solution, as it can help avoid the cost of setting up the TCP connection and cryptographic RLPx stream, only to be torn down if "),o("code",[e._v("eth/64")]),e._v(" rejects it.")]),e._v(" "),o("p",[e._v("Compared to the "),o("code",[e._v("eth")]),e._v(" protocol however, discovery is a bit fuzzy. The goal there is to suggest potential peers, not to be fool-proof. Information may be outdated, nodes may have changed or disappeared. Discovery can do a rough filtering, but more precision is still needed afterwards.")]),e._v(" "),o("p",[e._v("Additionally, "),o("code",[e._v("forkid")]),e._v(" validation via the discovery protocol requires ENR implementation ("),o("RouterLink",{attrs:{to:"/zh/eip-778.html"}},[e._v("EIP-778")]),e._v(") and ENR extension support ("),o("RouterLink",{attrs:{to:"/zh/eip-868.html"}},[e._v("EIP-868")]),e._v("), which is not mandated by the Ethereum network currently. Lastly, the discovery protocol is just one way to find peers, but systems that cannot use UDP or that rely on other mechanism (e.g. DNS discovery ("),o("RouterLink",{attrs:{to:"/zh/eip-1459.html"}},[e._v("EIP-1459")]),e._v(")) still need a way to filter connections.")],1),e._v(" "),o("h5",{attrs:{id:"the-forkid-implicitly-contains-the-genesis-hash-checksummed-into-the-fork-hash-field-why-doesn-t-this-proposal-remove-the-genesishash-field-from-the-eth-handshake"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#the-forkid-implicitly-contains-the-genesis-hash-checksummed-into-the-fork-hash-field-why-doesn-t-this-proposal-remove-the-genesishash-field-from-the-eth-handshake"}},[e._v("#")]),e._v(" The "),o("code",[e._v("forkid")]),e._v(" implicitly contains the genesis hash checksummed into the "),o("code",[e._v("FORK_HASH")]),e._v(" field. Why doesn't this proposal remove the "),o("code",[e._v("genesisHash")]),e._v(" field from the "),o("code",[e._v("eth")]),e._v(" handshake?")]),e._v(" "),o("p",[e._v("Originally this EIP did remove it as redundant data, since filtering based on the "),o("code",[e._v("forkid")]),e._v(" is a superset of filtering based on genesis hash. The reason for backing out of that decision was that the genesis hash may be useful for other things too, not just connection filtering (network crawlers use it currently to split nodes across networks).")]),e._v(" "),o("p",[e._v("Although the "),o("code",[e._v("forkid")]),e._v(" will hopefully take over all the roles of the genesis hash currently in use, there's no reason to be overly aggressive in deduplicating data. It's fine to keep both side-by-side for now, and remove in a future version when 3rd party infrastructures switch over.")]),e._v(" "),o("h2",{attrs:{id:"backwards-compatibility"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),o("p",[e._v("This EIP extends the "),o("code",[e._v("eth")]),e._v(" protocol handshake in a backwards incompatible way and requires rolling out a new version, "),o("code",[e._v("eth/64")]),e._v(". However, "),o("code",[e._v("devp2p")]),e._v(" supports running multiple versions of the same wire protocol side-by-side, so rolling out "),o("code",[e._v("eth/64")]),e._v(" does not require client coordination, since non-updated clients can keep using "),o("code",[e._v("eth/63")]),e._v(".")]),e._v(" "),o("p",[e._v("This EIP does not change the consensus engine, thus does "),o("em",[e._v("not")]),e._v(" require a hard fork.")]),e._v(" "),o("h2",{attrs:{id:"test-cases"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),o("p",[e._v("For calculating and validating fork IDs, see test cases in "),o("RouterLink",{attrs:{to:"/zh/eip-2124.html"}},[e._v("EIP-2124")]),e._v(".")],1),e._v(" "),o("p",[e._v("Testing proper advertising and validation at the networking level will require a "),o("a",{attrs:{href:"https://github.com/ethereum/hive",target:"_blank",rel:"noopener noreferrer"}},[e._v("hive"),o("OutboundLink")],1),e._v(" test.")]),e._v(" "),o("h2",{attrs:{id:"implementation"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),o("p",[e._v("Geth: https://github.com/ethereum/go-ethereum/pull/20140")]),e._v(" "),o("h2",{attrs:{id:"copyright"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),o("p",[e._v("Copyright and related rights waived via "),o("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),o("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);