(window.webpackJsonp=window.webpackJsonp||[]).push([[469],{877:function(t,e,a){"use strict";a.r(e);var s=a(46),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[t._v("#")]),t._v(" Simple Summary")]),t._v(" "),a("p",[t._v("One of the great features of Ethereum is the fact, that you can verify all data of the state. But in order to allow verification of accounts outside the client, we need an additional function delivering us the required proof. These proofs are important to secure Layer2-Technologies.")]),t._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),a("p",[t._v("Ethereum uses a "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/Patricia-Tree",target:"_blank",rel:"noopener noreferrer"}},[t._v("Merkle Tree"),a("OutboundLink")],1),t._v(" to store the state of accounts and their storage. This allows verification of each value by simply creating a Merkle Proof. But currently, the standard RPC-Interface does not give you access to these proofs. This EIP suggests an additional RPC-Method, which creates Merkle Proofs for Accounts and Storage Values.")]),t._v(" "),a("p",[t._v("Combined with a stateRoot (from the blockheader) it enables offline verification of any account or storage-value. This allows especially IOT-Devices or even mobile apps which are not able to run a light client to verify responses from an untrusted source only given a trusted blockhash.")]),t._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),a("p",[t._v("In order to create a MerkleProof access to the full state db is required. The current RPC-Methods allow an application to access single values ("),a("code",[t._v("eth_getBalance")]),t._v(","),a("code",[t._v("eth_getTransactionCount")]),t._v(","),a("code",[t._v("eth_getStorageAt")]),t._v(","),a("code",[t._v("eth_getCode")]),t._v("), but it is impossible to read the data needed for a  MerkleProof through the standard RPC-Interface. (There are implementations using leveldb and accessing the data via filesystems, but this can not be used for production systems since it requires the client to be stopped first - See https://github.com/zmitton/eth-proof)")]),t._v(" "),a("p",[t._v("Today MerkleProofs are already used internally. For example, the "),a("a",{attrs:{href:"https://github.com/zsfelfoldi/go-ethereum/wiki/Light-Ethereum-Subprotocol-%28LES%29#on-demand-data-retrieval",target:"_blank",rel:"noopener noreferrer"}},[t._v("Light Client Protocol"),a("OutboundLink")],1),t._v(" supports a function creating MerkleProof, which is used in order to verify the requested account or storage-data.")]),t._v(" "),a("p",[t._v("Offering these already existing function through the RPC-Interface as well would enable Applications to store and send these proofs to devices which are not directly connected to the p2p-network and still are able to verify the data. This could be used to verify data in mobile applications or IOT-devices, which are currently only using a remote client.")]),t._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),a("p",[t._v("As Part of the eth-Module, an additional Method called "),a("code",[t._v("eth_getProof")]),t._v(" should be defined as follows:")]),t._v(" "),a("h4",{attrs:{id:"eth-getproof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eth-getproof"}},[t._v("#")]),t._v(" eth_getProof")]),t._v(" "),a("p",[t._v("Returns the account- and storage-values of the specified account including the Merkle-proof.")]),t._v(" "),a("h5",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("DATA")]),t._v(", 20 Bytes - address of the account.")]),t._v(" "),a("li",[a("code",[t._v("ARRAY")]),t._v(", 32 Bytes - array of storage-keys which should be proofed and included. See "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getstorageat",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("eth_getStorageAt")]),a("OutboundLink")],1)]),t._v(" "),a("li",[a("code",[t._v("QUANTITY|TAG")]),t._v(" - integer block number, or the string "),a("code",[t._v('"latest"')]),t._v(" or "),a("code",[t._v('"earliest"')]),t._v(", see the "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC#the-default-block-parameter",target:"_blank",rel:"noopener noreferrer"}},[t._v("default block parameter"),a("OutboundLink")],1)])]),t._v(" "),a("h5",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[t._v("#")]),t._v(" Returns")]),t._v(" "),a("p",[a("code",[t._v("Object")]),t._v(" - A account object:")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("balance")]),t._v(": "),a("code",[t._v("QUANTITY")]),t._v(" - the balance of the account. See "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_getbalance",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("eth_getBalance")]),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("code",[t._v("codeHash")]),t._v(": "),a("code",[t._v("DATA")]),t._v(", 32 Bytes - hash of the code of the account. For a simple Account without code it will return "),a("code",[t._v('"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"')])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("nonce")]),t._v(": "),a("code",[t._v("QUANTITY")]),t._v(", - nonce of the account. See "),a("a",{attrs:{href:"https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_gettransactioncount",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("eth_getTransactionCount")]),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("code",[t._v("storageHash")]),t._v(": "),a("code",[t._v("DATA")]),t._v(", 32 Bytes - SHA3 of the StorageRoot. All storage will deliver a MerkleProof starting with this rootHash.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("accountProof")]),t._v(": "),a("code",[t._v("ARRAY")]),t._v(" - Array of rlp-serialized MerkleTree-Nodes, starting with the stateRoot-Node, following the path of the SHA3 (address) as key.")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("storageProof")]),t._v(": "),a("code",[t._v("ARRAY")]),t._v(" - Array of storage-entries as requested. Each entry is a object with these properties:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("key")]),t._v(": "),a("code",[t._v("QUANTITY")]),t._v(" - the requested storage key")]),t._v(" "),a("li",[a("code",[t._v("value")]),t._v(": "),a("code",[t._v("QUANTITY")]),t._v(" - the storage value")]),t._v(" "),a("li",[a("code",[t._v("proof")]),t._v(": "),a("code",[t._v("ARRAY")]),t._v(" - Array of rlp-serialized MerkleTree-Nodes, starting with the storageHash-Node, following the path of the SHA3 (key) as path.")])])])]),t._v(" "),a("h5",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[t._v("#")]),t._v(" Example")]),t._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"jsonrpc"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"method"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"eth_getProof"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"params"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x7F0d15C7FAae65896648C8273B6d7E43f58Fa842"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"latest"')]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br")])]),a("p",[t._v("The result will look like this:")]),t._v(" "),a("div",{staticClass:"language-json line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"jsonrpc"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2.0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"result"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"accountProof"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...0701bc80"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...0d832380"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...5fb20c80"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...0675b80"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90151a0...ca08080"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"balance"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"codeHash"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"nonce"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x0"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"storageHash"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"storageProof"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"key"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"proof"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...0701bc80"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0xf90211a...0d832380"')]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"value"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0x1"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br"),a("span",{staticClass:"line-number"},[t._v("16")]),a("br"),a("span",{staticClass:"line-number"},[t._v("17")]),a("br"),a("span",{staticClass:"line-number"},[t._v("18")]),a("br"),a("span",{staticClass:"line-number"},[t._v("19")]),a("br"),a("span",{staticClass:"line-number"},[t._v("20")]),a("br"),a("span",{staticClass:"line-number"},[t._v("21")]),a("br"),a("span",{staticClass:"line-number"},[t._v("22")]),a("br"),a("span",{staticClass:"line-number"},[t._v("23")]),a("br"),a("span",{staticClass:"line-number"},[t._v("24")]),a("br"),a("span",{staticClass:"line-number"},[t._v("25")]),a("br"),a("span",{staticClass:"line-number"},[t._v("26")]),a("br"),a("span",{staticClass:"line-number"},[t._v("27")]),a("br")])]),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),a("p",[t._v("This one Method actually returns 3 different important data points:")]),t._v(" "),a("ol",[a("li",[t._v("The 4 fields of an account-object as specified in the yellow paper "),a("code",[t._v("[nonce, balance, storageHash, codeHash ]")]),t._v(", which allows storing a hash of the account-object in order to keep track of changes.")]),t._v(" "),a("li",[t._v("The MerkleProof for the account starting with a stateRoot from the specified block.")]),t._v(" "),a("li",[t._v("The MerkleProof for each requested storage entry starting with a storageHash from the account.")])]),t._v(" "),a("p",[t._v("Combining these in one Method allows the client to work very efficient since the required data are already fetched from the db.")]),t._v(" "),a("h3",{attrs:{id:"proofs-for-non-existent-values"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proofs-for-non-existent-values"}},[t._v("#")]),t._v(" Proofs for non existent values")]),t._v(" "),a("p",[t._v("In case an address or storage-value does not exist, the proof needs to provide enough data to verify this fact. This means the client needs to follow the path from the root node and deliver until the last matching node. If the last matching node is a branch, the proof value in the node must be an empty one. In case of leaf-type, it must be pointing to a different relative-path in order to proof that the requested path does not exist.")]),t._v(" "),a("h3",{attrs:{id:"possible-changes-to-be-discussed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#possible-changes-to-be-discussed"}},[t._v("#")]),t._v(" possible Changes to be discussed:")]),t._v(" "),a("ul",[a("li",[t._v("instead of providing the blocknumber maybe the blockhash would be better since it would allow proofs of uncles-states.")]),t._v(" "),a("li",[t._v("in order to reduce data, the account-object may only provide the "),a("code",[t._v("accountProof")]),t._v(" and "),a("code",[t._v("storageProof")]),t._v(". The Fields "),a("code",[t._v("balance")]),t._v(", "),a("code",[t._v("nonce")]),t._v(", "),a("code",[t._v("storageHash")]),t._v(" and "),a("code",[t._v("codeHash")]),t._v(" could be taken from the last Node in the proof by deserializing it.")])]),t._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[t._v("#")]),t._v(" Backwards Compatibility")]),t._v(" "),a("p",[t._v("Since this only adds a new Method there are no issues with Backwards Compatibility.")]),t._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[t._v("#")]),t._v(" Test Cases")]),t._v(" "),a("p",[t._v("TODO: Tests still need to be implemented, but the core function creating the proof already exists inside the clients and are well tested.")]),t._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[t._v("#")]),t._v(" Copyright")]),t._v(" "),a("p",[t._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CC0"),a("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);e.default=r.exports}}]);