(window.webpackJsonp=window.webpackJsonp||[]).push([[695],{1117:function(e,s,t){"use strict";t.r(s);var a=t(46),n=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"simple-summary"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),t("p",[e._v("This EIP defines a hash-to-curve precompile for use in BN256 and would allow for cheaper BLS signature verification.")]),e._v(" "),t("h2",{attrs:{id:"abstract"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),t("p",[e._v("There is currently no inexpensive way to perform BLS signature verification for arbitrary messages. This stems from the fact that there is no precompiled contract in the EVM for a hash-to-curve algorithm for the BN256 elliptic curve. The gas cost of calling a deterministic hash-to-curve algorithm written in Solidity is approximately that of one pairing check, although the latter requires an order of magnitude more computation. This EIP remedies this by implementing a hash-to-curve algorithm for the BN256 G1 curve, which would reduce the cost of signature verification to essentially that of the pairing check precompiled contract. We also include a hash-to-curve algorithm for the BN256 G2 group.")]),e._v(" "),t("h2",{attrs:{id:"motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),t("p",[e._v("The precompiled contracts in "),t("RouterLink",{attrs:{to:"/zh/eip-198.html"}},[e._v("EIP-198")]),e._v(" and "),t("RouterLink",{attrs:{to:"/zh/eip-1108.html"}},[e._v("EIP-1108")]),e._v(" increased usage of cryptographic operations in the EVM by reducing the gas costs. In particular, the cost reduction from "),t("RouterLink",{attrs:{to:"/zh/eip-1108.html"}},[e._v("EIP-1108")]),e._v(" helps increase the use of SNARKs in Ethereum via an elliptic curve pairing check; however, a hash-to-curve algorithm enabling arbitrary BLS signature verification on BN256 in the EVM was noticeably missing. There is interest in having a precompiled contract which would allow for signature verification, as noted "),t("a",{attrs:{href:"https://ethereum-magicians.org/t/pre-compile-for-bls/3973",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(".")],1),e._v(" "),t("p",[e._v("At this time, we are able to perform addition, scalar multiplication, and pairing checks in BN256. Reducing these costs in "),t("RouterLink",{attrs:{to:"/zh/eip-1108.html"}},[e._v("EIP-1108")]),e._v(" made "),t("a",{attrs:{href:"https://github.com/PhilippSchindler/ethdkg",target:"_blank",rel:"noopener noreferrer"}},[e._v("ETHDKG"),t("OutboundLink")],1),e._v(", a distributed key generation protocol in Ethereum, less expensive. ETHDKG by itself is useful; however, what it is lacking is the ability to verify arbitrary BLS signatures. Creating group signatures by aggregating partial signatures is one goal of a DKG protocol. The DKG enables the computation of partial signatures to be combined into a group signature offline, but there is no easy way to verify partial signatures or group signatures in the EVM.")],1),e._v(" "),t("p",[e._v("In order to perform BLS signature validation, a hash-to-curve algorithm is required. While the MapToGroup method initially discussed in the original BLS "),t("a",{attrs:{href:"../../assets/eip-3068/weilsigs.pdf"}},[e._v("paper")]),e._v(" works in practice, the nondeterministic nature of the algorithm leaves something to be desired as we would like to bound the overall computational cost in the EVM. A deterministic method for mapping to BN curves is given "),t("a",{attrs:{href:"../../assets/eip-3068/latincrypt12.pdf"}},[e._v("here")]),e._v("; in the paper, Fouque and Tibouchi proved their mapping was indifferentiable from a random oracle. This gives us the desired algorithm.")]),e._v(" "),t("h2",{attrs:{id:"specification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),t("p",[e._v("Here is the pseudocode for the "),t("code",[e._v("HashToG1")]),e._v(" function:")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function HashToG1(msg)\n    fieldElement0 = HashToBase(msg, 0x00, 0x01)\n    fieldElement1 = HashToBase(msg, 0x02, 0x03)\n    curveElement0 = BaseToG1(fieldElement0)\n    curveElement1 = BaseToG1(fieldElement1)\n    g1Element = ECAdd(curveElement0, curveElement1)\n    return g1Element\nend function\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br")])]),t("p",[e._v("Here is the pseudocode for "),t("code",[e._v("HashToBase")]),e._v("; "),t("code",[e._v("msg")]),e._v(" is the byte slice to be hashed while "),t("code",[e._v("dsp1")]),e._v(" and "),t("code",[e._v("dsp2")]),e._v(" are domain separation parameters. "),t("code",[e._v("fieldPrime")]),e._v(" is the prime of the underlying field.")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function HashToBase(msg, dsp1, dsp2)\n    hashResult0 = uint256(Keccak256(dsp1||msg))\n    hashResult1 = uint256(Keccak256(dsp2||msg))\n    constant = 2^256 mod fieldPrime\n    fieldElement0 = hashResult0*constant          mod fieldPrime\n    fieldElement1 = hashResult1                   mod fieldPrime\n    fieldElement  = fieldElement0 + fieldElement1 mod fieldPrime\n    return fieldElement\nend function\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br")])]),t("p",[e._v("Here is the pseudocode for "),t("code",[e._v("BaseToG1")]),e._v(". All of these operations are performed in the finite field. "),t("code",[e._v("inverse")]),e._v(" computes the multiplicative inverse in the underlying finite field; we have the convention "),t("code",[e._v("inverse(0) == 0")]),e._v(". "),t("code",[e._v("is_square(a)")]),e._v(" computes the Legendre symbol of the element, returning 1 if "),t("code",[e._v("a")]),e._v(" is a square, -1 if "),t("code",[e._v("a")]),e._v(" is not a square, and 0 if "),t("code",[e._v("a")]),e._v(" is 0. "),t("code",[e._v("sqrt")]),e._v(" computes the square root of the element in the finite field; a square root is assumed to exist. "),t("code",[e._v("sign0")]),e._v(" returns the sign of the finite field element.")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function BaseToG1(t)\n    # All operations are done in the finite field GF(fieldPrime)\n    # Here, the elliptic curve satisfies the equation\n    #       y^2 == g(x) == x^3 + curveB\n    constant1 = (-1 + sqrt(-3))/2\n    constant2 = -3\n    constant3 = 1/3\n    constant4 = g(1)\n    s = (constant4 + t^2)^3\n    alpha = inverse(t^2*(constant4 + t^2))\n    x1 = constant1 - constant2*t^4*alpha\n    x2 = -1 - x1\n    x3 = 1 - constant3*s*alpha\n    a1 = x1^3 + curveB\n    a2 = x2^3 + curveB\n    residue1 = is_square(a1)\n    residue2 = is_square(a2)\n    index = (residue1 - 1)*(residue2 - 3)/4 + 1\n    coef1 = ConstantTimeEquality(1, index)\n    coef2 = ConstantTimeEquality(2, index)\n    coef3 = ConstantTimeEquality(3, index)\n    x = coef1*x1 + coef2*x2 + coef3*x3\n    y = sign0(t)*sqrt(x^3 + curveB)\n    return (x, y)\nend function\n\nfunction sign0(t)\n    if t <= (fieldPrime-1)/2\n        return 1\n    else\n        return fieldPrime-1\n    end if\nend function\n\nfunction ConstantTimeEquality(a, b)\n    # This function operates in constant time\n    if a == b\n        return 1\n    else\n        return 0\n    end if\nend function\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br"),t("span",{staticClass:"line-number"},[e._v("22")]),t("br"),t("span",{staticClass:"line-number"},[e._v("23")]),t("br"),t("span",{staticClass:"line-number"},[e._v("24")]),t("br"),t("span",{staticClass:"line-number"},[e._v("25")]),t("br"),t("span",{staticClass:"line-number"},[e._v("26")]),t("br"),t("span",{staticClass:"line-number"},[e._v("27")]),t("br"),t("span",{staticClass:"line-number"},[e._v("28")]),t("br"),t("span",{staticClass:"line-number"},[e._v("29")]),t("br"),t("span",{staticClass:"line-number"},[e._v("30")]),t("br"),t("span",{staticClass:"line-number"},[e._v("31")]),t("br"),t("span",{staticClass:"line-number"},[e._v("32")]),t("br"),t("span",{staticClass:"line-number"},[e._v("33")]),t("br"),t("span",{staticClass:"line-number"},[e._v("34")]),t("br"),t("span",{staticClass:"line-number"},[e._v("35")]),t("br"),t("span",{staticClass:"line-number"},[e._v("36")]),t("br"),t("span",{staticClass:"line-number"},[e._v("37")]),t("br"),t("span",{staticClass:"line-number"},[e._v("38")]),t("br"),t("span",{staticClass:"line-number"},[e._v("39")]),t("br"),t("span",{staticClass:"line-number"},[e._v("40")]),t("br"),t("span",{staticClass:"line-number"},[e._v("41")]),t("br"),t("span",{staticClass:"line-number"},[e._v("42")]),t("br")])]),t("p",[e._v("In "),t("code",[e._v("HashToG2")]),e._v(", we first map to the underlying twist curve and then clear the cofactor to map to G2. Here is the pseudocode for "),t("code",[e._v("HashToG2")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function HashToG2(msg)\n    fieldElement00 = HashToBase(msg, 0x04, 0x05)\n    fieldElement01 = HashToBase(msg, 0x06, 0x07)\n    fieldElement10 = HashToBase(msg, 0x08, 0x09)\n    fieldElement11 = HashToBase(msg, 0x0a, 0x0b)\n    fieldElement0 = (fieldElement00, fieldElement01)\n    fieldElement1 = (fieldElement10, fieldElement11)\n    twistElement0 = BaseToTwist(fieldElement0)\n    twistElement1 = BaseToTwist(fieldElement1)\n    twistElement = ECAdd(twistElement0, twistElement1)\n    g2Element = ClearCofactor(twistElement)\n    return g2Element\nend function\n\nfunction ClearCofactor(twistElement)\n    return ECMul(twistElement, cofactor)\nend function\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br")])]),t("p",[e._v("Here is the pseudocode for "),t("code",[e._v("BaseToTwist")]),e._v(".")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function BaseToTwist(t)\n    # All operations are done in the finite field GF(fieldPrime^2)\n    # Here, the twist curve satisfies the equation\n    #       y^2 == g'(x) == x^3 + curveBPrime\n    constant1 = (-1 + sqrt(-3))/2\n    constant2 = -3\n    constant3 = 1/3\n    constant4 = g'(1)\n    s = (constant4 + t^2)^3\n    alpha = inverse(t^2*(constant4 + t^2))\n    x1 = constant1 - constant2*t^4*alpha\n    x2 = -1 - x1\n    x3 = 1 - constant3*s*alpha\n    a1 = x1^3 + curveBPrime\n    a2 = x2^3 + curveBPrime\n    residue1 = is_square(a1)\n    residue2 = is_square(a2)\n    index = (residue1 - 1)*(residue2 - 3)/4 + 1\n    coef1 = ConstantTimeEquality(1, index)\n    coef2 = ConstantTimeEquality(2, index)\n    coef3 = ConstantTimeEquality(3, index)\n    x = coef1*x1 + coef2*x2 + coef3*x3\n    y = sign0(t)*sqrt(x^3 + curveBPrime)\n    return (x, y)\nend function\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br"),t("span",{staticClass:"line-number"},[e._v("22")]),t("br"),t("span",{staticClass:"line-number"},[e._v("23")]),t("br"),t("span",{staticClass:"line-number"},[e._v("24")]),t("br"),t("span",{staticClass:"line-number"},[e._v("25")]),t("br")])]),t("h2",{attrs:{id:"rationale"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),t("p",[e._v("The BaseToG1 algorithm is based on the original Fouque and Tibouchi "),t("a",{attrs:{href:"../../assets/eip-3068/latincrypt12.pdf"}},[e._v("paper")]),e._v(" with modifications based on Wahby and Boneh's "),t("a",{attrs:{href:"../../assets/eip-3068/2019-403_BLS12_H2C.pdf"}},[e._v("paper")]),e._v(". There is freedom in choosing the HashToBase function and this could easily be changed. Within HashToBase, the particular hashing algorithm (Keccak256 in our case) could also be modified. It may be desired to change the call to "),t("code",[e._v("sign0")]),e._v(" at the end of BaseToG1 and BaseToTwist with "),t("code",[e._v("is_square")]),e._v(", as this would result in the same deterministic map to curve from the Fouque and Tibouchi "),t("a",{attrs:{href:"../../assets/eip-3068/latincrypt12.pdf"}},[e._v("paper")]),e._v(" and ensure HashToG1 is indifferentiable from a random oracle; they proved this result in their paper. It may be possible to show that switching the "),t("code",[e._v("is_square")]),e._v(" call with "),t("code",[e._v("sign0")]),e._v(" does not affect indifferentiability, although this has not been proven.")]),e._v(" "),t("p",[e._v("The HashToG2 algorithm follows from the Wahby and Boneh "),t("a",{attrs:{href:"../../assets/eip-3068/2019-403_BLS12_H2C.pdf"}},[e._v("paper")]),e._v(". Algorithms for computing "),t("code",[e._v("inverse")]),e._v(", "),t("code",[e._v("is_square")]),e._v(", and "),t("code",[e._v("sqrt")]),e._v(" in finite field GF(fieldPrime^2) can be found "),t("a",{attrs:{href:"../../assets/eip-3068/2012-685_Square_Root_Even_Ext.pdf"}},[e._v("here")]),e._v(".")]),e._v(" "),t("p",[e._v("We now discuss the potential gas cost for the HashToG1 and HashToG2 operations. On a local machine, ECMul was clocked at 68 microseconds per operation. The same machine clocked HashToG1 at 94 microseconds per operation when hashing 32 bytes into G1 and 105 microseconds per operation when hashing 1024 bytes into G1. Given that it currently costs 6000 gas for ECMul, this gives us an estimated gas cost for HashToG1 at "),t("code",[e._v("8500 + len(bytes)")]),e._v(". Similarly, HashToG2 was clocked at 886 microseconds per operation when hashing 32 bytes into G2 and 912 microseconds per operation when hashing 1024 bytes into G2. This allows us to estimate the gas cost at "),t("code",[e._v("80000 + 3*len(bytes)")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"backwards-compatibility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),t("p",[e._v("There are no backward compatibility concerns.")]),e._v(" "),t("h2",{attrs:{id:"test-cases"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),t("p",[e._v("TBD")]),e._v(" "),t("h2",{attrs:{id:"implementation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),t("p",[e._v("TBD")]),e._v(" "),t("h2",{attrs:{id:"security-considerations"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),t("p",[e._v("Due to recent "),t("a",{attrs:{href:"../../assets/eip-3068/2015-1027_exTNFS.pdf"}},[e._v("work")]),e._v(", the 128-bit security promised by the BN256 elliptic curve no longer applies; this was mentioned in the Cloudflare BN256 "),t("a",{attrs:{href:"https://github.com/cloudflare/bn256",target:"_blank",rel:"noopener noreferrer"}},[e._v("library"),t("OutboundLink")],1),e._v(". There has been some discussion on the exact security decrease from this advancement; see these "),t("a",{attrs:{href:"../../assets/eip-3068/2016-1102_Assessing_NFS_Advances.pdf"}},[e._v("two")]),e._v(" "),t("a",{attrs:{href:"../../assets/eip-3068/2017-334.pdf"}},[e._v("papers")]),e._v(" for different estimates. The more conservative estimate puts the security of BN256 at 100-bits. While this is likely still out of reach for many adversaries, it should give us pause. This reduced security was noted in the recent MadNet "),t("a",{attrs:{href:"../../assets/eip-3068/madnet.pdf"}},[e._v("whitepaper")]),e._v(", and this security concern was partially mitigated by requiring Secp256k1 signatures of the partial group signatures in order for those partial signatures to be valid. Full disclosure: the author of this EIP works for MadHive, assisted in the development of MadNet, and helped write the MadNet whitepaper.")]),e._v(" "),t("p",[e._v("The security concerns of the BN256 elliptic curve affect any operation using pairing check because it is related to the elliptic curve pairing; they are independent of this EIP.")]),e._v(" "),t("h2",{attrs:{id:"copyright"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),t("p",[e._v("Copyright and related rights waived via "),t("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),t("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);s.default=n.exports}}]);