(window.webpackJsonp=window.webpackJsonp||[]).push([[563],{978:function(e,t,a){"use strict";a.r(t);var i=a(46),s=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Precompiled contracts for elliptic curve operations are required in order to perform zkSNARK verification within the block gas limit.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP suggests to add precompiled contracts for addition and scalar multiplication on a specific pairing-friendly elliptic curve. This can in turn be combined with "),a("RouterLink",{attrs:{to:"/zh/eip-197.html"}},[e._v("EIP-197")]),e._v(" to verify zkSNARKs in Ethereum smart contracts. The general benefit of zkSNARKs for Ethereum is that it will increase the privacy for users (because of the Zero-Knowledge property) and might also be a scalability solution (because of the succinctness and efficient verifiability property).")],1),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Current smart contract executions on Ethereum are fully transparent, which makes them unsuitable for several use-cases that involve private information like the location, identity or history of past transactions. The technology of zkSNARKs could be a solution to this problem. While the Ethereum Virtual Machine can make use of zkSNARKs in theory, they are currently too expensive to fit the block gas limit. Because of that, this EIP proposes to specify certain parameters for some elementary primitives that enable zkSNARKs so that they can be implemented more efficiently and the gas cost be reduced.")]),e._v(" "),a("p",[e._v("Note that while fixing these parameters might look like limiting the use-cases for zkSNARKs, the primitives are so basic that they can be combined in ways that are flexible enough so that it should even be possible to allow future advances in zkSNARK research without the need for a further hard fork.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("block.number >= BYZANTIUM_FORK_BLKNUM")]),e._v(', add precompiled contracts for point addition (ADD)  and scalar multiplication (MUL) on the elliptic curve "alt_bn128".')]),e._v(" "),a("p",[e._v("Address of ADD: 0x6 Address for MUL: 0x7")]),e._v(" "),a("p",[e._v("The curve is defined by:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Y^2 = X^3 + 3\nover the field F_p with\np = 21888242871839275222246405745257275088696311157297823662689037894645226208583\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("h3",{attrs:{id:"encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding"}},[e._v("#")]),e._v(" Encoding")]),e._v(" "),a("p",[e._v("Field elements and scalars are encoded as 32 byte big-endian numbers. Curve points are encoded as two field elements "),a("code",[e._v("(x, y)")]),e._v(", where the point at infinity is encoded as "),a("code",[e._v("(0, 0)")]),e._v(".")]),e._v(" "),a("p",[e._v("Tuples of objects are encoded as their concatenation.")]),e._v(" "),a("p",[e._v("For both precompiled contracts, if the input is shorter than expected, it is assumed to be virtually padded with zeros at the end (i.e. compatible with the semantics of the "),a("code",[e._v("CALLDATALOAD")]),e._v(" opcode). If the input is longer than expected, surplus bytes at the end are ignored.")]),e._v(" "),a("p",[e._v('The length of the returned data is always as specified (i.e. it is not "unpadded").')]),e._v(" "),a("h3",{attrs:{id:"exact-semantics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exact-semantics"}},[e._v("#")]),e._v(" Exact semantics")]),e._v(" "),a("p",[e._v("Invalid input: For both contracts, if any input point does not lie on the curve or any of the field elements (point coordinates) is equal or larger than the field modulus p, the contract fails. The scalar can be any number between "),a("code",[e._v("0")]),e._v(" and "),a("code",[e._v("2**256-1")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"add"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add"}},[e._v("#")]),e._v(" ADD")]),e._v(" "),a("p",[e._v("Input: two curve points "),a("code",[e._v("(x, y)")]),e._v(". Output: curve point "),a("code",[e._v("x + y")]),e._v(", where "),a("code",[e._v("+")]),e._v(" is point addition on the elliptic curve "),a("code",[e._v("alt_bn128")]),e._v(" specified above. Fails on invalid input and consumes all gas provided.")]),e._v(" "),a("h4",{attrs:{id:"mul"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mul"}},[e._v("#")]),e._v(" MUL")]),e._v(" "),a("p",[e._v("Input: curve point and scalar "),a("code",[e._v("(x, s)")]),e._v(". Output: curve point "),a("code",[e._v("s * x")]),e._v(", where "),a("code",[e._v("*")]),e._v(" is the scalar multiplication on the elliptic curve "),a("code",[e._v("alt_bn128")]),e._v(" specified above. Fails on invalid input and consumes all gas.")]),e._v(" "),a("h3",{attrs:{id:"gas-costs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-costs"}},[e._v("#")]),e._v(" Gas costs")]),e._v(" "),a("ul",[a("li",[e._v("Gas cost for "),a("code",[e._v("ECADD")]),e._v(": 500")]),e._v(" "),a("li",[e._v("Gas cost for "),a("code",[e._v("ECMUL")]),e._v(": 40000")])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The specific curve "),a("code",[e._v("alt_bn128")]),e._v(" was chosen because it is particularly well-suited for zkSNARKs, or, more specifically their verification building block of pairing functions. Furthermore, by choosing this curve, we can use synergy effects with ZCash and re-use some of their components and artifacts.")]),e._v(" "),a("p",[e._v("The feature of adding curve and field parameters to the inputs was considered but ultimately rejected since it complicates the specification: The gas costs are much harder to determine and it would be possible to call the contracts on something which is not an actual elliptic curve.")]),e._v(" "),a("p",[e._v("A non-compact point encoding was chosen since it still allows to perform some operations in the smart contract itself (inclusion of the full y coordinate) and two encoded points can be compared for equality (no third projective coordinate).")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v('As with the introduction of any precompiled contract, contracts that already use the given addresses will change their semantics. Because of that, the addresses are taken from the "reserved range" below 256.')]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("Inputs to test:")]),e._v(" "),a("ul",[a("li",[e._v("Curve points which would be valid if the numbers were taken mod p (should fail).")]),e._v(" "),a("li",[e._v("Both contracts should succeed on empty input.")]),e._v(" "),a("li",[e._v("Truncated input that results in a valid curve point.")]),e._v(" "),a("li",[e._v("Points not on curve (but valid otherwise).")]),e._v(" "),a("li",[e._v("Multiply point with scalar that lies between the order of the group and the field (should succeed).")]),e._v(" "),a("li",[e._v("Multiply point with scalar that is larger than the field order (should succeed).")])]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("Implementation of these primitives are available here:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/scipr-lab/libff/blob/master/libff/algebra/curves/alt_bn128/alt_bn128_g1.cpp",target:"_blank",rel:"noopener noreferrer"}},[e._v("libff"),a("OutboundLink")],1),e._v(" (C++)")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/zcash/bn/blob/master/src/groups/mod.rs",target:"_blank",rel:"noopener noreferrer"}},[e._v("bn"),a("OutboundLink")],1),e._v(" (Rust)")])]),e._v(" "),a("p",[e._v("In both codebases, a specific group on the curve alt_bn128 is used and is called G1.")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://github.com/ethereum/py_pairing/blob/master/py_ecc/bn128/bn128_curve.py",target:"_blank",rel:"noopener noreferrer"}},[e._v("Python"),a("OutboundLink")],1),e._v(" - probably most self-contained and best readable.")])]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);