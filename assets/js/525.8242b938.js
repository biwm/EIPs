(window.webpackJsonp=window.webpackJsonp||[]).push([[525],{936:function(e,t,a){"use strict";a.r(t);var n=a(46),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v('Make smart contracts (e.g. dapps) accessible to non-ether users by allowing contracts to accept "'),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Collect_call",target:"_blank",rel:"noopener noreferrer"}},[e._v("collect-calls"),a("OutboundLink")],1),e._v('", paying for incoming calls. Let contracts "listen" on publicly accessible channels (e.g. web URL or a whisper address). Incentivize nodes to run "gas stations" to facilitate this. Require no network changes, and minimal contract changes.')]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("Communicating with dapps currently requires paying ETH for gas, which limits dapp adoption to ether users. Therefore, contract owners may wish to pay for the gas to increase user acquisition, or let their users pay for gas with fiat money. Alternatively, a 3rd party may wish to subsidize the gas costs of certain contracts. Solutions such as described in "),a("RouterLink",{attrs:{to:"/zh/eip-1077.html"}},[e._v("EIP-1077")]),e._v(" could allow transactions from addresses that hold no ETH.")],1),e._v(" "),a("p",[e._v("The gas stations network is an "),a("RouterLink",{attrs:{to:"/zh/eip-1077.html"}},[e._v("EIP-1077")]),e._v(' compliant effort to solve the problem by creating an incentive for nodes to run gas stations, where gasless transactions can be "fueled up". It abstracts the implementation details from both the dapp maintainer and the user, making it easy to convert existing dapps to accept "collect-calls".')],1),e._v(" "),a("p",[e._v("The network consists of a single public contract trusted by all participating dapp contracts, and a decentralized network of relay nodes (gas stations) incentivized to listen on non-ether interfaces such as web or whisper, pay for transactions and get compensated by that contract. The trusted contract can be verified by anyone, and the system is otherwise trustless. Gas stations cannot censor transactions as long as there's at least one honest gas station. Attempts to undermine the system can be proven on-chain and offenders can be penalized.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("ul",[a("li",[e._v("Increase user adoption of smart contracts by:\n"),a("ul",[a("li",[e._v("Removing the user hassle of acquiring ETH. Transactions are still paid by ETH but costs can be borne by the dapp or paid by the user through other means.")]),e._v(" "),a("li",[e._v('Removing the need to interact directly with the blockchain, while maintaining decentralization and censorship-resistance. Contracts can "listen" on multiple public channels, and users can interact with the contracts through common protocols that are generally permitted even in restrictive environments.')])])]),e._v(" "),a("li",[e._v("Ethereum nodes get a revenue source without requiring mining equipment. The entire network benefits from having more nodes.")]),e._v(" "),a("li",[e._v("No protocol changes required. The gas station network is self-organized via a smart contract, and dapps interact with the network by implementing an interface.")])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("The system consists of a "),a("code",[e._v("RelayHub")]),e._v(" singleton contract, participating contracts inheriting the "),a("code",[e._v("RelayRecipient")]),e._v(" contract, a decentralized network of "),a("code",[e._v("Relay")]),e._v(" nodes, a.k.a. Gas Stations, and user applications (e.g. mobile or web) interacting with contracts via relays.")]),e._v(" "),a("p",[e._v("Roles of the "),a("code",[e._v("RelayHub")]),e._v(":")]),e._v(" "),a("ul",[a("li",[e._v("Maintain a list of active relays. Senders select a "),a("code",[e._v("Relay")]),e._v(" from this list for each transaction. The selection process is discussed below.")]),e._v(" "),a("li",[e._v("Mediate all communication between relays and contracts.")]),e._v(" "),a("li",[e._v("Provide contracts with trusted versions of the real msg.sender and msg.data.")]),e._v(" "),a("li",[e._v("Hold ETH stakes placed by relays. A minimum stake size is enforced.  Stake can be withdrawn after a relay unregisters and waits for a cooldown period.")]),e._v(" "),a("li",[e._v("Hold ETH prepayments made by contracts and use them to compensate relays.")]),e._v(" "),a("li",[e._v("Penalize provably-offensive relays by giving their stakes to an address providing the proof, thus keeping relays honest.")]),e._v(" "),a("li",[e._v("Provide a free way for relays to know whether they'll be compensated for a future transaction.")])]),e._v(" "),a("p",[e._v("Roles of a "),a("code",[e._v("Relay")]),e._v(" node:")]),e._v(" "),a("ul",[a("li",[e._v("Maintain a hot wallet with a small amount of ETH, to pay for gas.")]),e._v(" "),a("li",[e._v("Provide a public interface for user apps to send gasless transactions via channels such as https or whisper.")]),e._v(" "),a("li",[e._v("Publish it's public interfaces and its price (as a multiplier of the actual transaction gas cost) in "),a("code",[e._v("RelayHub")]),e._v(".")]),e._v(" "),a("li",[e._v("Optionally monitor reverted transactions of other relays through RelayHub, catching offending relays and claiming their stakes. This can be done by anyone, not just a relay.")])]),e._v(" "),a("p",[e._v("Implementing a "),a("code",[e._v("RelayRecipient")]),e._v(" contract:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Know the address of "),a("code",[e._v("RelayHub")]),e._v(" and trust it to provide information about the transaction.")])]),e._v(" "),a("li",[a("p",[e._v("Maintain a small balance of ETH gas prepayment deposit in "),a("code",[e._v("RelayHub")]),e._v(". Can be paid directly by the "),a("code",[e._v("RelayRecipient")]),e._v(" contract, or by the dapp's owner on behalf of the "),a("code",[e._v("RelayRecipient")]),e._v(" address. The dapp owner is responsible for ensuring sufficient balance for the next transactions, and can stop depositing if something goes wrong, thus limiting the potential for abuse of system bugs. In DAO usecases it will be up to the DAO logic to maintain a sufficient deposit.")])]),e._v(" "),a("li",[a("p",[e._v("Use "),a("code",[e._v("getSender()")]),e._v(" and "),a("code",[e._v("getMessageData()")]),e._v(" instead of "),a("code",[e._v("msg.sender")]),e._v(" and "),a("code",[e._v("msg.data")]),e._v(", everywhere. "),a("code",[e._v("RelayRecipient")]),e._v(" provides these functions and gets the information from "),a("code",[e._v("RelayHub")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("Implement a "),a("code",[e._v("acceptRelayedCall(address relay, address from, bytes memory encodedFunction, uint gasPrice, uint transactionFee, bytes memory approval)")]),e._v(" view function that returns "),a("strong",[e._v("zero")]),e._v(" if and only if it is willing to accept a transaction and pay for it. "),a("code",[e._v("acceptRelayedCall")]),e._v(" is called by "),a("code",[e._v("RelayHub")]),e._v(" as a view function when a "),a("code",[e._v("Relay")]),e._v(" inquires it, and also during the actual transaction. Transactions are reverted if "),a("strong",[e._v("non-zero")]),e._v(", and "),a("code",[e._v("Relay")]),e._v(" only gets compensated for transactions (whether successful or reverted) if "),a("code",[e._v("acceptRelayedCall")]),e._v(" returns "),a("strong",[e._v("zero")]),e._v(". Some examples of "),a("code",[e._v("acceptRelayedCall()")]),e._v(" implementations:")]),e._v(" "),a("ul",[a("li",[e._v("Whitelist of trusted dapp members.")]),e._v(" "),a("li",[e._v("Balance sheet of registered users, maintained by the dapp owner. Users pay the dapp with a credit card or other non-ETH means, and are credited in the "),a("code",[e._v("RelayRecipient")]),e._v(" balance sheet. Users can never cost the dapp more than they were credited for.")]),e._v(" "),a("li",[e._v("A dapp can provide off-chain a signed message called "),a("code",[e._v("approval")]),e._v(" to a transaction sender and validate it.")]),e._v(" "),a("li",[e._v("Whitelist of known transactions used for onboarding new users. This allows certain anonymous calls and is subject to Sybil attacks. Therefore it should be combined with a restricted gasPrice, and a whitelist of trusted relays, to reduce the incentive for relays to create bogus transactions and rob the dapp's prepaid gas deposit. Dapps allowing anonymous onboarding transactions might benefit from registering their own "),a("code",[e._v("Relay")]),e._v(" and accepting anonymous transactions only from that "),a("code",[e._v("Relay")]),e._v(", whereas other transactions can be accepted from any relay. Alternatively, dapps may use the balance sheet method for onboarding as well, by applying the methods suggested in the attacks/mitigations section below.")])])]),e._v(" "),a("li",[a("p",[e._v("Implement "),a("code",[e._v("preRelayedCall(address relay, address from, bytes memory encodedFunction, uint transactionFee) returns (bytes32)")]),e._v(". This method is called before a transaction is relayed. By default, it does nothing.")])]),e._v(" "),a("li",[a("p",[e._v("Implement "),a("code",[e._v("postRelayedCall(ddress relay, address from, bytes memory encodedFunction, bool success, uint usedGas, uint transactionFee, bytes32 preRetVal)")]),e._v(". This method is called after a transaction is relayed. By default, it does nothing.")]),e._v(" "),a("p",[e._v("These two methods can be used to charge the user in dapp-specific manner.")])])]),e._v(" "),a("p",[e._v("Glossary of terms used in the processes below:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("RelayHub")]),e._v(" - the RelayHub singleton contract, used by everyone.")]),e._v(" "),a("li",[a("code",[e._v("Recipient")]),e._v(" - a contract implementing "),a("code",[e._v("RelayRecipient")]),e._v(", accepting relayed transactions from the RelayHub contract and paying for the incoming transactions.")]),e._v(" "),a("li",[a("code",[e._v("Sender")]),e._v(" - an external address with a valid key pair but no ETH to pay for gas.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" - a node holding ETH in an external address, listed in RelayHub and relaying transactions from Senders to RelayHub for a fee.")])]),e._v(" "),a("p",[a("img",{attrs:{src:"/assets/eip-1613/sequence.png",alt:"Sequence Diagram"}})]),e._v(" "),a("p",[e._v("The process of registering/refreshing a "),a("code",[e._v("Relay")]),e._v(":")]),e._v(" "),a("ul",[a("li",[e._v("Relay starts listening as a web app (or on some other communication channel).")]),e._v(" "),a("li",[e._v("If starting for the first time (no key yet), generate a key pair for Relay's address.")]),e._v(" "),a("li",[e._v("If Relay's address doesn't hold sufficient funds for gas (e.g. because it was just generated), Relay stays inactive until its owner funds it.")]),e._v(" "),a("li",[e._v("Relay's owner funds it.")]),e._v(" "),a("li",[e._v("Relay's owner sends the required stake to "),a("code",[e._v("RelayHub")]),e._v(" by calling "),a("code",[e._v("RelayHub.stake(address relay, uint unstakeDelay)")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" puts the "),a("code",[e._v("owner")]),e._v(" and "),a("code",[e._v("unstake delay")]),e._v(" in the relays map, indexed by "),a("code",[e._v("relay")]),e._v(" address.")]),e._v(" "),a("li",[e._v("Relay calls "),a("code",[e._v("RelayHub.registerRelay(uint transactionFee, string memory url)")]),e._v(" with the relay's "),a("code",[e._v("transaction fee")]),e._v(" (as a multiplier on transaction gas cost), and a URL for incoming transactions.")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" ensures that Relay has a sufficient stake.")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" puts the "),a("code",[e._v("transaction fee")]),e._v(" in the relays map.")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" emits an event, "),a("code",[e._v("RelayAdded(Relay, owner, transactionFee, relayStake, unstakeDelay, url)")]),e._v(".")]),e._v(" "),a("li",[e._v("Relay starts a timer to perform a "),a("code",[e._v("keepalive")]),e._v(" transaction every 6000 blocks.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" goes to sleep and waits for signing requests.")])]),e._v(" "),a("p",[e._v("The process of sending a relayed transaction:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("Sender")]),e._v(" selects a live "),a("code",[e._v("Relay")]),e._v(" from RelayHub's list by looking at "),a("code",[e._v("RelayAdded")]),e._v(" events from "),a("code",[e._v("RelayHub")]),e._v(", and sorting based on its own criteria. Selection may be based on a mix of:\n"),a("ul",[a("li",[e._v("Relay published transaction fees.")]),e._v(" "),a("li",[e._v("Relay stake size and lock-up time.")]),e._v(" "),a("li",[e._v("Recent relay transactions (visible through "),a("code",[e._v("TransactionRelayed")]),e._v(" events from "),a("code",[e._v("RelayHub")]),e._v(").")]),e._v(" "),a("li",[e._v("Optionally, reputation/blacklist/whitelist held by the sender app itself, or its backend, on per-app basis (not part of the gas stations network).")])])]),e._v(" "),a("li",[e._v("Sender prepares the transaction with Sender's address, the recipient address, the actual transaction data, Relay's transaction fee, gas price, gas limit, its current nonce from "),a("code",[e._v("RelayHub.nonces")]),e._v(", RelayHub's address, and Relay's address, and then signs it.")]),e._v(" "),a("li",[e._v("Sender verifies that "),a("code",[e._v("RelayHub.balances[recipient]")]),e._v(" holds enough ETH to pay Relay's fee.")]),e._v(" "),a("li",[e._v("Sender verifies that "),a("code",[e._v("Relay.balance")]),e._v(" has enough eth to send the transaction")]),e._v(" "),a("li",[e._v("Sender reads the Relay's current "),a("code",[e._v("nonce")]),e._v(" value and decides on the "),a("code",[e._v("max_nonce")]),e._v(" parameter.")]),e._v(" "),a("li",[e._v("Sender sends the signed transaction amd metadata to Relay's web interface.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" wraps the transaction with a transaction to "),a("code",[e._v("RelayHub")]),e._v(", with zero ETH value.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" signs the wrapper transaction with its key in order to pay for gas.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" verifies that:\n"),a("ul",[a("li",[e._v("The transaction's recipient contract will accept this transaction when submitted, by calling "),a("code",[e._v("RelayHub.canRelay()")]),e._v(", a view function, which checks the recipient's "),a("code",[e._v("acceptRelayedCall")]),e._v(", also a view function, stating whether it's willing to accept the charges).")]),e._v(" "),a("li",[e._v("The transaction nonce matches "),a("code",[e._v("RelayHub.nonces[sender]")]),e._v(".")]),e._v(" "),a("li",[e._v("The relay address in the transaction matches Relay's address.")]),e._v(" "),a("li",[e._v("The transaction's recipient has enough ETH deposited in "),a("code",[e._v("RelayHub")]),e._v(" to pay the transaction fee.")]),e._v(" "),a("li",[e._v("Relay has enough ETH to pay for the gas required by the transaction.")]),e._v(" "),a("li",[e._v("Value of "),a("code",[e._v("max_nonce")]),e._v(" is higher than current Relay's "),a("code",[e._v("nonce")])])])]),e._v(" "),a("li",[e._v("If any of Relay's checks fail, it returns an error to sender, and doesn't proceed.")]),e._v(" "),a("li",[e._v("Relay submits the signed wrapped transaction to the blockchain.")]),e._v(" "),a("li",[e._v("Relay immediately returns the signed wrapped transaction to the sender.  This step is discussed below, in attacks/mitigations.")]),e._v(" "),a("li",[a("code",[e._v("Sender")]),e._v(" receives the wrapped transaction and verifies that:\n"),a("ul",[a("li",[e._v("It's a valid relay call to "),a("code",[e._v("RelayHub")]),e._v(". from Relay's address.")]),e._v(" "),a("li",[e._v("The transaction's ethereum nonce matches Relay's current nonce.")]),e._v(" "),a("li",[e._v("The transaction's ethereum nonce is lower than or equal to "),a("code",[e._v("max_nonce")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" is sufficiently funded to pay for it.")]),e._v(" "),a("li",[e._v("The wrapped transaction is valid and signed by "),a("code",[e._v("sender")]),e._v(".")]),e._v(" "),a("li",[e._v("Recipient contract has sufficient funds in "),a("code",[e._v("RelayHub.balances")]),e._v(" to pay for Relay's fee as stated in the transaction.")])])]),e._v(" "),a("li",[e._v("If any of sender's checks fails, it goes back to selecting a new Relay. Sender may also file a report on the unresponsive relay to its backend or save it locally, to down-sort this relay in future transactions.")]),e._v(" "),a("li",[a("code",[e._v("Sender")]),e._v(" may also submit the raw wrapped transaction to the blockchain without paying for gas, through any Ethereum node. This submission is likely ignored because an identical transaction is already in the network's pending transactions, but no harm in putting it twice, to ensure that it happens. This step is not strictly necessary, for reasons discussed below in attacks/mitigations, but may speed things up.")]),e._v(" "),a("li",[a("code",[e._v("Sender")]),e._v(" monitors the blockchain, waiting for the transaction to be mined. The transaction was verified, with Relay's current nonce, so mining must be successful unless Relay submitted another (different) transaction with the same nonce. If mining fails due to such attack, sender may call "),a("code",[e._v("RelayHub.penalizeRepeatedNonce")]),e._v(" through another relay, to collect his reward and burn the remainder of the offending relay's stake, and then go back to selecting a new Relay for the transaction. See discussion in the attacks/mitigations section below.")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" receives the transaction:\n"),a("ul",[a("li",[e._v("Records "),a("code",[e._v("gasleft()")]),e._v(" as "),a("code",[e._v("initialGas")]),e._v(" for later payment.")]),e._v(" "),a("li",[e._v("Verifies the transaction is sent from a registered relay.")]),e._v(" "),a("li",[e._v("Verifies that the signature of the internal transaction matches its stated origin (sender's key).")]),e._v(" "),a("li",[e._v("Verifies that the relay address written in the transaction matches msg.sender.")]),e._v(" "),a("li",[e._v("Verifies that the transaction's "),a("code",[e._v("nonce")]),e._v(" matches the stated origin's nonce in "),a("code",[e._v("RelayHub.nonces")]),e._v(".")]),e._v(" "),a("li",[e._v("Calls recipient's "),a("code",[e._v("acceptRelayedCall")]),e._v(" function, asking whether it's going to accept the transaction. If not, the "),a("code",[e._v("TransactionRelayed")]),e._v(" will be emitted with status "),a("code",[e._v("CanRelayFailed")]),e._v(", and "),a("code",[e._v("chargeOrCanRelayStatus")]),e._v(" will contain the return value of "),a("code",[e._v("acceptRelayedCall")]),e._v(". In this case, Relay doesn't get paid, as it was its responsibility to check "),a("code",[e._v("RelayHub.canRelay")]),e._v(" before releasing the transaction.")]),e._v(" "),a("li",[e._v("Calls recipient's "),a("code",[e._v("preRelayedCall")]),e._v(" function. If this call reverts the "),a("code",[e._v("TransactionRelayed")]),e._v(" will be emitted with status "),a("code",[e._v("PreRelayedFailed")]),e._v(".")]),e._v(" "),a("li",[e._v("Sends the transaction to the recipient.  If this call reverts the "),a("code",[e._v("TransactionRelayed")]),e._v(" will be emitted with status "),a("code",[e._v("RelayedCallFailed")]),e._v(". When passing gas to "),a("code",[e._v("call()")]),e._v(", enough gas is preserved by "),a("code",[e._v("RelayHub")]),e._v(", for post-call handling. Recipient may run out of gas, but "),a("code",[e._v("RelayHub")]),e._v(" never does. "),a("code",[e._v("RelayHub")]),e._v(" also sends sender's address at the end of "),a("code",[e._v("msg.data")]),e._v(", so "),a("code",[e._v("RelayRecipient.getSender()")]),e._v(" will be able to extract the real sender, and trust it because the transaction came from the known "),a("code",[e._v("RelayHub")]),e._v(" address.")])])]),e._v(" "),a("li",[e._v("Recipient contract handles the transaction.")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" calls recipient's "),a("code",[e._v("postRelayedCall")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" checks call's return value of call, and emits "),a("code",[e._v("TransactionRelayed(address relay, address from, address to, bytes4 selector, uint256 status, uint256 chargeOrCanRelayStatus)")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" increases "),a("code",[e._v("RelayHub.nonces[sender]")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" transfers ETH balance from recipient to "),a("code",[e._v("Relay.owner")]),e._v(", to pay the transaction fee, based on the measured transaction cost. Note on relay payment: The relay gets paid for actual gas used, regardless of whether the recipient reverted. The only case where the relay sustains a loss, is if "),a("code",[e._v("canRelay")]),e._v(" returns non-zero, since the relay was responsible to verify this view function prior to submitting. Any other revert is caught and paid for. See attacks/mitigations below.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" keeps track of transactions it sent, and waits for "),a("code",[e._v("TransactionRelayed")]),e._v(" events to see the charge. If a transaction reverts and goes unpaid, which means the recipient's "),a("code",[e._v("acceptRelayedCall()")]),e._v(" function was inconsistent, "),a("code",[e._v("Relay")]),e._v(" refuses service to that recipient for a while (or blacklists it indefinitely, if it happens often). See attacks/mitigations below.")])]),e._v(" "),a("p",[e._v("The process of winding a "),a("code",[e._v("Relay")]),e._v(" down:")]),e._v(" "),a("ul",[a("li",[e._v("Relay's owner (the address that initially funded it) calls "),a("code",[e._v("RelayHub.removeRelayByOwner(Relay)")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" ensures that the sender is indeed Relay's owner, then removes "),a("code",[e._v("Relay")]),e._v(", and emits "),a("code",[e._v("RelayRemoved(Relay)")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("RelayHub")]),e._v(" starts the countdown towards releasing the owner's stake.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" receives its "),a("code",[e._v("RelayRemoved")]),e._v(" event.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" sends all its remaining ETH to its owner.")]),e._v(" "),a("li",[a("code",[e._v("Relay")]),e._v(" shuts down.")]),e._v(" "),a("li",[e._v("Once the owner's unstake delay is over, owner calls "),a("code",[e._v("RelayHub.unstake()")]),e._v(", and withdraws the stake.")])]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("The rationale for the gas stations network design is a combination of two sets of requirements: Easy adoption, and robustness.")]),e._v(" "),a("p",[e._v("For easy adoption, the design goals are:")]),e._v(" "),a("ul",[a("li",[e._v("No network changes.")]),e._v(" "),a("li",[e._v("Minimal changes to contracts, apps and frameworks.")])]),e._v(" "),a("p",[e._v("The robustness requirement translates to decentralization and attack resistance. The gas stations network is decentralized, and we have to assume that any entity may attack other entities in the system.")]),e._v(" "),a("p",[e._v("Specifically we've considered the following types of attacks:")]),e._v(" "),a("ul",[a("li",[e._v("Denial-of-service attacks against individual senders, i.e. transactions censorship.")]),e._v(" "),a("li",[e._v("Denial-of-service and financial attacks against individual relays.")]),e._v(" "),a("li",[e._v("Denial-of-service and financial attacks against individual contracts.")]),e._v(" "),a("li",[e._v("Denial-of-service attacks against the entire network, either by attacking existing entities, or by introducing any number of malicious entities.")])]),e._v(" "),a("h4",{attrs:{id:"attacks-and-mitigations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attacks-and-mitigations"}},[e._v("#")]),e._v(" Attacks and mitigations")]),e._v(" "),a("h5",{attrs:{id:"attack-relay-attempts-to-censor-a-transaction-by-not-signing-it-or-otherwise-ignoring-a-user-request"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-relay-attempts-to-censor-a-transaction-by-not-signing-it-or-otherwise-ignoring-a-user-request"}},[e._v("#")]),e._v(" Attack: Relay attempts to censor a transaction by not signing it, or otherwise ignoring a user request.")]),e._v(" "),a("p",[e._v("Relay is expected to return the signed transaction to the sender, immediately. Sender doesn't need to wait for the transaction to be mined, and knows immediately whether it's request has been served. If a relay doesn't return a signed transaction within a couple of seconds, sender cancels the operation, drops the connection, and switches to another relay. It also marks Relay as unresponsive in its private storage to avoid using it in the near future.")]),e._v(" "),a("p",[e._v("Therefore, the maximal damage a relay can cause with such attack, is a one-time delay of a couple of seconds. After a while, senders will avoid it altogether.")]),e._v(" "),a("h5",{attrs:{id:"attack-relay-attempts-to-censor-a-transaction-by-signing-it-returning-it-to-the-sender-but-never-putting-it-on-the-blockchain"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-relay-attempts-to-censor-a-transaction-by-signing-it-returning-it-to-the-sender-but-never-putting-it-on-the-blockchain"}},[e._v("#")]),e._v(" Attack: Relay attempts to censor a transaction by signing it, returning it to the sender, but never putting it on the blockchain.")]),e._v(" "),a("p",[e._v("This attack will backfire and not censor the transaction. The sender can submit the transaction signed by Relay to the blockchain as a raw transaction through any node, so the transaction does happen, but Relay may be unaware and therefore be stuck with a bad nonce which will break its next transaction.")]),e._v(" "),a("h5",{attrs:{id:"attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-publishing-a-different-transaction-with-the-same-nonce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-publishing-a-different-transaction-with-the-same-nonce"}},[e._v("#")]),e._v(" Attack: Relay attempts to censor a transaction by signing it, but publishing a different transaction with the same nonce.")]),e._v(" "),a("p",[e._v("Reusing the nonce is the only DoS performed by a Relay, that cannot be detected within a couple of seconds during the http request. It will only be detected when the malicious transaction with the same nonce gets mined and triggers the "),a("code",[e._v("RelayHub.TransactionRelayed")]),e._v(" event. However, the attack will backfire and cost Relay its entire stake.")]),e._v(" "),a("p",[e._v("Sender has a signed transaction from Relay with nonce N, and also gets a mined transaction from the blockchain with nonce N, also signed by Relay. This proves that Relay performed a DoS attack against the sender. The sender calls "),a("code",[e._v("RelayHub.penalizeRepeatedNonce(bytes transaction1, bytes transaction2)")]),e._v(", which verifies the attack, confiscates Relay's stake, and sends half of it to the sender who delivered the "),a("code",[e._v("penalizeRepeatedNonce")]),e._v(" call. The other half of the stake is burned by sending it to "),a("code",[e._v("address(0)")]),e._v(". Burning is done to prevent cheating relays from effectively penalizing themselves and getting away without any loss. The sender then proceeds to select a new relay and send the original transaction.")]),e._v(" "),a("p",[e._v("The result of such attack is a delay of a few blocks in sending the transaction (until the attack is detected) but the relay gets removed and loses its entire stake. Scaling such attack would be prohibitively expensive, and actually quite profitable for senders and honest relays.")]),e._v(" "),a("h5",{attrs:{id:"attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-using-a-nonce-higher-than-it-s-current-nonce"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-using-a-nonce-higher-than-it-s-current-nonce"}},[e._v("#")]),e._v(" Attack: Relay attempts to censor a transaction by signing it, but using a nonce higher than it's current nonce.")]),e._v(" "),a("p",[e._v("In this attack, the Relay did create and return a perfectly valid transaction, but it will not be mined until this Relay fills the gap in the nonce with 'missing' transactions. This may delay the relaying of some transactions indefinitely. In order to mitigate that, the sender includes a "),a("code",[e._v("max_nonce")]),e._v(" parameter with it's signing request. It is suggested to be higher by 2-3 from current nonce, to allow the relay process several transactions.")]),e._v(" "),a("p",[e._v("When the sender receives a transaction signed by a Relay he validates that the nonce used is valid, and if it is not, the client will ignore the given relay and use other relays to relay given transaction. Therefore, there will be no actual delay introduced by such attack.")]),e._v(" "),a("h5",{attrs:{id:"attack-dapp-attempts-to-burn-relays-funds-by-implementing-an-inconsistent-acceptrelayedcall-and-using-multiple-sender-addresses-to-generate-expensive-transactions-thus-performing-a-dos-attack-on-relays-and-reducing-their-profitability"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-dapp-attempts-to-burn-relays-funds-by-implementing-an-inconsistent-acceptrelayedcall-and-using-multiple-sender-addresses-to-generate-expensive-transactions-thus-performing-a-dos-attack-on-relays-and-reducing-their-profitability"}},[e._v("#")]),e._v(" Attack: Dapp attempts to burn relays funds by implementing an inconsistent acceptRelayedCall() and using multiple sender addresses to generate expensive transactions, thus performing a DoS attack on relays and reducing their profitability.")]),e._v(" "),a("p",[e._v("In this attack, a contract sets an inconsistent acceptRelayedCall (e.g. return zero for even blocks, nonzero for odd blocks), and uses it to exhaust relay resources through unpaid transactions. Relays can easily detect it after the fact. If a transaction goes unpaid, the relay knows that the recipient contract's acceptRelayedCall has acted inconsistently, because the relay has verified its view function before sending the transaction. It might be the result of a rare race condition where the contract's state has changed between the view call and the transaction, but if it happens too frequently, relays will blacklist this contract and refuse to serve transactions to it. Each offending contract can only cause a small damage (e.g. the cost of 2-3 transactions) to a relay, before getting blacklisted.")]),e._v(" "),a("p",[e._v("Relays may also look at recipients' history on the blockchain, looking for past unpaid transactions (reverted by RelayHub without pay), and denying service to contracts with a high failure rate. If a contract caused this minor loss to a few relays, all relays will stop serving it, so it can't cause further damage.")]),e._v(" "),a("p",[e._v("This attack doesn't scale because the cost of creating a malicious contract is in the same order of magnitude as the damage it can cause to the network. Causing enough damage to exhaust the resources of all relays, would be prohibitively expensive.")]),e._v(" "),a("p",[e._v("The attack can be made even more impractical by setting RelayHub to require a stake from dapps before they can be served, and enforcing an unstaking delay, so that attackers will have to raise a vast amount of ETH in order to simultaneously create enough malicious contracts and attack relays. This protection is probably an overkill, since the attack doesn't scale regardless.")]),e._v(" "),a("h5",{attrs:{id:"attack-user-attempts-to-rob-dapps-by-registering-its-own-relay-and-sending-expensive-transactions-to-dapps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-user-attempts-to-rob-dapps-by-registering-its-own-relay-and-sending-expensive-transactions-to-dapps"}},[e._v("#")]),e._v(" Attack: User attempts to rob dapps by registering its own relay and sending expensive transactions to dapps.")]),e._v(" "),a("p",[e._v("If a malicious sender repeatedly abuses a recipient by sending meaningless/reverted transactions and causing the recipient to pay a relay for nothing, it is the recipient's responsibility to blacklist that sender and have its acceptRelayedCall function return nonzero for that sender. Collect calls are generally not meant for anonymous senders unknown to the recipient. Dapps that utilize the gas station networks should have a way to blacklist malicious users in their system and prevent Sybil attacks.")]),e._v(" "),a("p",[e._v("A simple method that mitigates such Sybil attack, is that the dapp lets users buy credit with a credit card, and credit their account in the dapp contract, so acceptRelayedCall() only returns zero for users that have enough credit, and deduct the amount paid to the relay from the user's balance, whenever a transaction is relayed for the user. With this method, the attacker can only burn its own resources, not the dapp's.")]),e._v(" "),a("p",[e._v("A variation of this method, for free dapps (that don't charge the user, and prefer to pay for their users transactions) is to require a captcha during user creation in their web interface, or to login with a Google/Facebook account, which limits the rate of the attack to the attacker's ability to open many Google/Facebook accounts. Only a user that passed that process is given credit in RelayRecipient. The rate of such Sybil attack would be too low to cause any real damage.")]),e._v(" "),a("h5",{attrs:{id:"attack-attacker-attempts-to-reduce-network-availability-by-registering-many-unreliable-relays"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-attacker-attempts-to-reduce-network-availability-by-registering-many-unreliable-relays"}},[e._v("#")]),e._v(" Attack: Attacker attempts to reduce network availability by registering many unreliable relays.")]),e._v(" "),a("p",[e._v("Registering a relay requires placing a stake in RelayHub, and the stake can only be withdrawn after the relay is unregistered and a long cooldown period has passed, e.g. a month.")]),e._v(" "),a("p",[e._v("Each unreliable relay can only cause a couple of seconds delay to senders, once, and then it gets blacklisted by them, as described in the first attack above. After it caused this minor delay and got blacklisted, the attacker must wait a month before reusing the funds to launch another unreliable relay. Simultaneously bringing up a number of unreliable relays, large enough to cause a noticeable network delay, would be prohibitively expensive due to the required stake, and even then, all those relays will get blacklisted within a short time.")]),e._v(" "),a("h5",{attrs:{id:"attack-attacker-attempts-to-replay-a-relayed-transaction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-attacker-attempts-to-replay-a-relayed-transaction"}},[e._v("#")]),e._v(" Attack: Attacker attempts to replay a relayed transaction.")]),e._v(" "),a("p",[e._v("Transactions include a nonce. RelayHub maintains a nonce (counter) for each sender. Transactions with bad nonces get reverted by RelayHub. Each transaction can only be relayed once.")]),e._v(" "),a("h5",{attrs:{id:"attack-user-does-not-execute-the-raw-transaction-received-from-the-relayer-therefore-blocking-the-execution-of-all-further-transactions-signed-by-this-relayer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#attack-user-does-not-execute-the-raw-transaction-received-from-the-relayer-therefore-blocking-the-execution-of-all-further-transactions-signed-by-this-relayer"}},[e._v("#")]),e._v(" Attack: User does not execute the raw transaction received from the Relayer, therefore blocking the execution of all further transactions signed by this relayer")]),e._v(" "),a("p",[e._v("The user doesn't really have to execute the raw transaction. It's enough that the user can. The relationship between relay and sender is mutual distrust. The process described above incentivizes the relay to execute the transaction, so the user doesn't need to wait for actual mining to know that the transaction has been executed.")]),e._v(" "),a("p",[e._v("Once relay returns the signed transaction, which should happen immediately, the relay is incentivized to also execute it on chain, so that it can advance its nonce and serve the next transaction. The user can (but doesn't have to) also execute the transaction. To understand why the attack isn't viable, consider the four possible scenarios after the signed transaction was returned to the sender:")]),e._v(" "),a("ol",[a("li",[e._v("Relay executes the transaction, and the user doesn't. In this scenario the transaction is executed, so no problem. This is the case described in this attack.")]),e._v(" "),a("li",[e._v("Relay doesn't execute the transaction, but the user does. Similarly to 1, the transaction is executed, so no problem.")]),e._v(" "),a("li",[e._v("Both of them execute the transaction. The transactions are identical in the pending transactions pool, so the transaction gets executed once. No problem.")]),e._v(" "),a("li",[e._v("None of them execute the transaction. In this case the transaction doesn't get executed, but the relay is stuck. It can't serve the next transaction with the next nonce, because its nonce hasn't been advanced on-chain. It also can't serve the next transaction with the current nonce, as this can be proven by the user, having two different transactions signed by the same relay, with the same nonce. The user could use this to take the relay's nonce. So the relay is stuck unless it executes the transaction.")])]),e._v(" "),a("p",[e._v("As this matrix shows, the relay is "),a("strong",[e._v("always")]),e._v(" incentivized to execute the transaction, once it returned it to the user, in order to end up in #1 or #3, and avoid the risk of #4. It's just a way to commit the relay to do its work, without requiring the user to wait for on-chain confirmation.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("The gas stations network is implemented as smart contracts and external entities, and does not require any network changes.")]),e._v(" "),a("p",[e._v("Dapps adding gas station network support remain backwards compatible with their existing apps/users. The added methods apply on top of the existing ones, so no changes are required for existing apps.")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("A working implementation of the "),a("a",{attrs:{href:"https://github.com/tabookey-dev/tabookey-gasless",target:"_blank",rel:"noopener noreferrer"}},[a("strong",[e._v("gas stations network")]),a("OutboundLink")],1),e._v(" is being developed by "),a("strong",[e._v("TabooKey")]),e._v(". It consists of "),a("code",[e._v("RelayHub")]),e._v(", "),a("code",[e._v("RelayRecipient")]),e._v(", "),a("code",[e._v("web3 hooks")]),e._v(", an implementation of a gas station inside "),a("code",[e._v("geth")]),e._v(", and sample dapps using the gas stations network.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);