(window.webpackJsonp=window.webpackJsonp||[]).push([[674],{1095:function(e,t,a){"use strict";a.r(t);var o=a(46),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Enable new opcode to clear storage for "),a("code",[e._v("SELFDESTRUCTED")]),e._v("ed contracts.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("Changes "),a("code",[e._v("SELFDESTRUCT")]),e._v(" ("),a("code",[e._v("0xff")]),e._v(") to not clear any storage and adds a new "),a("code",[e._v("EXTCLEAR")]),e._v(" ("),a("code",[e._v("0x5c")]),e._v(") opcode that will clear a specific storage slot for a contract that has previously been self destructed.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[a("code",[e._v("SELFDESTRUCT")]),e._v(" ("),a("code",[e._v("0xFF")]),e._v(") is unnecessarily complex because it clears an unbounded amount of contract storage. It is computationally expensive for nodes to track all of the storage used in every contract in case the contract "),a("code",[e._v("SELFDESTRUCT")]),e._v("s. Further, contracts can be re-initialized using "),a("code",[e._v("CREATE2")]),e._v(" ("),a("code",[e._v("0xF5")]),e._v("), and then "),a("code",[e._v("SLOAD")]),e._v(" ("),a("code",[e._v("0x54")]),e._v(") prior storage. Therefore, several ethereum clients do not clear storage at all, and just check if the contract was initiated since "),a("code",[e._v("SSTORE")]),e._v(" ("),a("code",[e._v("0x55")]),e._v(") during "),a("code",[e._v("SLOAD")]),e._v(". "),a("code",[e._v("CREATE2")]),e._v(" was not intended to complicate "),a("code",[e._v("SLOAD")]),e._v(", and this change reverts that complexity. Also, bugs in this implementation could split the network.")]),e._v(" "),a("p",[e._v("Instead this defers the time of storage cleanup, and leaves the storage in-place, which reduces the complexity of "),a("code",[e._v("SLOAD")]),e._v(" and "),a("code",[e._v("SELFDESTRUCT")]),e._v(".")]),e._v(" "),a("p",[e._v("This empowers the "),a("code",[e._v("CREATE2")]),e._v(" reincarnation proxy pattern by retaining storage during upgrade, which would otherwise have to be reset again. An atomic reincarnation upgrade could clear a subset of storage during the upgrade, while the contract is destroyed, before reinstating it.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("After "),a("code",[e._v("FORK_BLOCK_NUM")]),e._v(", a new opcode, "),a("code",[e._v("EXTCLEAR")]),e._v(", is enabled at "),a("code",[e._v("0x5C")]),e._v(" to clear storage for "),a("code",[e._v("SELFDESTRUCT")]),e._v("ed contracts. "),a("code",[e._v("EXTCLEAR")]),e._v(":")]),e._v(" "),a("ul",[a("li",[e._v("does not push any words onto the stack")]),e._v(" "),a("li",[e._v("pops two words off the stack: the destroyed contract address and a storage address")]),e._v(" "),a("li",[e._v("if the contract exists, charge the same gas cost as "),a("code",[e._v("EXTCODEHASH")]),e._v(" ("),a("code",[e._v("0x3F")]),e._v(")")]),e._v(" "),a("li",[e._v("otherwise, if the storage is zero, charge the same gas as "),a("code",[e._v("EXTCODEHASH")]),e._v(" plus "),a("code",[e._v("SLOAD")])]),e._v(" "),a("li",[e._v("otherwise, the destroyed contract's slot is reset to 0, charging the same gas as "),a("code",[e._v("EXTCODEHASH")]),e._v(" and "),a("code",[e._v("SSTORE")]),e._v(" when resetting storage, while also refunding the amount specified in "),a("code",[e._v("SSTORE")]),e._v(".")])]),e._v(" "),a("p",[a("code",[e._v("SELFDESTRUCT")]),e._v(" is modified to not clear contract storage. This change also works retroactively: all prior destroyed contracts can be cleaned up.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[a("code",[e._v("0x5C")]),e._v(" is available in the same range as "),a("code",[e._v("SSTORE")]),e._v(" and "),a("code",[e._v("SLOAD")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("A reincarnation upgrade mechanism that expects all internal storage to be cleared might break, but such an upgrade mechanism would allow adaptation to this new behavior.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("TODO")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("Implementation is required on all major clients to add the opcode.")]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("A reincarnated contract that does not expect its state to be cleared by malicious actors SHOULD reinitialize itself to avoid antagonistic "),a("code",[e._v("EXTCLEAR")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);