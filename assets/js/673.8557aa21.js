(window.webpackJsonp=window.webpackJsonp||[]).push([[673],{1094:function(e,t,a){"use strict";a.r(t);var o=a(46),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Store historical block hashes in a contract, and modify the "),a("code",[e._v("BLOCKHASH (0x40)")]),e._v(" opcode to read this contract.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("There is increasingly a desire to remove the need for most clients to store history older than some relatively short duration (often between 1 week and 1 year) to save disk space. This requires some form of layer-2 network to help clients access historical information. These protocols can be made much simpler if blocks contained a quick Merkle path to historical blocks.")]),e._v(" "),a("p",[e._v("Additional secondary motivations include:")]),e._v(" "),a("ul",[a("li",[e._v('The protocol can be used to make more secure efficient light clients with flyclient-like technology (while the "optimal" flyclient protocol is fairly complex, large security gains over the status quo (trusted "canonical hash trees") can be made cheaply)')]),e._v(" "),a("li",[e._v("Improving cleanness of the protocol, as the BLOCKHASH opcode would then access state and not history.")])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Parameter")]),e._v(" "),a("th",[e._v("Value")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("FORK_BLKNUM")])]),e._v(" "),a("td",[e._v("TBD")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("HISTORY_STORAGE_ADDRESS")])]),e._v(" "),a("td",[a("code",[e._v("0xfffffffffffffffffffffffffffffffffffffffe")])])])])]),e._v(" "),a("p",[e._v("At the start of processing any block where "),a("code",[e._v("block.number > FORK_BLKNUM")]),e._v(" (ie. before processing any transactions), run "),a("code",[e._v("sstore(HISTORY_STORAGE_ADDRESS, block.number - 1, block.prevhash)")]),e._v(".")]),e._v(" "),a("p",[e._v("When "),a("code",[e._v("block.number > FORK_BLKNUM + 256")]),e._v(", change the logic of the "),a("code",[e._v("BLOCKHASH")]),e._v(" opcode as follows: if "),a("code",[e._v("FORK_BLKNUM <= arg < block.number")]),e._v(", return "),a("code",[e._v("sload(HISTORY_STORAGE_ADDRESS, arg)")]),e._v(". Otherwise return 0.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Very similar ideas were proposed before in EIP-98 and EIP-210. This EIP is a simplification, removing two sources of needless complexity:")]),e._v(" "),a("ol",[a("li",[e._v("Having a tree-like structure with multiple layers as opposed to a single list")]),e._v(" "),a("li",[e._v("Writing the EIP in EVM code")])]),e._v(" "),a("p",[e._v('The former was intended to save space. Since then, however, storage usage has increased massively, to the point where even eg. 5 million new storage slots are fairly negligible compared to existing usage. The latter was intended as a first step toward "writing the Ethereum protocol in EVM" as much as possible, but this goal has since been de-facto abandoned.')]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("The range of "),a("code",[e._v("BLOCKHASH")]),e._v(" is increased by this opcode, but behavior within the previous 256-block range remains unchanged.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("TBD")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("TBD")]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("Adding ~2.5 million storage slots per year bloats the state somewhat (but not much relative to the hundreds of millions of existing state objects). However, this EIP is not intended to be permanent; when eth1 is merged into eth2, the BLOCKHASH opcode would likely be repurposed to use eth2's built-in history accumulator structure (see "),a("a",{attrs:{href:"https://github.com/ethereum/annotated-spec/blob/master/phase0/beacon-chain.md#slots_per_historical_root",target:"_blank",rel:"noopener noreferrer"}},[e._v("phase 0 spec"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);