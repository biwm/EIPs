(window.webpackJsonp=window.webpackJsonp||[]).push([[657],{1076:function(e,t,a){"use strict";a.r(t);var s=a(46),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Creates a new transaction type that supports sponsored transactions (separate gas payer from sender), batch transactions (multiple transactions executed in sequence), and expiring transactions (transactions which are not valid after a certain timestamp).")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("An EIP-2718 transaction with the type number "),a("code",[e._v("2")]),e._v(" is a new type of transaction that includes support for:")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Sponsored Transactions")]),e._v(": an optional additional signature from which the account that will pay for gas ("),a("code",[e._v("GAS_PAYER")]),e._v(") can be recovered")]),e._v(" "),a("li",[a("strong",[e._v("Batch Transactions")]),e._v(": multiple transactions from the same sender that will be executed in sequence")]),e._v(" "),a("li",[a("strong",[e._v("Expiring Transactions")]),e._v(": an optional "),a("code",[e._v("validUntil")]),e._v(" field that makes the transaction invalid after a certain point in time")])]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("h3",{attrs:{id:"sponsored-transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sponsored-transactions"}},[e._v("#")]),e._v(" Sponsored Transactions")]),e._v(" "),a("p",[e._v("With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account.  Some users don't want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets.  Unfortunately, since gas "),a("strong",[e._v("MUST")]),e._v(" be paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.")]),e._v(" "),a("p",[e._v("This EIP proposes a mechanism by which we can allow people to transact without ever having to own any ETH by allowing someone else to cover gas costs.  The arrangements that enable the covering of gas costs is out of scope for this EIP but it could be an extra-protocol monthly subscription, payment could occur as part of the transaction being submitted, the recpient may be willing to cover gas costs, or it could be a free service offered as a value-add by a company that you are working with.")]),e._v(" "),a("p",[e._v("While it is possible to implement these sort of mechanisms at the individual contract layer, such solutions require integration by just about every contract and those solutions also end up depending on gas costs being stable with time in order to appropriately bake them into contracts without putting either party at risk of malicious participants in the system.  For this reason, it is believed that separating out "),a("code",[e._v("GAS_PAYER")]),e._v(" from "),a("code",[e._v("msg.sender")]),e._v(" at the protocol layer is valuable.")]),e._v(" "),a("h3",{attrs:{id:"batch-transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#batch-transactions"}},[e._v("#")]),e._v(" Batch Transactions")]),e._v(" "),a("p",[e._v("Often times an EOA may want to execute a series of transactions with a strong guarantee that they happen in order with nothing occurring between them.  For example, one may want to send some tokens to a contract and then follow that up with another transaction that makes a contract call on the destination address that causes those tokens to be registered to them.  By supporting transaction batching at layer 1, we can ensure that the user can get strong guarantees at signing time of cross-transaction atomicity.")]),e._v(" "),a("h3",{attrs:{id:"expiring-transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expiring-transactions"}},[e._v("#")]),e._v(" Expiring Transactions")]),e._v(" "),a("ul",[a("li",[e._v("If any form of dust-account clearing is introduced, e.g. (https://github.com/ethereum/EIPs/issues/168), it will be necessary to introduce a replay protection, such as https://github.com/ethereum/EIPs/issues/169 . Having temporal replay protection removes the need to change nonce-behaviour in the state, since transactions would not be replayable at a later date than explicitly set by the user.")]),e._v(" "),a("li",[e._v("In many cases, such as during ICOs, a lot of people want their transactions to either become included soon (within a couple of hours) or not at all. Currently, transactions are queued and may not execute for several days, at a cost for both the user (who ends up paying gas for a failing purchase) and the network, dealing with the large transaction queues.")]),e._v(" "),a("li",[e._v("Node implementations have no commonly agreed metric for which transactions to keep, discard or propagate. Having a TTL on transactions would make it easier to remove stale transactions from the system.")])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("h3",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("TransactionType")])]),e._v(" 2.  See "),a("RouterLink",{attrs:{to:"/zh/eip-2718.html"}},[e._v("EIP-2718")])],1),e._v(" "),a("p",[a("strong",[a("code",[e._v("TransactionSubtype")])]),e._v(" is either 1, 2, 3, or 4.")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("ChainId")])]),e._v(" The transaction is valid if this value is "),a("code",[e._v("0")]),e._v(" or it is included in a block on a chain whose ID is equal to this value.")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("ValidUntil")])]),e._v(" The transaction is valid if this value is "),a("code",[e._v("0")]),e._v(" or it is included in a block whose "),a("code",[e._v("timestamp")]),e._v(" is less than or equal to this value.")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("YParity")])]),e._v(" The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("ChildTransaction")])]),e._v(" A nested transaction consisting of "),a("code",[e._v("[to, value, data]")]),e._v(".")]),e._v(" "),a("p",[a("strong",[a("code",[e._v("SenderPayload")])]),e._v(" Defined based on the "),a("code",[e._v("TransactionSubtype")]),e._v(" as follows:")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("[1, ChildTransaction[], nonce, ChainId, ValidUntil, gasLimit, gasPrice]")])]),e._v(" "),a("li",[a("code",[e._v("[2, ChildTransaction[], nonce, ChainId, ValidUntil, gasLimit, gasPrice]")])]),e._v(" "),a("li",[a("code",[e._v("[3, ChildTransaction[], nonce, ChainId, ValidUntil, gasLimit]")])]),e._v(" "),a("li",[a("code",[e._v("[4, ChildTransaction[], nonce, ChainId, ValidUntil]")])])]),e._v(" "),a("p",[a("strong",[a("code",[e._v("SenderSignature")])]),e._v(" "),a("code",[e._v("[YParity, r, s]")]),e._v(" of "),a("code",[e._v("secp256k1(keccak256(rlp([TransactionType, SenderPayload])))")])]),e._v(" "),a("p",[a("strong",[a("code",[e._v("GasPayerPayload")])]),e._v(" Defined based on the "),a("code",[e._v("TransactionSubtype")]),e._v(" as follows:")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("[]")])]),e._v(" "),a("li",[a("code",[e._v("[]")])]),e._v(" "),a("li",[a("code",[e._v("[gasPrice]")])]),e._v(" "),a("li",[a("code",[e._v("[gasLimit, gasPrice]")])])]),e._v(" "),a("p",[a("strong",[a("code",[e._v("GasPayerSignature")])]),e._v(" is "),a("code",[e._v("[]")]),e._v(" for "),a("code",[e._v("TransactionSubType")]),e._v(" "),a("code",[e._v("1")]),e._v(" or "),a("code",[e._v("[YParity, r, s]")]),e._v(" of "),a("code",[e._v("secp256k1(keccak256(rlp([SenderPayload, SenderSignature, GasPayerPayload])))")]),e._v(" for others.")]),e._v(" "),a("h3",{attrs:{id:"new-transaction-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-transaction-type"}},[e._v("#")]),e._v(" New Transaction Type")]),e._v(" "),a("p",[e._v("As of "),a("code",[e._v("FORK_BLOCK_NUMBER")]),e._v(" an "),a("RouterLink",{attrs:{to:"/zh/eip-2718.html"}},[e._v("EIP-2718")]),e._v(" transaction with a "),a("code",[e._v("TransactionType")]),e._v(" of "),a("code",[e._v("2")]),e._v(" will have its "),a("code",[e._v("Payload")]),e._v(" interpreted as an RLP encoded tuple of:")],1),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("[...SenderPayload, ...SenderSignature, ...GasPayerPayload, ...GasPayerSignature]\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("The address recovered from "),a("code",[e._v("SenderSignature")]),e._v(" is the address...")]),e._v(" "),a("ol",[a("li",[e._v("...returned by the "),a("code",[e._v("CALLER")]),e._v(" opcode (0x33, aka "),a("code",[e._v("msg.sender")]),e._v(") during the first call frame of the transaction")]),e._v(" "),a("li",[e._v("...returned by the "),a("code",[e._v("ORIGIN")]),e._v(" opcode (0x32, aka "),a("code",[e._v("tx.origin")]),e._v(")")]),e._v(" "),a("li",[e._v("...whose "),a("code",[e._v("nonce")]),e._v(" is used")]),e._v(" "),a("li",[e._v("...whose ETH balance is deducted if any value is attached to the transaction")]),e._v(" "),a("li",[e._v("...whose ETH balance is deducted to pay for gas if "),a("code",[e._v("GasPayerSignature")]),e._v(" is not present")])]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("GasPayerSignature")]),e._v(" is present, then the address recovered from it is the address...")]),e._v(" "),a("ol",[a("li",[e._v("...whose ETH balance is deducted to pay for gas")])]),e._v(" "),a("p",[e._v("The base gas cost of transactions of this type will be "),a("code",[e._v("TRANSACTION_TYPE_2_BASE_GAS_PRICE")]),e._v(" + "),a("code",[e._v("TRANSACTION_TYPE_2_CHILD_GAS_PRICE")]),e._v(" * "),a("code",[e._v("n")]),e._v(", rather than the cost associated with transactions of type "),a("code",[e._v("0")]),e._v(" and legacy transactions.")]),e._v(" "),a("h3",{attrs:{id:"new-transaction-receipt"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-transaction-receipt"}},[e._v("#")]),e._v(" New Transaction Receipt")]),e._v(" "),a("p",[e._v("As of "),a("code",[e._v("FORK_BLOCK_NUMBER")]),e._v(" an "),a("RouterLink",{attrs:{to:"/zh/eip-2718.html"}},[e._v("EIP-2718")]),e._v(" transaction receipt with a "),a("code",[e._v("TransactionType")]),e._v(" of "),a("code",[e._v("2")]),e._v(" will have its "),a("code",[e._v("Payload")]),e._v(" interpreted as a "),a("code",[e._v("rlp([status, cumulativeGasUsed, logsBloom, logs][])")]),e._v(" where each item of the array corresponds to the child-transaction at matching offset in the transaction type 2 "),a("code",[e._v("Payload")]),e._v(".")],1),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("h3",{attrs:{id:"one-monolithic-eip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#one-monolithic-eip"}},[e._v("#")]),e._v(" One Monolithic EIP")]),e._v(" "),a("p",[e._v("This EIP could be split up into multiple EIPs, one for each of the subtypes and one for the meta-type.  Alternatively, each of the subtypes could be a unique TransactionType.  The reason we chose to go with a single EIP with subtypes is because these 4 transactions all have a "),a("em",[e._v("lot")]),e._v(" in common and each separate EIP would be almost identical to the previous.  We felt that in this case, splitting into multiple EIPs wasn't worth the duplication of EIP content.")]),e._v(" "),a("h3",{attrs:{id:"chainid-not-encoded-with-v"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chainid-not-encoded-with-v"}},[e._v("#")]),e._v(" ChainID not encoded with "),a("code",[e._v("v")])]),e._v(" "),a("p",[e._v("While we could save one byte in the common case by bundling the y-parity bit of the signature with the Chain ID like in EIP-155, this adds complexity to signing tools that the authors deem not worth it given the size of the transaction overall.")]),e._v(" "),a("h3",{attrs:{id:"optionality-of-chainid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optionality-of-chainid"}},[e._v("#")]),e._v(" Optionality of ChainID")]),e._v(" "),a("p",[e._v("Sometimes it is useful to have a transaction that "),a("em",[e._v("can")]),e._v(" be replayed on multiple chains.  An example of this is when you construct a vanity signature for a transaction and have the "),a("code",[e._v("from")]),e._v(" be whatever address that signature recovers to.  With the ability to have someone else be a gas payer (setting both the gas limit and the gas price), one can have transactions that deploy contracts which live at the same address on every chain.  While this can be accomplished with CREATE2 using legacy transactions, we have the opportunity here to simplify the process and enable potentially other future uses of deterministic transactions by making ChainID optional.")]),e._v(" "),a("h3",{attrs:{id:"optionality-of-validuntil"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optionality-of-validuntil"}},[e._v("#")]),e._v(" Optionality of ValidUntil")]),e._v(" "),a("p",[e._v("A user can set "),a("code",[e._v("ValidUntil")]),e._v(" to a very large number which effectively makes it non-expiring.  By making "),a("code",[e._v("ValidUntil")]),e._v(" optional, we can save some bytes on the wire by allowing such transcations to simply have a "),a("code",[e._v("0")]),e._v(" (1 byte in RLP) value for this field.")]),e._v(" "),a("h3",{attrs:{id:"sender-sets-gaslimit-and-gasprice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sender-sets-gaslimit-and-gasprice"}},[e._v("#")]),e._v(" "),a("code",[e._v("SENDER")]),e._v(" sets "),a("code",[e._v("gasLimit")]),e._v(" and "),a("code",[e._v("gasPrice")])]),e._v(" "),a("p",[e._v("This type of transaction is useful when the transaction may execute differently depending on what these values are set to.  By having the "),a("code",[e._v("SENDER")]),e._v(" set both, we ensure that the "),a("code",[e._v("SENDER")]),e._v(" has full control over the transaction details.")]),e._v(" "),a("h3",{attrs:{id:"sender-sets-gaslimit-gas-payer-sets-gasprice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sender-sets-gaslimit-gas-payer-sets-gasprice"}},[e._v("#")]),e._v(" "),a("code",[e._v("SENDER")]),e._v(" sets "),a("code",[e._v("gasLimit")]),e._v(", "),a("code",[e._v("GAS_PAYER")]),e._v(" sets "),a("code",[e._v("gasPrice")])]),e._v(" "),a("p",[e._v("This type of transaction is useful when the transaction may execute differently depending on how much gas it is allowed (e.g., number of loops) but where the "),a("code",[e._v("SENDER")]),e._v(" would like to give the "),a("code",[e._v("GAS_PAYER")]),e._v(" the ability to price the transaction to maximize chances of inclusion.")]),e._v(" "),a("h3",{attrs:{id:"gas-payer-sets-gaslimit-and-gasprice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-payer-sets-gaslimit-and-gasprice"}},[e._v("#")]),e._v(" "),a("code",[e._v("GAS_PAYER")]),e._v(" sets "),a("code",[e._v("gasLimit")]),e._v(" and "),a("code",[e._v("gasPrice")])]),e._v(" "),a("p",[e._v("This type of transaction allows the "),a("code",[e._v("SENDER")]),e._v(" to define what they want to do, and leaves all worry about gas to the "),a("code",[e._v("GAS_PAYER")]),e._v(".  This is useful for transactions where the sender doesn't care how much gas is used or the price that is paid and also either trusts the "),a("code",[e._v("GAS_PAYER")]),e._v(" to be non-malicious or doesn't care if the "),a("code",[e._v("SENDER")]),e._v("'s nonce is increased.  Such situations are useful when you have extra-protocol trust between the "),a("code",[e._v("SENDER")]),e._v(" and "),a("code",[e._v("GAS_PAYER")]),e._v(" and you want to separate concerns (what to do vs how to get included) for security or complexity reasons.")]),e._v(" "),a("h3",{attrs:{id:"nonces"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nonces"}},[e._v("#")]),e._v(" Nonces")]),e._v(" "),a("p",[e._v("The inner transaction needs a nonce to protect themselves from replay attacks.  Since the inner transaction has a nonce, we get replay protection on the outer transaction as well, so it is not critical for security to have multiple parties provide a nonce.")]),e._v(" "),a("p",[e._v("We could have the "),a("code",[e._v("GAS_PAYER")]),e._v(" provide a second nonce, but this would increase the payload size and require "),a("code",[e._v("GAS_PAYER")]),e._v(" to do replace-by-fee (noisy for gossip) if they want to slip in a new (different inner) transaction with a higher gas price.  It would also create the possibility of a deadlock if the "),a("code",[e._v("SENDER")]),e._v(" nonces aren't ordered the same as the "),a("code",[e._v("GAS_PAYER")]),e._v(" nonces, and if the "),a("code",[e._v("SENDER")]),e._v(" nonce isn't the lowest valid nonce for the "),a("code",[e._v("SENDER")]),e._v(" then the "),a("code",[e._v("GAS_PAYER")]),e._v(" can't sign and submit yet.  Finally, client complexity increases slightly if a transaction has two nonces because you have to protect yourself from deadlocks and do more work to determine validity.")]),e._v(" "),a("h3",{attrs:{id:"validuntil"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validuntil"}},[e._v("#")]),e._v(" ValidUntil")]),e._v(" "),a("p",[e._v("For the dust-account clearing usecase,")]),e._v(" "),a("ul",[a("li",[e._v("This change is much less invasive in the consensus engine.\n"),a("ul",[a("li",[e._v("No need to maintain a consensus-field of 'highest-known-nonce' or cap the number of transactions from a sender in a block.")]),e._v(" "),a("li",[e._v("Only touches the transaction validation part of the consensus engine")]),e._v(" "),a("li",[e._v("Other schemas which uses the "),a("code",[e._v("nonce")]),e._v(" can have unintended side-effects,\n"),a("ul",[a("li",[e._v("such as inability to create contracts at certain addresses.")]),e._v(" "),a("li",[e._v("more difficult to integrate with offline signers, since more elaborate nonce-schemes requires state access to determine.")]),e._v(" "),a("li",[e._v("More intricate schemes like "),a("code",[e._v("highest-nonce")]),e._v(" are a lot more difficult, since highest-known-nonce will be a consensus-struct that is incremented and possibly reverted during transaction execution, requiring one more journalled field.")])])])])])]),e._v(" "),a("h3",{attrs:{id:"validuntil-as-timestamp-instead-of-block-number"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validuntil-as-timestamp-instead-of-block-number"}},[e._v("#")]),e._v(" ValidUntil as timestamp instead of block number")]),e._v(" "),a("ul",[a("li",[e._v("The unix time is generally available in most settings, even on a computer which is offline. This means that even a setup where blockchain information is unavailable, the party signing a transaction can generate a transaction with the desired properties.")]),e._v(" "),a("li",[e._v("The correlation between time and block number is not fixed; even though a 13s blocktime is 'desired', this varies due to both network hashrate and difficulty bomb progression.")]),e._v(" "),a("li",[e._v("The block number is even more unreliable as a timestamp for testnets and private networks.")]),e._v(" "),a("li",[e._v("unix time is more user-friendly, a user can more easily decide on reasonable end-date for a transaction, rather than a suitalbe number of valid blocks.")])]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("No known issues.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=i.exports}}]);