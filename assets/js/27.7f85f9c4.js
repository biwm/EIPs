(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{1183:function(e,t,a){"use strict";a.r(t);var s=a(46),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),s("p",[e._v("An account abstraction proposal which completely avoids the need for consensus-layer protocol changes. Instead of adding new protocol features and changing the bottom-layer transaction type, this proposal instead introduces a higher-layer pseudo-transaction object called a "),s("code",[e._v("UserOperation")]),e._v(". Users send "),s("code",[e._v("UserOperation")]),e._v(" objects into a separate mempool. A special class of actor called bundlers (either miners, or users that can send transactions to miners through a bundle marketplace) package up a set of these objects into a transaction making a "),s("code",[e._v("handleOps")]),e._v(" call to a special contract, and that transaction then gets included in a block.")]),e._v(" "),s("h2",{attrs:{id:"motivation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),s("p",[e._v("See also "),s("a",{attrs:{href:"https://ethereum-magicians.org/t/implementing-account-abstraction-as-part-of-eth1-x/4020",target:"_blank",rel:"noopener noreferrer"}},[e._v('"Implementing Account Abstraction as Part of Eth 1.x"'),s("OutboundLink")],1),e._v(" and the links therein for historical work and motivation, and "),s("RouterLink",{attrs:{to:"/zh/eip-2938.html"}},[e._v("EIP-2938")]),e._v(" for a consensus layer proposal for implementing the same goal.")],1),e._v(" "),s("p",[e._v("This proposal takes a different approach, avoiding any adjustments to the consensus layer. It seeks to achieve the following goals:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Achieve the key goal of account abstraction")]),e._v(": allow users to use smart contract wallets containing arbitrary verification logic instead of EOAs as their primary account. Completely remove any need at all for users to also have EOAs (as status quo SC wallets and EIP-3074 both require)")]),e._v(" "),s("li",[s("strong",[e._v("Decentralization")]),e._v(" "),s("ul",[s("li",[e._v("Allow any bundler (think: miner) to participate in the process of including account-abstracted user operations")]),e._v(" "),s("li",[e._v("Work with all activity happening over a public mempool; users do not need to know the direct communication addresses (eg. IP, onion) of any specific actors")]),e._v(" "),s("li",[e._v("Avoid trust assumptions on bundlers")])])]),e._v(" "),s("li",[s("strong",[e._v("Do not require any Ethereum consensus changes")]),e._v(": Ethereum consensus layer development is focusing on the merge and later on scalability-oriented features, and there may not be any opportunity for further protocol changes for a long time. Hence, to increase the chance of faster adoption, this proposal avoids Ethereum consensus changes.")]),e._v(" "),s("li",[s("strong",[e._v("Try to support other use cases")]),e._v(" "),s("ul",[s("li",[e._v("Privacy-preserving applications")]),e._v(" "),s("li",[e._v("Atomic multi-operations (similar goal to EIP-3074)")]),e._v(" "),s("li",[e._v("Pay tx fees with ERC-20 tokens, allow developers to pay fees for their users, and "),s("RouterLink",{attrs:{to:"/zh/eip-3074.html"}},[e._v("EIP-3074")]),e._v("-like "),s("strong",[e._v("sponsored transaction")]),e._v(" use cases more generally")],1)])])]),e._v(" "),s("h2",{attrs:{id:"specification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),s("p",[e._v("To avoid Ethereum consensus changes, we do not attempt to create new transaction types for account-abstracted transactions. Instead, users package up the action they want their wallet to take in an ABI-encoded struct called a "),s("code",[e._v("UserOperation")]),e._v(":")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Type")]),e._v(" "),s("th",[e._v("Description")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[s("code",[e._v("sender")])]),e._v(" "),s("td",[s("code",[e._v("Address")])]),e._v(" "),s("td",[e._v("The wallet making the operation")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("nonce")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("Anti-replay parameter; also used as the salt for first-time wallet creation")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("initCode")])]),e._v(" "),s("td",[s("code",[e._v("bytes")])]),e._v(" "),s("td",[e._v("The initCode of the wallet (only needed if the wallet is not yet on-chain and needs to be created)")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("callData")])]),e._v(" "),s("td",[s("code",[e._v("bytes")])]),e._v(" "),s("td",[e._v("The data to pass to the "),s("code",[e._v("sender")]),e._v(" during the main execution call")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("callGas")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("The amount of gas to allocate the main execution call")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("verificationGas")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("The amount of gas to allocate for the verification step")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("preVerificationGas")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("The amount of gas to pay for to compensate the bundler for for pre-verification execution and calldata")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("maxFeePerGas")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("Maximum fee per gas (similar to EIP 1559 "),s("code",[e._v("max_fee_per_gas")]),e._v(")")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("maxPriorityFeePerGas")])]),e._v(" "),s("td",[s("code",[e._v("uint256")])]),e._v(" "),s("td",[e._v("Maximum priority fee per gas (similar to EIP 1559 "),s("code",[e._v("max_priority_fee_per_gas")]),e._v(")")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("paymaster")])]),e._v(" "),s("td",[s("code",[e._v("address")])]),e._v(" "),s("td",[e._v("Address sponsoring the transaction (or zero for regular self-sponsored transactions)")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("paymasterData")])]),e._v(" "),s("td",[s("code",[e._v("bytes")])]),e._v(" "),s("td",[e._v("Extra data to send to the paymaster")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("signature")])]),e._v(" "),s("td",[s("code",[e._v("bytes")])]),e._v(" "),s("td",[e._v("Data passed into the wallet along with the nonce during the verification step")])])])]),e._v(" "),s("p",[e._v("Users send "),s("code",[e._v("UserOperation")]),e._v(" objects to a dedicated user operation mempool. A specialized class of actors called "),s("strong",[e._v("bundlers")]),e._v(" (either miners running special-purpose code, or users that can relay transactions to miners eg. through a bundle marketplace such as Flashbots that can guarantee next-block-or-never inclusion) listen in on the user operation mempool, and create "),s("strong",[e._v("bundle transactions")]),e._v(". A bundle transaction packages up multiple "),s("code",[e._v("UserOperation")]),e._v(" objects into a single "),s("code",[e._v("handleOps")]),e._v(" call to a pre-published global "),s("strong",[e._v("entry point contract")]),e._v(".")]),e._v(" "),s("p",[e._v("The core interface of the entry point contract is as follows:")]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function handleOps\n    (UserOperation[] calldata ops, address payable redeemer)\n    external;\n\nfunction simulateWalletValidation\n    (UserOperation calldata userOp)\n    external returns (uint gasUsedByPayForSelfOp);\n\nfunction simulatePaymasterValidation\n    (UserOperation calldata userOp, uint gasUsedByPayForSelfOp)\n    external view returns (bytes memory context, uint gasUsedByPayForOp);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("The core interface required for a wallet to have is:")]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function validateUserOp\n    (UserOperation calldata userOp, uint requiredPrefund)\n    external;\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("h3",{attrs:{id:"required-entry-point-contract-functionality"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#required-entry-point-contract-functionality"}},[e._v("#")]),e._v(" Required entry point contract functionality")]),e._v(" "),s("p",[e._v("The entry point's "),s("code",[e._v("handleOps")]),e._v(" function must perform the following steps (we first describe the simpler non-paymaster case). It must make two loops, the "),s("strong",[e._v("verification loop")]),e._v(" and the "),s("strong",[e._v("execution loop")]),e._v(". In the verification loop, the "),s("code",[e._v("handleOps")]),e._v(" call must perform the following steps for each "),s("code",[e._v("UserOperation")]),e._v(":")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Create the wallet if it does not yet exist")]),e._v(", using the initcode provided in the "),s("code",[e._v("UserOperation")]),e._v(" (if the wallet does not exist "),s("em",[e._v("and")]),e._v(" the initcode is empty, the call must fail)")]),e._v(" "),s("li",[s("strong",[e._v("Call "),s("code",[e._v("validateUserOp")]),e._v(" on the wallet")]),e._v(", passing in the "),s("code",[e._v("UserOperation")]),e._v(" and the required fee. The wallet should verify the operation's signature, and pay the fee if the wallet considers the operation valid. If any "),s("code",[e._v("validateUserOp")]),e._v(" call fails, "),s("code",[e._v("handleOps")]),e._v(" must skip execution of at least that operation, and may revert entirely.")])]),e._v(" "),s("p",[e._v("In the execution loop, the "),s("code",[e._v("handleOps")]),e._v(" call must perform the following steps for each "),s("code",[e._v("UserOperation")]),e._v(":")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Call the wallet with the "),s("code",[e._v("UserOperation")]),e._v("'s calldata")]),e._v(". It's up to the wallet to choose how to parse the calldata; an expected worlflow is for the wallet to have an "),s("code",[e._v("execute")]),e._v(" function that parses the remaining calldata as a series of one or more calls that the wallet should make.")]),e._v(" "),s("li",[s("strong",[e._v("Refund unused gas fees")]),e._v(" to the wallet")])]),e._v(" "),s("p",[s("img",{attrs:{src:a(364),alt:""}})]),e._v(" "),s("p",[e._v("Before accepting a "),s("code",[e._v("UserOperation")]),e._v(", bundlers must use an RPC method to locally simulate calling the "),s("code",[e._v("simulateWalletValidation")]),e._v(" function of the entry point, to verify that the signature is correct and the operation actually pays fees; see the "),s("a",{attrs:{href:"#simulation"}},[e._v("Simulation section below")]),e._v(" for details.")]),e._v(" "),s("h3",{attrs:{id:"extension-paymasters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#extension-paymasters"}},[e._v("#")]),e._v(" Extension: paymasters")]),e._v(" "),s("p",[e._v("We extend the entry point logic to support "),s("strong",[e._v("paymasters")]),e._v(" that can sponsor transactions for other users. This feature can be used to allow application developers to subsidize fees for their users, allow users to pay fees with ERC-20 tokens and many other use cases. When the paymaster is not equal to the zero address, the entry point implements a different flow:")]),e._v(" "),s("p",[s("img",{attrs:{src:a(365),alt:""}})]),e._v(" "),s("p",[e._v("During the verification loop, in addition to calling "),s("code",[e._v("validateUserOp")]),e._v(", the "),s("code",[e._v("handleOps")]),e._v(" execution also must check that the paymaster has enough ETH staked with the entry point to pay for the operation, and then call "),s("code",[e._v("validatePaymasterUserOp")]),e._v(" on the paymaster to verify that the paymaster is willing to pay for the operation. Additionally, the "),s("code",[e._v("validateUserOp")]),e._v(" must be called with a "),s("code",[e._v("requiredPrefund")]),e._v(" of 0 to reflect that it's the paymaster, and not the wallet, that's paying the fees.")]),e._v(" "),s("p",[e._v("During the execution loop, the "),s("code",[e._v("handleOps")]),e._v(" execution must call "),s("code",[e._v("postOp")]),e._v(" on the paymaster after making the main execution call. It must guarantee the execution of "),s("code",[e._v("postOp")]),e._v(", by making the main execution inside an inner call context, and if the inner call context reverts attempting to call "),s("code",[e._v("postOp")]),e._v(" again in an outer call context.")]),e._v(" "),s("p",[e._v("Maliciously crafted paymasters "),s("em",[e._v("can")]),e._v(" DoS the system. To prevent this, we use a paymaster reputation system; see the "),s("a",{attrs:{href:"#reputation-scoring-and-throttlingbanning-for-paymasters"}},[e._v("reputation, throttling and banning section")]),e._v(" for details.")]),e._v(" "),s("p",[e._v("The paymaster interface is as follows:")]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function validatePaymasterUserOp\n    (UserOperation calldata userOp, uint maxcost)\n    external view returns (bytes memory context);\n\nfunction postOp\n    (PostOpMode mode, bytes calldata context, uint actualGasCost)\n    external;\n\nenum PostOpMode {\n    opSucceeded, // user op succeeded\n    opReverted, // user op reverted. still has to pay for gas.\n    postOpReverted // user op succeeded, but caused postOp to revert\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("To prevent attacks involving malicious "),s("code",[e._v("UserOperation")]),e._v(" objects listing other users' wallets as their paymasters, the entry point contract must require a paymaster to call the entry point to lock their stake and thereby consent to being a paymaster. Unlocking stake must have a delay. The extended interface for the entry point, adding functions for paymasters to add and withdraw stake, is:")]),e._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function addStake() external payable\nfunction lockStake() external\nfunction unlockStake(address paymaster) external\nfunction withdrawStake(address payable withdrawAddress) external\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("h3",{attrs:{id:"client-behavior-upon-receiving-a-useroperation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#client-behavior-upon-receiving-a-useroperation"}},[e._v("#")]),e._v(" Client behavior upon receiving a UserOperation")]),e._v(" "),s("p",[e._v("When a client receives a "),s("code",[e._v("UserOperation")]),e._v(", it must first run some basic sanity checks, namely that:")]),e._v(" "),s("ul",[s("li",[e._v("Either the "),s("code",[e._v("sender")]),e._v(" is an existing contract, or the "),s("code",[e._v("initCode")]),e._v(" is not empty (but not both)")]),e._v(" "),s("li",[e._v("The "),s("code",[e._v("verificationGas")]),e._v(" is sufficiently low ("),s("code",[e._v("<= MAX_VERIFICATION_GAS")]),e._v(") and the "),s("code",[e._v("preVerificationGas")]),e._v(" is sufficiently high (enough to pay for the calldata gas cost of serializing the "),s("code",[e._v("UserOperation")]),e._v(" plus "),s("code",[e._v("PRE_VERIFICATION_OVERHEAD_GAS")]),e._v(")")]),e._v(" "),s("li",[e._v("The paymaster is either the zero address or is a contract which (i) currently has nonempty code on chain, (ii) has registered and has sufficient stake, and (iii) has not been banned")]),e._v(" "),s("li",[e._v("The callgas is at least the cost of a "),s("code",[e._v("CALL")]),e._v(" with non-zero value.")]),e._v(" "),s("li",[e._v("The "),s("code",[e._v("maxFeePerGas")]),e._v(" and "),s("code",[e._v("maxPriorityFeePerGas")]),e._v(" are above a configurable minimum value that the client is willing to accept")]),e._v(" "),s("li",[e._v("The "),s("code",[e._v("UserOperation")]),e._v(" object is not already present in the pool (or it replaces an existing entry with the same sender, nonce with a higher priority)")])]),e._v(" "),s("p",[e._v("If the "),s("code",[e._v("UserOperation")]),e._v(" object passes these sanity checks, the client must next simulate the op, and if the simulation succeeds, the client must add the op to the pool. Simulation must also happen during bundling to make sure that the storage accessed is the same as the "),s("code",[e._v("accessList")]),e._v(" that was saved during the initial simulation.")]),e._v(" "),s("h3",{attrs:{id:"simulation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#simulation"}},[e._v("#")]),e._v(" Simulation")]),e._v(" "),s("p",[e._v("To simulate a "),s("code",[e._v("UserOperation")]),e._v(" "),s("code",[e._v("op")]),e._v(", the client makes an "),s("code",[e._v("eth_call")]),e._v(" with the following params:")]),e._v(" "),s("div",{staticClass:"language-python line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"from"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x0000000000000000000000000000000000000000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"to"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("entry point address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"input"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("simulateWalletValidation header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" serialize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"gas"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("verificationGas"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("If the call returns an error, the client rejects the "),s("code",[e._v("op")]),e._v(". If it succeeds, the output is interpreted as an integer "),s("code",[e._v("gasUsedByPayForSelfOp")]),e._v(". If "),s("code",[e._v("op.paymaster != ZERO_ADDRESS")]),e._v(", the client must then make an "),s("code",[e._v("eth_call")]),e._v(" with the following params:")]),e._v(" "),s("div",{staticClass:"language-python line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"from"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0x0000000000000000000000000000000000000000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"to"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("entry point address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"input"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("simulatePaymasterValidation header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v("\n             abi_encode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("serialize"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" gasUsedByPayForSelfOp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"gas"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" op"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("verificationGas "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v(" gasUsedByPayForSelfOp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("While simulating, the client should make sure that:")]),e._v(" "),s("ol",[s("li",[e._v("Neither call's execution trace invokes any "),s("strong",[e._v("forbidden opcodes")])]),e._v(" "),s("li",[e._v("The first call does not access "),s("em",[e._v("mutable state")]),e._v(" of any contract except the wallet itself")]),e._v(" "),s("li",[e._v("The second call does not access "),s("em",[e._v("mutable state")]),e._v(" of any contract except the paymaster itself")])]),e._v(" "),s("p",[e._v("If a contract (i) does not contain the "),s("code",[e._v("SELFDESTRUCT")]),e._v(" or "),s("code",[e._v("DELEGATECALL")]),e._v(" opcode [except perhaps inside pushdata] and (ii) has nonempty code, "),s("em",[e._v("mutable state")]),e._v(" of that contract is defined as storage slots (accessed with SLOAD or SSTORE). If a contract does not satisfy either of the above conditions, mutable state of that contract includes code and storage. Note that balance can not be read in any case because of the forbidden opcode restriction. "),s("em",[e._v("Writing")]),e._v(" balance (via value-bearing calls) to any address is not restricted.")]),e._v(" "),s("p",[e._v("In practice, restrictions (2) and (3) basically mean that the only external accesses that the wallet and the paymaster can make are reading code of other contracts if their code is guaranteed to be immutable (eg. this is useful for calling or delegatecalling to libraries).")]),e._v(" "),s("p",[e._v("If any of the three conditions is violated, the client should reject the "),s("code",[e._v("op")]),e._v(". If both calls succeed (or, if "),s("code",[e._v("op.paymaster == ZERO_ADDRESS")]),e._v(" and the first call succeeds) without violating the three conditions, the client should accept the op. On a bundler node, the storage keys accessed by both calls must be saved as the "),s("code",[e._v("accessList")]),e._v(" of the "),s("code",[e._v("UserOperation")])]),e._v(" "),s("h4",{attrs:{id:"forbidden-opcodes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#forbidden-opcodes"}},[e._v("#")]),e._v(" Forbidden opcodes")]),e._v(" "),s("p",[e._v("The forbidden opcodes are to be forbidden when "),s("code",[e._v("depth > 2")]),e._v(" (i.e. when it is the wallet, paymaster, or other contracts called by them that are being executed). They are: "),s("code",[e._v("GASPRICE")]),e._v(", "),s("code",[e._v("GASLIMIT")]),e._v(", "),s("code",[e._v("DIFFICULTY")]),e._v(", "),s("code",[e._v("TIMESTAMP")]),e._v(", "),s("code",[e._v("BASEFEE")]),e._v(", "),s("code",[e._v("BLOCKHASH")]),e._v(", "),s("code",[e._v("NUMBER")]),e._v(", "),s("code",[e._v("SELFBALANCE")]),e._v(", "),s("code",[e._v("BALANCE")]),e._v(", "),s("code",[e._v("ORIGIN")]),e._v(", "),s("code",[e._v("GAS")]),e._v(". They should only be forbidden during verification, not execution. These opcodes are forbidden because their outputs may differ between simulation and execution, so simulation of calls using these opcodes does not reliably tell what would happen if these calls are later done on-chain.")]),e._v(" "),s("h3",{attrs:{id:"reputation-scoring-and-throttling-banning-for-paymasters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reputation-scoring-and-throttling-banning-for-paymasters"}},[e._v("#")]),e._v(" Reputation scoring and throttling/banning for paymasters")]),e._v(" "),s("p",[e._v("Clients maintain two mappings with a value for each paymaster:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("opsSeen: Map[Address, int]")])]),e._v(" "),s("li",[s("code",[e._v("opsIncluded: Map[Address, int]")])])]),e._v(" "),s("p",[e._v("When the client learns of a new "),s("code",[e._v("paymaster")]),e._v(", it sets "),s("code",[e._v("opsSeen[paymaster] = 0")]),e._v(" and "),s("code",[e._v("opsIncluded[paymaster] = 0")]),e._v(" .")]),e._v(" "),s("p",[e._v("The client sets "),s("code",[e._v("opsSeen[paymaster] +=1")]),e._v(" each time it adds an op with that "),s("code",[e._v("paymaster")]),e._v(" to the "),s("code",[e._v("UserOperationPool")]),e._v(", and the client sets "),s("code",[e._v("opsIncluded[paymaster] += 1")]),e._v(" each time an op that was in the "),s("code",[e._v("UserOperationPool")]),e._v(" is included on-chain.")]),e._v(" "),s("p",[e._v("Every hour, the client sets "),s("code",[e._v("opsSeen[paymaster] -= opsSeen[paymaster] // 24")]),e._v(" and "),s("code",[e._v("opsIncluded[paymaster] -= opsIncluded[paymaster] // 24")]),e._v(" for all paymasters (so both values are 24-hour exponential moving averages).")]),e._v(" "),s("p",[e._v("We define the "),s("strong",[e._v("status")]),e._v(" of a paymaster as follows:")]),e._v(" "),s("div",{staticClass:"language-python line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[e._v("OK"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" THROTTLED"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" BANNED "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("def")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("status")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("paymaster"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n           opsSeen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" Map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n           opsIncluded"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" Map"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" paymaster "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("not")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("in")]),e._v(" opsSeen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" OK\n    min_expected_included "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" opsSeen"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("paymaster"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("//")]),e._v(" MIN_INCLUSION_RATE_DENOMINATOR\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" min_expected_included "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" THROTTLING_SLACK "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">=")]),e._v(" opsIncluded"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("paymaster"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" OK\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("elif")]),e._v(" min_expected_included "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" BAN_SLACK "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">=")]),e._v(" opsIncluded"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("paymaster"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" THROTTLED\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" BANNED\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("p",[e._v("Stated in simpler terms, we expect at least "),s("code",[e._v("1 / MIN_INCLUSION_RATE_DENOMINATOR")]),e._v(" of all ops seen on the network to get included. If a paymaster falls too far behind this minimum, the paymaster gets "),s("strong",[e._v("throttled")]),e._v(" (meaning, the client does not accept ops from that paymaster if there is already an op from that paymaster, and an op only stays in the pool for 10 blocks), If the paymaster falls even further behind, it gets "),s("strong",[e._v("banned")]),e._v(". Throttling and banning naturally reverse over time because of the exponential-moving-average rule.")]),e._v(" "),s("p",[s("strong",[e._v("Non-bundling clients and bundlers should use different settings for the above params")]),e._v(":")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Param")]),e._v(" "),s("th",[e._v("Client setting")]),e._v(" "),s("th",[e._v("Bundler setting")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[s("code",[e._v("MIN_INCLUSION_RATE_DENOMINATOR")])]),e._v(" "),s("td",[e._v("100")]),e._v(" "),s("td",[e._v("10")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("THROTTLING_SLACK")])]),e._v(" "),s("td",[e._v("10")]),e._v(" "),s("td",[e._v("10")])]),e._v(" "),s("tr",[s("td",[s("code",[e._v("BAN_SLACK")])]),e._v(" "),s("td",[e._v("50")]),e._v(" "),s("td",[e._v("50")])])])]),e._v(" "),s("p",[e._v("To help make sense of these params, note that a malicious paymaster can at most cause the network (only the p2p network, not the blockchain) to process "),s("code",[e._v("BAN_SLACK * MIN_INCLUSION_RATE_DENOMINATOR / 24")]),e._v(" non-paying ops per hour.")]),e._v(" "),s("h3",{attrs:{id:"rpc-methods"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rpc-methods"}},[e._v("#")]),e._v(" RPC methods")]),e._v(" "),s("p",[s("code",[e._v("eth_sendUserOperation")])]),e._v(" "),s("div",{staticClass:"language-json= line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n  "jsonrpc": "2.0",\n  "id": 1,\n  "method": "eth_sendUserOperation",\n  "params": [\n    {\n      sender, // Address\n      nonce, // uint256\n      initCode, // bytes\n      callData, //bytes\n      callGas, // uint256\n      verificationGas, // uint256\n      maxFeePerGas, // uint256\n      maxPriorityFeePerGas, // uint256\n      paymaster, // address\n      paymasterData, // bytes\n      signature // bytes\n    }\n  ]\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br")])]),s("p",[s("code",[e._v("eth_callUserOperation")])]),e._v(" "),s("div",{staticClass:"language-json= line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n  "jsonrpc": "2.0",\n  "id": 1,\n  "method": "eth_callUserOperation",\n  "params": [\n    {\n      sender, // Address\n      nonce, // uint256\n      initCode, // bytes\n      callData, //bytes\n      callGas, // uint256\n      verificationGas, // uint256\n      maxFeePerGas, // uint256\n      maxPriorityFeePerGas, // uint256\n      paymaster, // address\n      paymasterData, // bytes\n      signature, // bytes\n      blockNumber, // hex-encoded uint256\n    }\n  ]\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br")])]),s("h2",{attrs:{id:"rationale"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),s("p",[e._v("The main challenge with a purely smart contract wallet based account abstraction system is DoS safety: how can a miner including an operation make sure that will actually pay fees, without having to first execute the entire operation? Requiring the miner to execute the entire operation opens a DoS attack vector, as an attacker could easily send many operations that pretend to pay a fee but then revert at the last moment after a long execution. Similarly, to prevent attackers from cheaply clogging the mempool, nodes in the P2P network need to check if a operation will pay a fee before they are willing to forward it.")]),e._v(" "),s("p",[e._v("In this proposal, we expect wallets to have a "),s("code",[e._v("validateUserOp")]),e._v(" method that takes as input a "),s("code",[e._v("UserOperation")]),e._v(", and verify the signature and pay the fee. This method is required to be almost-pure: it is only allowed to access the storage of the wallet itself, cannot use environment opcodes (eg. "),s("code",[e._v("TIMESTAMP")]),e._v("), and can only edit the storage of the wallet, and can also send out ETH (needed to pay the entry point). The method is gas-limited by the "),s("code",[e._v("verificationGas")]),e._v(" of the "),s("code",[e._v("UserOperation")]),e._v("; nodes can choose to reject operations whose "),s("code",[e._v("verificationGas")]),e._v(" is too high. These restrictions allow miners and network nodes to simulate the verification step locally, and be confident that the result will match the result when the operation actually gets included into a block.")]),e._v(" "),s("p",[e._v("The entry point-based approach allows for a clean separation between verification and execution, and keeps wallets' logic simple. The alternative would be to require wallets to follow a template where they first self-call to verify and then self-call to execute (so that the execution is sandboxed and cannot cause the fee payment to revert); template-based approaches were rejected due to being harder to implement, as existing code compilation and verification tooling is not designed around template verification.")]),e._v(" "),s("h3",{attrs:{id:"paymasters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#paymasters"}},[e._v("#")]),e._v(" Paymasters")]),e._v(" "),s("p",[e._v("Paymasters facilitate transaction sponsorship, allowing third-party-designed mechanisms to pay for transactions. Many of these mechanisms "),s("em",[e._v("could")]),e._v(" be done by having the paymaster wrap a "),s("code",[e._v("UserOperation")]),e._v(" with their own, but there are some important fundamental limitations to that approach:")]),e._v(" "),s("ul",[s("li",[e._v('No possibility for "passive" paymasters (eg. that accept fees in some ERC-20 token at an exchange rate pulled from an on-chain DEX)')]),e._v(" "),s("li",[e._v("Paymasters run the risk of getting griefed, as users could send ops that appear to pay the paymaster but then change their behavior after a block")])]),e._v(" "),s("p",[e._v("The paymaster scheme allows a contract to passively pay on users' behalf under arbitrary conditions. It even allows ERC-20 token paymasters to secure a guarantee that they would only need to pay if the user pays them: the paymaster contract can check that there is sufficient approved ERC-20 balance in the "),s("code",[e._v("validatePaymasterUserOp")]),e._v(" method, and then extract it with "),s("code",[e._v("transferFrom")]),e._v(" in the "),s("code",[e._v("postOp")]),e._v(" call; if the op itself transfers out or de-approves too much of the ERC-20s, the inner "),s("code",[e._v("postOp")]),e._v(" will fail and revert the execution and the outer "),s("code",[e._v("postOp")]),e._v(" can extract payment (note that because of storage access restrictions the ERC-20 would need to be a wrapper defined within the paymaster itself).")]),e._v(" "),s("h3",{attrs:{id:"first-time-wallet-creation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#first-time-wallet-creation"}},[e._v("#")]),e._v(" First-time wallet creation")]),e._v(" "),s("p",[e._v("It is an important design goal of this proposal to replicate the key property of EOAs that users do not need to perform some custom action or rely on an existing user to create their wallet; they can simply generate an address locally and immediately start accepting funds.")]),e._v(" "),s("p",[e._v("This is accomplished by having the entry point itself create wallets using CREATE2. The "),s("code",[e._v("UserOperation")]),e._v(" struct has an "),s("code",[e._v("initCode")]),e._v(" field; this field would be empty for all operations by a given wallet after the first, but the first operation would fill in the "),s("code",[e._v("initCode")]),e._v(". The entry point uses "),s("RouterLink",{attrs:{to:"/zh/eip-2470.html"}},[e._v("EIP-2470")]),e._v(" deployer contract to create the wallet, and then performs the operation. The user can compute the address of their wallet by locally running the "),s("RouterLink",{attrs:{to:"/zh/eip-1014.html"}},[e._v("EIP 1014")]),e._v(" CREATE2 address formula. The salt used is the "),s("code",[e._v("nonce")]),e._v(" of the "),s("code",[e._v("UserOperation")]),e._v(". (The entry point contract has a utility method "),s("code",[e._v("getSenderAddress()")]),e._v(" for that purpose)")],1),e._v(" "),s("h3",{attrs:{id:"entry-point-upgrading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#entry-point-upgrading"}},[e._v("#")]),e._v(" Entry point upgrading")]),e._v(" "),s("p",[e._v("Wallets are encouraged to be DELEGATECALL forwarding contracts for gas efficiency and to allow wallet upgradability. The wallet code is expected to hard-code the entry point into their code for gas efficiency. If a new entry point is introduced, whether to add new functionality, improve gas efficiency, or fix a critical security bug, users can self-call to replace their wallet's code address with a new code address containing code that points to a new entry point. During an upgrade process, it's expected that two mempools will run in parallel.")]),e._v(" "),s("h2",{attrs:{id:"backwards-compatibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),s("p",[e._v("This ERC does not change the consensus layer, so there are no backwards compatibility issues for Ethereum as a whole. Unfortunately it is not easily compatible with pre-ERC-4337 wallets, because those wallets do not have a "),s("code",[e._v("validateUserOp")]),e._v(" function. If the wallet has a function for authorizing a trusted op submitter, then this could be fixed by creating an ERC-4337-compatible wallet that re-implements the verification logic as a wrapper and setting it to be the original wallet's trusted op submitter.")]),e._v(" "),s("h2",{attrs:{id:"reference-implementation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation"}},[e._v("#")]),e._v(" Reference Implementation")]),e._v(" "),s("p",[e._v("See https://github.com/opengsn/account-abstraction/tree/main/contracts")]),e._v(" "),s("h2",{attrs:{id:"security-considerations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security considerations")]),e._v(" "),s("p",[e._v("The entry point contract will need to be very heavily audited and formally verified, because it will serve as a central trust point for "),s("em",[e._v("all")]),e._v(" ERC 4337 wallets. In total, this architecture reduces auditing and formal verification load for the ecosystem, because the amount of work that individual "),s("em",[e._v("wallets")]),e._v(" have to do becomes much smaller (they need only verify the "),s("code",[e._v("validateUserOp")]),e._v(' function and its "check signature, increment nonce and pay fees" logic) and check that other functions are '),s("code",[e._v("msg.sender == ENTRY_POINT")]),e._v(" gated (perhaps also allowing "),s("code",[e._v("msg.sender == self")]),e._v("), but it is nevertheless the case that this is done precisely by concentrating security risk in the entry point contract that needs to be verified to be very robust.")]),e._v(" "),s("p",[e._v("Verification would need to cover two primary claims (not including claims needed to protect paymasters, and claims needed to establish p2p-level DoS resistance):")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Safety against arbitrary hijacking")]),e._v(": The entry point only calls a wallet generically if "),s("code",[e._v("validateUserOp")]),e._v(" to that specific wallet has passed (and with "),s("code",[e._v("op.calldata")]),e._v(" equal to the generic call's calldata)")]),e._v(" "),s("li",[s("strong",[e._v("Safety against fee draining")]),e._v(": If the entry point calls "),s("code",[e._v("validateUserOp")]),e._v(" and passes, it also must make the generic call with calldata equal to "),s("code",[e._v("op.calldata")])])]),e._v(" "),s("h2",{attrs:{id:"copyright"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),s("p",[e._v("Copyright and related rights waived via "),s("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),s("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=n.exports},364:function(e,t,a){e.exports=a.p+"assets/img/image1.e192563a.png"},365:function(e,t,a){e.exports=a.p+"assets/img/image2.4ccac142.png"}}]);