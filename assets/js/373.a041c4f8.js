(window.webpackJsonp=window.webpackJsonp||[]).push([[373],{778:function(t,e,a){"use strict";a.r(e);var o=a(46),n=Object(o.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),a("p",[t._v("This EIP makes it possible to call functions that return strings and other dynamically-sized arrays.\nCurrently, when another contract / function is called from inside the Ethereum Virtual Machine,\nthe size of the output has to be specified in advance. It is of course possible to give a larger\nsize, but gas also has to be paid for memory that is not written to, which makes returning\ndynamically-sized data both costly and inflexible to the extent that it is actually unusable.")]),t._v(" "),a("p",[t._v("The solution proposed in this EIP is to charge gas only for memory that is actually written to at\nthe time the "),a("code",[t._v("CALL")]),t._v(" returns.")]),t._v(" "),a("h3",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),a("p",[t._v("The gas and memory semantics for "),a("code",[t._v("CALL")]),t._v(", "),a("code",[t._v("CALLCODE")]),t._v(" and "),a("code",[t._v("DELEGATECALL")]),t._v(" (called later as "),a("code",[t._v("CALL*")]),t._v(")\nare changed in the following way ("),a("code",[t._v("CREATE")]),t._v(" does not write to memory and is thus unaffected):")]),t._v(" "),a("p",[t._v("Suppose the arguments to "),a("code",[t._v("CALL*")]),t._v(" are "),a("code",[t._v("gas, address, value, input_start, input_size, output_start, output_size")]),t._v(",\nthen, at the beginning of the opcode, gas for growing memory is only charged for "),a("code",[t._v("input_start + input_size")]),t._v(", but not\nfor "),a("code",[t._v("output_start + output_size")]),t._v(".")]),t._v(" "),a("p",[t._v("If the called contract returns data of size "),a("code",[t._v("n")]),t._v(", the memory of the calling contract is grown to\n"),a("code",[t._v("output_start + min(output_size, n)")]),t._v(" (and the calling contract is charged gas for that) and the\noutput is written to the area "),a("code",[t._v("[output_start, output_start + min(n, output_size))")]),t._v(".")]),t._v(" "),a("p",[t._v("The calling contract can run out of gas both at the beginning of the opcode and at the end\nof the opcode.")]),t._v(" "),a("p",[t._v("After the call, the "),a("code",[t._v("MSIZE")]),t._v(" opcode should return the size the memory was actually grown to.")]),t._v(" "),a("h3",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),a("p",[t._v("In general, it is good practise to reserve a certain memory area for the output of a call,\nbecause letting a subroutine write to arbitrary areas in memory might be dangerous. On the\nother hand, it is often hard to know the output size of a call prior to performing the call:\nThe data could be in the storage of another contract which is generally inaccessible and\ndetermining its size would require another call to that contract.")]),t._v(" "),a("p",[t._v("Furthermore, charging gas for areas of memory that are not actually written to is unnecessary.")]),t._v(" "),a("p",[t._v('This proposal tries to solve both problems: A caller can choose to provide a gigantic area of\nmemory at the end of their memory area. The callee can "write" to it by returning and the\ncaller is only charged for the memory area that is actually written.')]),t._v(" "),a("p",[t._v("This makes it possible to return dynamic data like strings and dynamically-sized arrays\nin a very flexible way. It is even possible to determine the size of the returned data:\nIf the caller uses "),a("code",[t._v("output_start = MSIZE")]),t._v(" and "),a("code",[t._v("output_size = 2**256-1")]),t._v(", the area of\nmemory that was actually written to is "),a("code",[t._v("(output_start, MSIZE)")]),t._v(" (here, "),a("code",[t._v("MSIZE")]),t._v(' as evaluated\nafter the call). This is important because it allows "proxy" contracts\nwhich call other contracts whose interface they do not know and just return their output,\ni.e. they both forward the input and the output. For this, it is important that the caller\n(1) does not need to know the size of the output in advance and (2) can determine the\nsize of the output after the call.')]),t._v(" "),a("h3",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),a("p",[t._v("This way of dealing with the problem requires a minimal change to the Ethereum Virtual Machine.\nOther means of achieving a similar goal would have changed the opcodes themselves or\nthe number of their arguments. Another possibility would have been to only change the\ngas mechanics if "),a("code",[t._v("output_size")]),t._v(" is equal to "),a("code",[t._v("2**256-1")]),t._v(". Since the main difficulty in the\nimplementation is that memory has to be enlarged at two points in the code around "),a("code",[t._v("CALL")]),t._v(",\nthis would not have been a simplification.")]),t._v(" "),a("p",[t._v("At an earlier stage, it was proposed to also add the size of the returned data on the stack,\nbut the "),a("code",[t._v("MSIZE")]),t._v(" mechanism described above should be sufficient and is much better\nbackwards compatible.")]),t._v(" "),a("p",[t._v("Some comments are available at https://github.com/ethereum/EIPs/issues/8")]),t._v(" "),a("h3",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[t._v("#")]),t._v(" Backwards Compatibility")]),t._v(" "),a("p",[t._v("This proposal changes the semantics of contracts because contracts can access the gas counter\nand the size of memory.")]),t._v(" "),a("p",[t._v("On the other hand, it is unlikely that existing contracts will suffer from this change due to\nthe following reasons:")]),t._v(" "),a("p",[t._v("Gas:")]),t._v(" "),a("p",[t._v("The VM will not charge more gas than before. Usually, contracts are written in a way such\nthat their semantics do not change if they use up less gas. If more gas were used, contracts\nmight go out-of-gas if they perform a tight estimation for gas needed by sub-calls. Here,\ncontracts might only return more gas to their callers.")]),t._v(" "),a("p",[t._v("Memory size:")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("MSIZE")]),t._v(" opcode is typically used to allocate memory at a previously unused spot.\nThe change in semantics affects existing contracts in two ways:")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("Overlaps in allocated memory. By using "),a("code",[t._v("CALL")]),t._v(", a contract might have wanted to allocate\na certain slice of memory, even if that is not written to by the called contract.\nSubsequent uses of "),a("code",[t._v("MSIZE")]),t._v(" to allocate memory might overlap with this slice that is\nnow smaller than before the change. It is though unlikely that such contracts exist.")])]),t._v(" "),a("li",[a("p",[t._v("Memory addresses change. Rather general, if memory is allocated using "),a("code",[t._v("MSIZE")]),t._v(", the\naddresses of objects in memory will be different after the change. Contract should\nall be written in a way, though, such that objects in memory are "),a("em",[t._v("relocatable")]),t._v(",\ni.e. their absolute position in memory and their relative position to other\nobjects does not matter. This is of course not the case for arrays, but they\nare allocated in a single allocation and not with an intermediate "),a("code",[t._v("CALL")]),t._v(".")])])]),t._v(" "),a("h3",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[t._v("#")]),t._v(" Implementation")]),t._v(" "),a("p",[t._v('VM implementers should take care not to grow the memory until the end of the call and after a check that sufficient\ngas is still available. Typical uses of the EIP include "reserving" '),a("code",[t._v("2**256-1")]),t._v(" bytes of memory for the output.")]),t._v(" "),a("p",[t._v("Python implementation:")]),t._v(" "),a("p",[t._v("old: http://vitalik.ca/files/old.py\nnew: http://vitalik.ca/files/new.py")])])}),[],!1,null,null,null);e.default=n.exports}}]);