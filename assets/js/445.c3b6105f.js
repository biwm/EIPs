(window.webpackJsonp=window.webpackJsonp||[]).push([[445],{852:function(e,t,a){"use strict";a.r(t);var o=a(46),i=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP adds overflow checking for EVM arithmetic operations, and two new opcodes that check and clear the overflow flags.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("The correct functioning of many contracts today is dependent on detecting and preventing overflow of arithmetic operations. Since the EVM operates on mod 2^256 integers and provides no built-in overflow detection or prevention, this requires manual checks on every arithmetic operation.")]),e._v(" "),a("p",[e._v("In the interests of facilitating efficient and secure contracts, we propose new opcodes that permit efficient detection of overflows, which can be checked periodically rather than after each operation.")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Two new flags are added to the EVM state: overflow ("),a("code",[e._v("ovf")]),e._v(") and signed overflow ("),a("code",[e._v("sovf")]),e._v(").")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("ovf")]),e._v(" flag is set in the following circumstances:")]),e._v(" "),a("ul",[a("li",[e._v("When an "),a("code",[e._v("ADD")]),e._v(" ("),a("code",[e._v("0x01")]),e._v(") opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1.")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("SUB")]),e._v(" ("),a("code",[e._v("0x03")]),e._v(") opcode, with both inputs treated as unsigned integers, produces an ideal output less than 0.")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("MUL")]),e._v("("),a("code",[e._v("0x02")]),e._v(") opcode, with both inputs treated as unsigned integers, produces an ideal output in excess of 2^256 - 1.")])]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("sovf")]),e._v(" flag is set whenever the "),a("code",[e._v("ovf")]),e._v(" flag is set, and additionally in the following circumstances:")]),e._v(" "),a("ul",[a("li",[e._v("When an "),a("code",[e._v("ADD")]),e._v(" opcode with both inputs having the same MSB results in the output having a different MSB (eg, "),a("code",[e._v("(+a) + (+b) = (-c)")]),e._v(" or "),a("code",[e._v("(-a) + (-b) = (+c)")]),e._v(").")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("SUB")]),e._v(" opcode occurs and the result has the same MSB as the subtractand (second argument) (eg, "),a("code",[e._v("(+a) - (-b) = (-c)")]),e._v(" or "),a("code",[e._v("(-a) - (+b) = (+c)")]),e._v(".")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("MUL")]),e._v(" opcode with both inputs being positive has a negative output.")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("MUL")]),e._v(" opcode with both inputs being negative has a negative output.")]),e._v(" "),a("li",[e._v("When a "),a("code",[e._v("MUL")]),e._v(" opcode with one negative input and one positive input has a positive output.")])]),e._v(" "),a("p",[e._v("A new opcode, "),a("code",[e._v("OFV")]),e._v(" is added, with number "),a("code",[e._v("0x0c")]),e._v(". This opcode takes 0 arguments from the stack. When executed, it pushes "),a("code",[e._v("1")]),e._v(" if the "),a("code",[e._v("ovf")]),e._v(" flag is set, and "),a("code",[e._v("0")]),e._v(" otherwise. It then sets the "),a("code",[e._v("ovf")]),e._v(" flag to false.")]),e._v(" "),a("p",[e._v("A new opcode, "),a("code",[e._v("SOVF")]),e._v(" is added, with number "),a("code",[e._v("0x0d")]),e._v(". This opcode takes 0 arguments from the stack. When executed, it pushes "),a("code",[e._v("1")]),e._v(" if the "),a("code",[e._v("sovf")]),e._v(" flag is set, and "),a("code",[e._v("0")]),e._v(" otherwise. It then sets the "),a("code",[e._v("sovf")]),e._v(" flag to false.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Any change to implement overflow protection needs to preserve behaviour of existing contracts, which precludes many changes to the arithmetic operations themselves. One option would be to provide an opcode that enables overflow protection, causing a throw or revert if an overflow happens. However, this limits the manner in which overflows can be handled.")]),e._v(" "),a("p",[e._v("Instead, we replicate functionality from real world CPUs, which typically implement 'carry' and 'overflow' flags.")]),e._v(" "),a("p",[e._v("Separate flags for signed and unsigned overflow are necessary due to the fact that a signed overflow may not result in an unsigned overflow.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("This EIP introduces no backwards compatibility issues.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("TBD")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("TBD")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=i.exports}}]);