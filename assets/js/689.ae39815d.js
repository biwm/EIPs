(window.webpackJsonp=window.webpackJsonp||[]).push([[689],{1111:function(e,t,a){"use strict";a.r(t);var i=a(46),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("This precompile adds operations for the BW6-761 curve (from the EY/Inria "),a("a",{attrs:{href:"https://eprint.iacr.org/2020/351.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("research paper"),a("OutboundLink")],1),e._v(") as a precompile in a set necessary to "),a("em",[e._v("efficiently")]),e._v(" perform verification of one-layer composed zkSNARKs proofs.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("If "),a("code",[e._v("block.number >= X")]),e._v(" we introduce "),a("em",[e._v("seven")]),e._v(" separate precompiles to perform the following operations (addresses to be determined):")]),e._v(" "),a("ul",[a("li",[e._v("BW6_G1_ADD - to perform point addition on a curve defined over a prime field")]),e._v(" "),a("li",[e._v("BW6_G1_MUL - to perform point multiplication on a curve defined over a prime field")]),e._v(" "),a("li",[e._v("BW6_G1_MULTIEXP - to perform multiexponentiation on a curve defined over a prime field")]),e._v(" "),a("li",[e._v("BW6_G2_ADD - to perform point addition on a curve twist defined the base a prime field")]),e._v(" "),a("li",[e._v("BW6_G2_MUL - to perform point multiplication on a curve twist defined over a prime field")]),e._v(" "),a("li",[e._v("BW6_G2_MULTIEXP - to perform multiexponentiation on a curve twist defined over a prime field")]),e._v(" "),a("li",[e._v("BW6_PAIRING - to perform a pairing operations between a set of "),a("em",[e._v("pairs")]),e._v(" of (G1, G2) points")])]),e._v(" "),a("p",[e._v("The multiexponentiation operations are a generalization of point multiplication, but separate precompiles are prosposed because running a single MUL through MULTIEXP seems to be 20% more expensive.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("This EIP is based on and tends to replace "),a("a",{attrs:{href:"https://github.com/matter-labs/EIPs/blob/sw6_wrapping/EIPS/eip-2541.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP-2541"),a("OutboundLink")],1),e._v(" for significant performance reasons. In most applications, BW6-761 is used as an outer curve to BLS12-377 considered in "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/pull/2539",target:"_blank",rel:"noopener noreferrer"}},[e._v("EIP-2539"),a("OutboundLink")],1),e._v(". The motivation of this precompile is to allow efficient one-layer composition of SNARK proofs. Currently this is done by Zexe using the BLS12-377/CP6-782 pair of curves. This precompile proposes a replacement of CP6-782 by BW6-761, which allows much faster operations. For example, it was shown that verifying a Groth16 proof with BW6-761 is 30 times faster than with CP6-782.")]),e._v(" "),a("h3",{attrs:{id:"proposed-addresses-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposed-addresses-table"}},[e._v("#")]),e._v(" Proposed addresses table")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Precompile")]),e._v(" "),a("th",[e._v("Address")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("BW6_G1_ADD")]),e._v(" "),a("td",[e._v("0x13")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_G1_MUL")]),e._v(" "),a("td",[e._v("0x14")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_G1_MULTIEXP")]),e._v(" "),a("td",[e._v("0x15")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_G2_ADD")]),e._v(" "),a("td",[e._v("0x16")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_G2_MUL")]),e._v(" "),a("td",[e._v("0x17")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_G2_MULTIEXP")]),e._v(" "),a("td",[e._v("0x18")])]),e._v(" "),a("tr",[a("td",[e._v("BW6_PAIRING")]),e._v(" "),a("td",[e._v("0x19")])])])]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Curve parameters:")]),e._v(" "),a("p",[e._v("The BW6-761 "),a("code",[e._v("y^2=x^3-1")]),e._v(" curve is fully defined by the following set of parameters:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Base field modulus = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008b\nA coefficient = 0x0\nB coefficient = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d00000000008a\nMain subgroup order = 0x1ae3a4617c510eac63b05c06ca1493b1a22d9f300f5138f1ef3622fba094800170b5d44300000008508c00000000001\nExtension tower:\nFp3 construction: (Fp3 = Fp[u]/u^3+4)\nFp cubic non-residue = 0x122e824fb83ce0ad187c94004faff3eb926186a81d14688528275ef8087be41707ba638e584e91903cebaff25b423048689c8ed12f9fd9071dcd3dc73ebff2e98a116c25667a8f8160cf8aeeaf0a437e6913e6870000082f49d000000000087\nTwist parameters:\nTwist type: M\ntwist curve A coefficient c0 = 0x0\n                          c1 = 0x0\ntwist curve B coefficient c0 = 0x4\n                        c1 = 0x0\nGenerators:\nG1:\nX = 0x1075b020ea190c8b277ce98a477beaee6a0cfb7551b27f0ee05c54b85f56fc779017ffac15520ac11dbfcd294c2e746a17a54ce47729b905bd71fa0c9ea097103758f9a280ca27f6750dd0356133e82055928aca6af603f4088f3af66e5b43d\nY = 0x58b84e0a6fc574e6fd637b45cc2a420f952589884c9ec61a7348d2a2e573a3265909f1af7e0dbac5b8fa1771b5b806cc685d31717a4c55be3fb90b6fc2cdd49f9df141b3053253b2b08119cad0fb93ad1cb2be0b20d2a1bafc8f2db4e95363\nG2:\nX = 0x110133241d9b816c852a82e69d660f9d61053aac5a7115f4c06201013890f6d26b41c5dab3da268734ec3f1f09feb58c5bbcae9ac70e7c7963317a300e1b6bace6948cb3cd208d700e96efbc2ad54b06410cf4fe1bf995ba830c194cd025f1c\nY = 0x17c3357761369f8179eb10e4b6d2dc26b7cf9acec2181c81a78e2753ffe3160a1d86c80b95a59c94c97eb733293fef64f293dbd2c712b88906c170ffa823003ea96fcd504affc758aa2d3a3c5a02a591ec0594f9eac689eb70a16728c73b61\nPairing parameters:\ne(P,Q)=(ML1(P,Q)*ML2(P,Q)^q)^FE\n|loop_count_1| (first miller loop ML1 count) = 0x8508c00000000002\n|loop_count_2| (second miller loop ML2 count) = 0x23ed1347970dec008a442f991fffffffffffffffffffffff\nloop_count_1 is negative = false\nloop_count_2 is negative = false\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br")])]),a("h4",{attrs:{id:"encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding"}},[e._v("#")]),e._v(" Encoding")]),e._v(" "),a("h5",{attrs:{id:"field-elements-encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#field-elements-encoding"}},[e._v("#")]),e._v(" Field elements encoding:")]),e._v(" "),a("p",[e._v("To encode points involved in the operation one has to encode elements of only the base field.")]),e._v(" "),a("p",[e._v("The base field element (Fp) is encoded as "),a("code",[e._v("96")]),e._v(" bytes by performing BigEndian encoding of the corresponding (unsigned) integer. The corresponding integer "),a("strong",[e._v("MUST")]),e._v(" be less than the base field modulus.")]),e._v(" "),a("p",[e._v("If encodings do not follow this spec anywhere during parsing in the precompile, the precompile "),a("strong",[e._v("MUST")]),e._v(' revert with "endoding error".')]),e._v(" "),a("h5",{attrs:{id:"encoding-of-uncompressed-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding-of-uncompressed-points"}},[e._v("#")]),e._v(" Encoding of uncompressed points:")]),e._v(" "),a("p",[e._v("Points in both G1 and G2 can be expressed as "),a("code",[e._v("(x, y)")]),e._v(" affine coordinates, where "),a("code",[e._v("x")]),e._v(" and "),a("code",[e._v("y")]),e._v(" are elements of the base field. Therefore, points in both G1 and G2 are encoded as the byte concatenation of the field element encodings of the "),a("code",[e._v("x")]),e._v(" and "),a("code",[e._v("y")]),e._v(" affine coordinates. The total encoding length for a G1/G2 point is thus "),a("code",[e._v("192")]),e._v(" bytes.")]),e._v(" "),a("h5",{attrs:{id:"point-at-infinity-encoding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#point-at-infinity-encoding"}},[e._v("#")]),e._v(" Point at infinity encoding:")]),e._v(" "),a("p",[e._v('Also referred as the "zero point". For BW6-761 ('),a("code",[e._v("y^2=x^3-1")]),e._v(") and its M-twisted curves ("),a("code",[e._v("y^3=x^3+4")]),e._v("), the point with coordinates "),a("code",[e._v("(0, 0)")]),e._v(" (formal zeros in Fp) is "),a("em",[e._v("not")]),e._v(" on the curve, and so the encoding of "),a("code",[e._v("(0, 0)")]),e._v(" is used as a convention to encode the point at infinity.")]),e._v(" "),a("h5",{attrs:{id:"encoding-of-scalars-for-multiplication-and-multiexponentiation-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encoding-of-scalars-for-multiplication-and-multiexponentiation-operations"}},[e._v("#")]),e._v(" Encoding of scalars for multiplication and multiexponentiation operations:")]),e._v(" "),a("p",[e._v("For multiplication and multiexponentiation operations, a scalar is encoded as "),a("code",[e._v("64")]),e._v(" bytes by performing BigEndian encoding of the corresponding (unsigned) integer.")]),e._v(" "),a("p",[e._v("Note that the main subgroup order for BW6-761 is actually only "),a("code",[e._v("377")]),e._v(" bits ("),a("code",[e._v("48")]),e._v(" bytes), but an encoding of "),a("code",[e._v("64")]),e._v(" bytes has been chosen to have a "),a("code",[e._v("32")]),e._v("-byte-aligned ABI (representable as e.g. "),a("code",[e._v("bytes32[2]")]),e._v(" or "),a("code",[e._v("uint256[2]")]),e._v(").")]),e._v(" "),a("p",[e._v("The corresponding integer "),a("strong",[e._v("MAY")]),e._v(" be greater than the main subgroup order.")]),e._v(" "),a("h4",{attrs:{id:"abi-for-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-operations"}},[e._v("#")]),e._v(" ABI for operations")]),e._v(" "),a("h5",{attrs:{id:"abi-for-g1-addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g1-addition"}},[e._v("#")]),e._v(" ABI for G1 addition")]),e._v(" "),a("p",[e._v("G1 addition call expects "),a("code",[e._v("384")]),e._v(" bytes as an input that is interpreted as the byte concatenation of two G1 points (point-encoded as "),a("code",[e._v("192")]),e._v(" bytes each). Output is a point-encoding of the addition operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Either of the points being not on the curve")]),e._v(" "),a("li",[e._v("Input has invalid length")]),e._v(" "),a("li",[e._v("Field element encoding rules apply (obviously)")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-g1-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g1-multiplication"}},[e._v("#")]),e._v(" ABI for G1 multiplication")]),e._v(" "),a("p",[e._v("G1 multiplication call expects "),a("code",[e._v("256")]),e._v(" bytes as an input that is interpreted as the byte concatenation of the point-encoding of a G1 point ("),a("code",[e._v("192")]),e._v(" bytes) and the encoding of a scalar value ("),a("code",[e._v("64")]),e._v(" bytes). Output is a point-encoding of the multiplication operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Point being not on the curve")]),e._v(" "),a("li",[e._v("Input has invalid length")]),e._v(" "),a("li",[e._v("Field element encoding rules apply (obviously)")]),e._v(" "),a("li",[e._v("Scalar encoding rules apply (obviously)")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-g1-multiexponentiation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g1-multiexponentiation"}},[e._v("#")]),e._v(" ABI for G1 multiexponentiation")]),e._v(" "),a("p",[e._v("G1 multiplication call expects "),a("code",[e._v("256*k")]),e._v(" bytes as an input that is interpreted as the byte concatenation of "),a("code",[e._v("k")]),e._v(" slices, each of them being a byte concatenation of the point-encoding of a G1 point ("),a("code",[e._v("192")]),e._v(" bytes) and the encoding of a scalar value ("),a("code",[e._v("64")]),e._v(" bytes). Output is an encoding of the multiexponentiation operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Any of the G1 points being not on the curve")]),e._v(" "),a("li",[e._v("Input has invalid length")]),e._v(" "),a("li",[e._v("Field element encoding rules apply (obviously)")]),e._v(" "),a("li",[e._v("Scalar encoding rules apply (obviously)")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-g2-addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g2-addition"}},[e._v("#")]),e._v(" ABI for G2 addition")]),e._v(" "),a("p",[e._v("G2 addition call expects "),a("code",[e._v("384")]),e._v(" bytes as an input that is interpreted as the byte concatenation of two G2 points (point-encoded as "),a("code",[e._v("192")]),e._v(" bytes each). Output is a point-encoding of the addition operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Either of points being not on the curve")]),e._v(" "),a("li",[e._v("Input has invalid length")]),e._v(" "),a("li",[e._v("Field elements encoding rules apply (obviously)")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-g2-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g2-multiplication"}},[e._v("#")]),e._v(" ABI for G2 multiplication")]),e._v(" "),a("p",[e._v("G2 multiplication call expects "),a("code",[e._v("256")]),e._v(" bytes as an input that is interpreted as the byte concatenation of the point-encoding of a G2 point ("),a("code",[e._v("192")]),e._v(" bytes) and the encoding of a scalar value ("),a("code",[e._v("64")]),e._v(" bytes). Output is an encoding of multiplication operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Point being not on the curve must result in error")]),e._v(" "),a("li",[e._v("Field elements encoding rules apply (obviously)")]),e._v(" "),a("li",[e._v("Input has invalid length")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-g2-multiexponentiation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-g2-multiexponentiation"}},[e._v("#")]),e._v(" ABI for G2 multiexponentiation")]),e._v(" "),a("p",[e._v("G2 multiplication call expects "),a("code",[e._v("240*k")]),e._v(" bytes as an input that is interpreted as byte concatenation of "),a("code",[e._v("k")]),e._v(" slices each of them being a byte concatenation of encoding of G2 point ("),a("code",[e._v("192")]),e._v(" bytes) and encoding of a scalar value ("),a("code",[e._v("48")]),e._v(" bytes). Output is an encoding of multiexponentiation operation result.")]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Any of G2 points being not on the curve must result in error")]),e._v(" "),a("li",[e._v("Field elements encoding rules apply (obviously)")]),e._v(" "),a("li",[e._v("Input has invalid length")])]),e._v(" "),a("h5",{attrs:{id:"abi-for-pairing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abi-for-pairing"}},[e._v("#")]),e._v(" ABI for pairing")]),e._v(" "),a("p",[e._v("Pairing call expects "),a("code",[e._v("384*k")]),e._v(" bytes as an input, that is interpreted as the byte concatenation of "),a("code",[e._v("k")]),e._v(" slices. Each slice has the following structure:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("192")]),e._v(" bytes G1 point encoding")]),e._v(" "),a("li",[a("code",[e._v("192")]),e._v(" bytes G2 point encoding")])]),e._v(" "),a("p",[e._v("Output is "),a("code",[e._v("32")]),e._v(" bytes representing a boolean:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("0x0000000000000000000000000000000000000000000000000000000000000001")]),e._v(" if the pairing result is equal the to multiplicative identity in the pairing target field; and")]),e._v(" "),a("li",[a("code",[e._v("0x0000000000000000000000000000000000000000000000000000000000000000")]),e._v(" otherwise.")])]),e._v(" "),a("p",[e._v("Error cases:")]),e._v(" "),a("ul",[a("li",[e._v("Any of the G1 or G2 points being not on the curve")]),e._v(" "),a("li",[e._v("Any of the G1 or G2 points being not in the correct subgroup")]),e._v(" "),a("li",[e._v("Input has invalid length")]),e._v(" "),a("li",[e._v("Field elements encoding rules apply (obviously)")])]),e._v(" "),a("h4",{attrs:{id:"prevention-of-ddos-on-error-handling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prevention-of-ddos-on-error-handling"}},[e._v("#")]),e._v(" Prevention of DDoS on error handling")]),e._v(" "),a("p",[e._v("This precompile performs extensive computations and in case of any errors during execution it "),a("strong",[e._v("MUST")]),e._v(" consume all gas from the the gas schedule for the corresponding operation.")]),e._v(" "),a("h4",{attrs:{id:"gas-schedule"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-schedule"}},[e._v("#")]),e._v(" Gas schedule")]),e._v(" "),a("h5",{attrs:{id:"g1-addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-addition"}},[e._v("#")]),e._v(" G1 addition")]),e._v(" "),a("p",[a("code",[e._v("<to be estimated>")]),e._v(" gas")]),e._v(" "),a("h5",{attrs:{id:"g1-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-multiplication"}},[e._v("#")]),e._v(" G1 multiplication")]),e._v(" "),a("p",[a("code",[e._v("<to be estimated>")]),e._v(" gas")]),e._v(" "),a("h5",{attrs:{id:"g2-addition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g2-addition"}},[e._v("#")]),e._v(" G2 addition")]),e._v(" "),a("p",[a("code",[e._v("<to be estimated>")]),e._v(" gas")]),e._v(" "),a("h5",{attrs:{id:"g2-multiplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g2-multiplication"}},[e._v("#")]),e._v(" G2 multiplication")]),e._v(" "),a("p",[a("code",[e._v("<to be estimated>")]),e._v(" gas")]),e._v(" "),a("h5",{attrs:{id:"g1-g2-multiexponentiation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-g2-multiexponentiation"}},[e._v("#")]),e._v(" G1/G2 Multiexponentiation")]),e._v(" "),a("p",[e._v("Discounts table as a vector of pairs "),a("code",[e._v("[k, discount]")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<to be estimated>\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[a("code",[e._v("max_discount = <to be estimated>")])]),e._v(" "),a("h5",{attrs:{id:"pairing-operation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pairing-operation"}},[e._v("#")]),e._v(" Pairing operation")]),e._v(" "),a("p",[e._v("Base cost of the pairing operation is "),a("code",[e._v("<to be estimated>*k + <to be estimated>")]),e._v(" where "),a("code",[e._v("k")]),e._v(" is a number of pairs.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("Gas costs are based on EIP1962 estimation strategy (but do not fully include yet parsing of ABI, decoding and encoding of the result as a byte array).")]),e._v(" "),a("h4",{attrs:{id:"gas-estimation-strategy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gas-estimation-strategy"}},[e._v("#")]),e._v(" Gas estimation strategy")]),e._v(" "),a("p",[e._v("Gas cost is derived by taking the average timing of the same operations over different implementations and assuming a constant "),a("code",[e._v("30 MGas/second")]),e._v(". Since the execution time is machine-specific, this constant is determined based on execution times of "),a("a",{attrs:{href:"https://github.com/matter-labs/eip1962/blob/master/run_bn_pairing_estimate.sh",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECRECOVER"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/matter-labs/eip1962/blob/master/run_bn_pairing_estimate.sh",target:"_blank",rel:"noopener noreferrer"}},[e._v("BNPAIR"),a("OutboundLink")],1),e._v(" precompiles on my machine and their proposed gas price ("),a("code",[e._v("43.5 MGas/s")]),e._v(" for ECRECOVER and "),a("code",[e._v("16.5 MGas/s")]),e._v(" for BNPAIR). Following are the proposed methods to time the precompile operations:")]),e._v(" "),a("ul",[a("li",[e._v("G1 addition: Average timing of 1000 random samples.")]),e._v(" "),a("li",[e._v("G1 multiplication: Average timing of 1000 samples of random worst-case of double-and-add algorithm (scalar of max bit length and max hamming weight and random base points in G1)")]),e._v(" "),a("li",[e._v("G2 addition: Average timing of 1000 random samples")]),e._v(" "),a("li",[e._v("G2 multiplication: Average timing of 1000 samples of radnom worst-case of double-and-add algorithm (scalar of max bit length and max hamming weight and random base points in G2)")]),e._v(" "),a("li",[e._v("G1 and G2 multiexponentiations: Expected to be performed by the Peppinger algorithm, with a table prepared for discount in case of "),a("code",[e._v("k <= 128")]),e._v(" points in the multiexponentiation with a discount cup "),a("code",[e._v("max_discount")]),e._v(" for "),a("code",[e._v("k > 128")]),e._v(". To avoid non-integer arithmetic call cost is calculated as "),a("code",[e._v("k * multiplication_cost * discount / multiplier")]),e._v(" where "),a("code",[e._v("multiplier = 1000")]),e._v(", "),a("code",[e._v("k")]),e._v(" is a number of (scalar, point) pairs for the call, "),a("code",[e._v("multiplication_cost")]),e._v(" is a corresponding single multiplication call cost for G1/G2.")]),e._v(" "),a("li",[e._v("Pairing: Average timing of 1000 random samples (random points in G1 and G2) for different number of pairs with linear lifting.")])]),e._v(" "),a("h4",{attrs:{id:"multiexponentiation-as-a-separate-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multiexponentiation-as-a-separate-call"}},[e._v("#")]),e._v(" Multiexponentiation as a separate call")]),e._v(" "),a("p",[e._v("Explicit separate multiexponentiation operation that allows one to save execution time (so gas) by both the algorithm used (namely Peppinger algorithm) and (usually forgotten) by the fact that "),a("code",[e._v("CALL")]),e._v(" operation in Ethereum is expensive (at the time of writing), so one would have to pay non-negigible overhead if e.g. for multiexponentiation of "),a("code",[e._v("100")]),e._v(" points would have to call the multipication precompile "),a("code",[e._v("100")]),e._v(" times and addition for "),a("code",[e._v("99")]),e._v(" times (roughly "),a("code",[e._v("138600")]),e._v(" would be saved).")]),e._v(" "),a("h4",{attrs:{id:"explicit-subgroup-checks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explicit-subgroup-checks"}},[e._v("#")]),e._v(" Explicit subgroup checks")]),e._v(" "),a("p",[e._v("G2 subgroup check has the same cost as G1 subgroup check. Endomorphisms can be leverages to optimize this operation.")]),e._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),a("p",[e._v("There are no backward compatibility questions.")]),e._v(" "),a("h2",{attrs:{id:"test-cases"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),a("p",[e._v("Due to the large test parameters space we first provide properties that various operations must satisfy. We use additive notation for point operations, capital letters ("),a("code",[e._v("P")]),e._v(", "),a("code",[e._v("Q")]),e._v(") for points, small letters ("),a("code",[e._v("a")]),e._v(", "),a("code",[e._v("b")]),e._v(") for scalars. Generator for G1 is labeled as "),a("code",[e._v("G")]),e._v(", generator for G2 is labeled as "),a("code",[e._v("H")]),e._v(", otherwise we assume random point on a curve in a correct subgroup. "),a("code",[e._v("0")]),e._v(" means either scalar zero or point of infinity. "),a("code",[e._v("1")]),e._v(" means either scalar one or multiplicative identity. "),a("code",[e._v("group_order")]),e._v(" is a main subgroup order. "),a("code",[e._v("e(P, Q)")]),e._v(" means pairing operation where "),a("code",[e._v("P")]),e._v(" is in G1, "),a("code",[e._v("Q")]),e._v(" is in G2.")]),e._v(" "),a("p",[e._v("Requeired properties for basic ops (add/multiply):")]),e._v(" "),a("ul",[a("li",[e._v("Commutativity: "),a("code",[e._v("P + Q = Q + P")])]),e._v(" "),a("li",[e._v("Additive negation: "),a("code",[e._v("P + (-P) = 0")])]),e._v(" "),a("li",[e._v("Doubling "),a("code",[e._v("P + P = 2*P")])]),e._v(" "),a("li",[e._v("Subgroup check: "),a("code",[e._v("group_order * P = 0")])]),e._v(" "),a("li",[e._v("Trivial multiplication check: "),a("code",[e._v("1 * P = P")])]),e._v(" "),a("li",[e._v("Multiplication by zero: "),a("code",[e._v("0 * P = 0")])]),e._v(" "),a("li",[e._v("Multiplication by the unnormalized scalar "),a("code",[e._v("(scalar + group_order) * P = scalar * P")])])]),e._v(" "),a("p",[e._v("Required properties for pairing operation:")]),e._v(" "),a("ul",[a("li",[e._v("Degeneracy "),a("code",[e._v("e(P, 0*Q) = e(0*P, Q) = 1")])]),e._v(" "),a("li",[e._v("Bilinearity "),a("code",[e._v("e(a*P, b*Q) = e(a*b*P, Q) = e(P, a*b*Q)")]),e._v(" (internal test, not visible through ABI)")])]),e._v(" "),a("p",[e._v("Test vector for all operations are expanded in this "),a("a",{attrs:{href:"https://gist.github.com/shamatar/506ab3193a7932fe9302a2f3a31a23e8",target:"_blank",rel:"noopener noreferrer"}},[e._v("gist"),a("OutboundLink")],1),e._v(" until it's final.")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("There is a various choice of existing implementations:")]),e._v(" "),a("p",[a("strong",[e._v("Libraries:")])]),e._v(" "),a("ul",[a("li",[e._v("Rust implementation (EY/Zexe): https://github.com/yelhousni/zexe/tree/youssef/BW6-761-Fq-ABLR-2ML-M")]),e._v(" "),a("li",[e._v("C++ implementation (EY/libff): https://github.com/EYBlockchain/zk-swap-libff")]),e._v(" "),a("li",[e._v("Golang implementation (Consensys/gurvy): https://github.com/ConsenSys/gurvy")])]),e._v(" "),a("p",[a("strong",[e._v("Stand-alone implementation:")])]),e._v(" "),a("ul",[a("li",[e._v("Golang implementation with Intel assembly (Onur Kilic): https://github.com/kilic/bw6")])]),e._v(" "),a("p",[a("strong",[e._v("Precompiles:")])]),e._v(" "),a("ul",[a("li",[e._v("OpenEthereum (EY/Parity): https://github.com/EYBlockchain/solidity-elliptic-curves")])]),e._v(" "),a("p",[a("strong",[e._v("Sripts:")])]),e._v(" "),a("ul",[a("li",[e._v("SageMath and Magma scripts: https://gitlab.inria.fr/zk-curves/bw6-761/")])]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("Strictly following the spec will eliminate security implications or consensus implications in a contrast to the previous BN254 precompile.")]),e._v(" "),a("p",[e._v('Important topic is a "constant time" property for performed operations. We explicitly state that this precompile '),a("strong",[e._v("IS NOT REQUIRED")]),e._v(" to perform all the operations using constant time algorithms.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);