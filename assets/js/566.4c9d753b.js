(window.webpackJsonp=window.webpackJsonp||[]).push([[566],{981:function(e,t,a){"use strict";a.r(t);var o=a(46),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Standardise how proxies store the address of the logic contract they delegate to, and other proxy specific information.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("Delegating "),a("strong",[e._v("proxy contracts")]),e._v(" are widely used for both upgradeability and gas savings. These proxies rely on a "),a("strong",[e._v("logic contract")]),e._v(" (also known as implementation contract or master copy) that is called using "),a("code",[e._v("delegatecall")]),e._v(". This allows proxies to keep a persistent state (storage and balance) while the code is delegated to the logic contract.")]),e._v(" "),a("p",[e._v("To avoid clashes in storage usage between the proxy and logic contract, the address of the logic contract is typically saved in a "),a("a",{attrs:{href:"https://blog.zeppelinos.org/upgradeability-using-unstructured-storage/",target:"_blank",rel:"noopener noreferrer"}},[e._v("specific storage slot"),a("OutboundLink")],1),e._v(" guaranteed to be never allocated by a compiler. This EIP proposes a set of standard slots to store proxy information. This allows clients like block explorers to properly extract and show this information to end users, and logic contracts to optionally act upon it.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("Delegating proxies are widely in use, as a means to both support upgrades and reduce gas costs of deployments. Examples of these proxies are found in "),a("a",{attrs:{href:"https://blog.zeppelinos.org/the-transparent-proxy-pattern/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZeppelinOS"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://medium.com/terminaldotco/escape-hatch-proxy-efb681de108d",target:"_blank",rel:"noopener noreferrer"}},[e._v("Terminal"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://blog.gnosis.pm/solidity-delegateproxy-contracts-e09957d0f201",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gnosis"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/aragon/aragonOS/blob/dev/contracts/common/DelegateProxy.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("AragonOS"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/melonproject/melon-mail/blob/782aeff9418ac8cdd80875fd6c400bf96f3b03b3/solidity/contracts/DelegateProxy.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Melonport"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/LimeChain/UpgradeableSolidityContract/blob/14bcabc338130fb2aba2ce8bd27b885305566fce/contracts/Upgradeability/Forwardable.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Limechain"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/windingtree/upgradeable-token-labs/blob/af3b66096091d8282d5c9c55c33365315d85f3e1/contracts/upgradable/DelegateProxy.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("WindingTree"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/decentraland/land/blob/5154046844f6f94a5074e82abe01381e6fd7c39d/contracts/upgradable/DelegateProxy.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("Decentraland"),a("OutboundLink")],1),e._v(", and many others.")]),e._v(" "),a("p",[e._v("However, the lack of a common interface for obtaining the logic address for a proxy makes it impossible to build common tools that act upon this information.")]),e._v(" "),a("p",[e._v("A classic example of this is a block explorer. Here, the end user wants to interact with the underlying logic contract and not the proxy itself. Having a common way to retrieve the logic contract address from a proxy would allow a block explorer, among other things, to show the ABI of the logic contract and not that of the proxy (see "),a("a",{attrs:{href:"https://etherscan.io/token/0x00fdae9174357424a78afaad98da36fd66dd9e03#readContract",target:"_blank",rel:"noopener noreferrer"}},[e._v("this proxy"),a("OutboundLink")],1),e._v(" for an example). The explorer should check the storage of the contract at the distinguished slots to determine if it is indeed a proxy, in which case it should show information on both the proxy and the logic contract.")]),e._v(" "),a("p",[e._v("Another example are logic contracts that explicitly act upon the fact that they are being proxied. This allows them to potentially trigger a code update as part of their logic, as is the case of "),a("RouterLink",{attrs:{to:"/zh/eip-1822.html"}},[e._v("Universal Upgradeable Proxy Standard (EIP1822)")]),e._v(". A common storage slot allows these use cases independently of the specific proxy implementation being used.")],1),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("The main requirement for the storage slots chosen is that they must never be picked by the compiler to store any contract state variable. Otherwise, a logic contract could inadvertently overwrite this information on the proxy when writing to a variable of its own.")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://solidity.readthedocs.io/en/v0.4.21/miscellaneous.html#layout-of-state-variables-in-storage",target:"_blank",rel:"noopener noreferrer"}},[e._v("Solidity"),a("OutboundLink")],1),e._v(" maps variables to storage based on the order in which they were declared, after the contract inheritance chain is linearized: the first variable is assigned the first slot, and so on. The exception are values in dynamic arrays and mappings, which are stored in the hash of the concatenation of the key and the storage slot. The Solidity development team has "),a("a",{attrs:{href:"https://twitter.com/ethchris/status/1073692785176444928",target:"_blank",rel:"noopener noreferrer"}},[e._v("confirmed"),a("OutboundLink")],1),e._v(" that the storage layout is to be preserved among new versions. Vyper seems to "),a("a",{attrs:{href:"https://github.com/ethereum/vyper/issues/769",target:"_blank",rel:"noopener noreferrer"}},[e._v("follow the same strategy as Solidity"),a("OutboundLink")],1),e._v(". Note that contracts written in other languages, or directly in assembly, may incur in clashes.")]),e._v(" "),a("p",[e._v("As such, the proposed storage slots for proxy-specific information are the following. They are chosen in such a way so they are guaranteed to not clash with state variables allocated by the compiler, since they depend on the hash of a string that does not start with a storage index. Furthermore, a "),a("code",[e._v("-1")]),e._v(" offset is added so the preimage of the hash cannot be known, further reducing the chances of a possible attack.")]),e._v(" "),a("p",[e._v("More slots for additional information can be added in subsequent ERCs as needed.")]),e._v(" "),a("p",[e._v("Monitoring of proxies is essential to the security of many applications. It is thus essential to have the ability to track changes to the implementation and admin slots. Unfortunately, tracking changes to storage slots is not easy. Consequently, it is recommended that any function that changes any of these slots SHOULD also emit the corresponding event. This includes initialization, from "),a("code",[e._v("0x0")]),e._v(" to the first non-zero value.")]),e._v(" "),a("h3",{attrs:{id:"logic-contract-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#logic-contract-address"}},[e._v("#")]),e._v(" Logic contract address")]),e._v(" "),a("p",[e._v("Storage slot "),a("code",[e._v("0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc")]),e._v(" (obtained as "),a("code",[e._v("bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)")]),e._v(").")]),e._v(" "),a("p",[e._v("Holds the address of the logic contract that this proxy delegates to. SHOULD be empty if a beacon is used instead. Changes to this slot should be notified by the event:")]),e._v(" "),a("div",{staticClass:"language-solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("event")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("Upgraded")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("indexed")]),e._v(" implementation"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"beacon-contract-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beacon-contract-address"}},[e._v("#")]),e._v(" Beacon contract address")]),e._v(" "),a("p",[e._v("Storage slot "),a("code",[e._v("0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50")]),e._v(" (obtained as "),a("code",[e._v("bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)")]),e._v(").")]),e._v(" "),a("p",[e._v("Holds the address of the beacon contract this proxy relies on (fallback). SHOULD be empty if a logic address is used directly instead, and should only be considered if the logic contract slot is empty. See the Beacons section below. Changes to this slot should be notified by the event:")]),e._v(" "),a("div",{staticClass:"language-solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("event")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("BeaconUpgraded")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("indexed")]),e._v(" beacon"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"admin-address"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#admin-address"}},[e._v("#")]),e._v(" Admin address")]),e._v(" "),a("p",[e._v("Storage slot "),a("code",[e._v("0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103")]),e._v(" (obtained as "),a("code",[e._v("bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)")]),e._v(").")]),e._v(" "),a("p",[e._v("Holds the address that is allowed to upgrade the logic contract address for this proxy (optional). Changes to this slot should be notified by the event:")]),e._v(" "),a("div",{staticClass:"language-solidity line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-solidity"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("event")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("AdminChanged")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" previousAdmin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("address")]),e._v(" newAdmin"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("This EIP standardises the "),a("strong",[e._v("storage slot")]),e._v(" for the logic contract address, instead of a public method on the proxy contract as "),a("RouterLink",{attrs:{to:"/zh/eip-897.html"}},[e._v("DelegateProxy (EIP897)")]),e._v(" does. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract.")],1),e._v(" "),a("p",[e._v("Note that a clash may occur even among functions with different names, since the ABI relies on just four bytes for the function selector. This can lead to unexpected errors, or even exploits, where a call to a proxied contract returns a different value than expected, since the proxy intercepts the call and answers with a value of its own.")]),e._v(" "),a("p",[e._v("From "),a("a",{attrs:{href:"https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357",target:"_blank",rel:"noopener noreferrer"}},[a("em",[e._v("Malicious backdoors in Ethereum proxies")]),a("OutboundLink")],1),e._v(" by Nomic Labs:")]),e._v(" "),a("blockquote",[a("p",[e._v("Any function in the Proxy contract whose selector matches with one in the implementation contract will be called directly, completely skipping the implementation code.")]),e._v(" "),a("p",[e._v("Because the function selectors use a fixed amount of bytes, there will always be the possibility of a clash. This isn’t an issue for day to day development, given that the Solidity compiler will detect a selector clash within a contract, but this becomes exploitable when selectors are used for cross-contract interaction. Clashes can be abused to create a seemingly well-behaved contract that’s actually concealing a backdoor.")])]),e._v(" "),a("p",[e._v("The fact that proxy public functions are potentially exploitable makes it necessary to standardise the logic contract address in a different way. This approach is also used as part of "),a("RouterLink",{attrs:{to:"/zh/eip-1822.html"}},[e._v("Universal Upgradeable Proxy Standard (EIP1822)")]),e._v(", which could become a specialization of this EIP.")],1),e._v(" "),a("h2",{attrs:{id:"beacons"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beacons"}},[e._v("#")]),e._v(" Beacons")]),e._v(" "),a("p",[e._v("Some use-cases rely on multiple proxy contracts delegating their calls to the same logic contract. If each contract was to store the address of the logic contract using the logic contract storage slot, upgrading them would require writing to the corresponding storage slot of every instance, which could be very expensive in terms of gas.")]),e._v(" "),a("p",[e._v('Another approach is to have each proxy retrieve the logic contract\'s address from a dedicated "beacon". Using this pattern, the address of the logic contract can be modified in the beacon and take immediate effect for all the corresponding proxy contracts.')]),e._v(" "),a("p",[e._v("A beacon MUST implement the function:")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function implementation() returns (address)\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("Beacon based proxy contracts do not use the logic contract slot. Instead, they use the beacon contract slot to store the address of the beacon they are attached to. In order to know the logic contract used by a beacon proxy, one should:")]),e._v(" "),a("ul",[a("li",[e._v("Read the address of the beacon for the beacon logic storage slot;")]),e._v(" "),a("li",[e._v("Call the "),a("code",[e._v("implementation()")]),e._v(" function on the beacon contract.")])]),e._v(" "),a("p",[e._v("The result of the "),a("code",[e._v("implementation()")]),e._v(" function on the beacon contract SHOULD NOT depend on the caller ("),a("code",[e._v("msg.sender")]),e._v(").")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("Sample proxy implementations that follow this standard can be found in the "),a("a",{attrs:{href:"https://github.com/zeppelinos/zos/blob/dc9e4ed/packages/lib/contracts/upgradeability/BaseUpgradeabilityProxy.sol",target:"_blank",rel:"noopener noreferrer"}},[e._v("ZeppelinOS repository"),a("OutboundLink")],1),e._v(", albeit with a different set of slots.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);