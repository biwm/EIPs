(window.webpackJsonp=window.webpackJsonp||[]).push([[667],{1087:function(e,t,a){"use strict";a.r(t);var r=a(46),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"simple-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),a("p",[e._v("Add new methods to the JSON-RPC for signing and decrypting JOSE objects under a new "),a("code",[e._v("did_*")]),e._v(" prefix.")]),e._v(" "),a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),a("p",[e._v("This EIP describes three new methods to add to the JSON-RPC that enables wallets to support "),a("em",[e._v("Decentralized Identifiers")]),e._v(" (DIDs) as well as "),a("em",[e._v("JSON Object Signing and Encryption")]),e._v(" (JOSE). These standards enables wallets to support data decryption as well as authenticated data, both in standard formats using JOSE. With these new methods apps can request the DID from a users wallet, from which a DID document can be resolved. The DID document contains public keys that can be used for encryption and signature verification. This enables Alice to discover Bobs public keys by only knowing Bobs DID. This EIP does not enforce the user of any particular DID method or JOSE algorithms, wallets are free to implement these however they wish.")]),e._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),a("p",[e._v("There has been one main previous effort ("),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/130",target:"_blank",rel:"noopener noreferrer"}},[e._v("#130"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/pull/1098",target:"_blank",rel:"noopener noreferrer"}},[e._v("#1098"),a("OutboundLink")],1),e._v(") to add decryption to Ethereum wallets in a standard way. This previous approach used a non standard way to encode and represent data encrypted using "),a("code",[e._v("x25519-xsalsa20-poly1305")]),e._v(". While this approach does provide a functional way to add encryption support to wallets, it does not take into account similar work that has gone into standardizing the way encrypted data is represented, namely using "),a("a",{attrs:{href:"https://datatracker.ietf.org/wg/jose/documents/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JOSE"),a("OutboundLink")],1),e._v(". This is a standard from IETF for representing signed and encrypted objects. Another shortcoming of the previous approach is that it's impossible to retrieve the "),a("code",[e._v("x25519")]),e._v(" public key from another user if only an Ethereum address is known. Public key discoverability is at the core of the work that is happening with the "),a("a",{attrs:{href:"https://w3c.github.io/did-core",target:"_blank",rel:"noopener noreferrer"}},[e._v("W3C DID standard"),a("OutboundLink")],1),e._v(", where given a DID a document which contains public keys can always be discovered. Implementations of this standard already exist and are adopted within the Ethereum community, e.g. "),a("a",{attrs:{href:"https://github.com/decentralized-identity/ethr-did-resolver/",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("did:ethr")]),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/3box/3id-resolver",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("did:3")]),a("OutboundLink")],1),e._v(". Interoperability between JOSE and DIDs "),a("a",{attrs:{href:"https://github.com/decentralized-identity/did-jwt",target:"_blank",rel:"noopener noreferrer"}},[e._v("already exists"),a("OutboundLink")],1),e._v(", and work is being done to "),a("a",{attrs:{href:"https://github.com/decentralized-identity/did-jose-extensions",target:"_blank",rel:"noopener noreferrer"}},[e._v("strengthen it"),a("OutboundLink")],1),e._v(". Adding support for JOSE and DIDs will enable Ethereum wallets to support a wide range of new use cases such as more traditional authentication using JWTs, as well as new emerging technologies such as "),a("a",{attrs:{href:"https://identity.foundation/secure-data-store/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Secure Data Stores"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://github.com/ipld/specs/pull/269",target:"_blank",rel:"noopener noreferrer"}},[e._v("encrypted data in IPFS"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),a("p",[e._v("Three new JSON-RPC methods are specified under the new "),a("code",[e._v("did_*")]),e._v(" prefix.")]),e._v(" "),a("h3",{attrs:{id:"auth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#auth"}},[e._v("#")]),e._v(" Auth")]),e._v(" "),a("p",[e._v("Authenticate the current rpc connection to the DID methods.")]),e._v(" "),a("p",[e._v("Prompt the user to give permission to the current connection to access the user DID and the given "),a("code",[e._v("paths")]),e._v(".")]),e._v(" "),a("h5",{attrs:{id:"method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#method"}},[e._v("#")]),e._v(" Method:")]),e._v(" "),a("p",[a("code",[e._v("did_authenticate")])]),e._v(" "),a("h5",{attrs:{id:"params"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#params"}},[e._v("#")]),e._v(" Params:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("nonce")]),e._v(" - a random string used as a challenge")]),e._v(" "),a("li",[a("code",[e._v("aud")]),e._v(" - the intended audience of the authentication response")]),e._v(" "),a("li",[a("code",[e._v("paths")]),e._v(" - an array of strings")])]),e._v(" "),a("h5",{attrs:{id:"returns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("A JWS with general serialization containing the following properties:")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("nonce")]),e._v(" - the random string which was given as a challenge")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("did")]),e._v(" - the DID which authentication was given for")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("paths")]),e._v(" - the paths which was given permission for")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("exp")]),e._v(" - a unix timestamp after which the JWS should be considered invalid")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("aud")]),e._v(" - optional audience for the JWS, should match the domain which made the request")])])]),e._v(" "),a("p",[e._v("An additional property "),a("code",[e._v("kid")]),e._v(" with the value which represents the DID, and the "),a("code",[e._v("keyFragment")]),e._v(" that was used to sign the JWS should be added to the protected header ("),a("a",{attrs:{href:"https://github.com/decentralized-identity/did-jose-extensions/issues/2",target:"_blank",rel:"noopener noreferrer"}},[e._v("details"),a("OutboundLink")],1),e._v(").")]),e._v(" "),a("h4",{attrs:{id:"createjws"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#createjws"}},[e._v("#")]),e._v(" CreateJWS")]),e._v(" "),a("p",[e._v("Creates a JSON Web Signature (JWS).")]),e._v(" "),a("p",[e._v("An additional property "),a("code",[e._v("kid")]),e._v(" with the value which represents the DID, and the "),a("code",[e._v("keyFragment")]),e._v(" that was used to sign the JWS should be added to the protected header ("),a("a",{attrs:{href:"https://github.com/decentralized-identity/did-jose-extensions/issues/2",target:"_blank",rel:"noopener noreferrer"}},[e._v("details"),a("OutboundLink")],1),e._v("). When "),a("code",[e._v("revocable")]),e._v(" is set to false the JWS signature should not be possible to revoke. For some DID methods like. "),a("code",[e._v("did:key")]),e._v(" this is always the case. For other methods which support key revocation it is necessary to include the "),a("code",[e._v("version-id")]),e._v(" in the "),a("code",[e._v("kid")]),e._v(" to refer to a specific version of the DID document. When "),a("code",[e._v("revocable")]),e._v(" is set to true "),a("code",[e._v("version-id")]),e._v(" must not be included in the "),a("code",[e._v("kid")]),e._v(" for DID methods that support key revocation.")]),e._v(" "),a("h5",{attrs:{id:"method-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#method-2"}},[e._v("#")]),e._v(" Method:")]),e._v(" "),a("p",[a("code",[e._v("did_createJWS")])]),e._v(" "),a("h5",{attrs:{id:"params-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#params-2"}},[e._v("#")]),e._v(" Params:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("payload")]),e._v(" - the payload to sign, json object or "),a("code",[e._v("base64url")]),e._v(" encoded string")]),e._v(" "),a("li",[a("code",[e._v("protected")]),e._v(" - the protected header, json object")]),e._v(" "),a("li",[a("code",[e._v("did")]),e._v(" - the DID that should sign the message, may include the key fragment, string")]),e._v(" "),a("li",[a("code",[e._v("revocable")]),e._v(" - makes the JWS revocable when rotating keys, boolean default to "),a("code",[e._v("false")])])]),e._v(" "),a("h5",{attrs:{id:"returns-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-2"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("An object containing a JWS with general serialization on the "),a("code",[e._v("jws")]),e._v(" property.")]),e._v(" "),a("h5",{attrs:{id:"recommendation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recommendation"}},[e._v("#")]),e._v(" Recommendation:")]),e._v(" "),a("p",[e._v("Use "),a("code",[e._v("secp256k1")]),e._v(" for signing, alternatively "),a("code",[e._v("ed25519")]),e._v(".")]),e._v(" "),a("h4",{attrs:{id:"decryptjwe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#decryptjwe"}},[e._v("#")]),e._v(" DecryptJWE")]),e._v(" "),a("p",[e._v("Decrypt the given JWE.")]),e._v(" "),a("p",[e._v("If the cleartext object contains a property "),a("code",[e._v("paths")]),e._v(" that contains an array of strings and one of the paths in there are already authenticated using "),a("code",[e._v("did_authenticate")]),e._v(" the decryption should happen without user confirmation.")]),e._v(" "),a("h5",{attrs:{id:"method-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#method-3"}},[e._v("#")]),e._v(" Method:")]),e._v(" "),a("p",[a("code",[e._v("did_decryptJWE")])]),e._v(" "),a("h5",{attrs:{id:"params-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#params-3"}},[e._v("#")]),e._v(" Params:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("jwe")]),e._v(" - a JWE with general serialization, string")]),e._v(" "),a("li",[a("code",[e._v("did")]),e._v(" - the DID that should try to decrypt the JWE, string")])]),e._v(" "),a("h5",{attrs:{id:"returns-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returns-3"}},[e._v("#")]),e._v(" Returns:")]),e._v(" "),a("p",[e._v("An object containing the cleartext, encoded using "),a("a",{attrs:{href:"https://github.com/multiformats/multibase",target:"_blank",rel:"noopener noreferrer"}},[a("code",[e._v("base64pad")]),a("OutboundLink")],1),e._v(", assigned to the "),a("code",[e._v("cleartext")]),e._v(" property.")]),e._v(" "),a("h5",{attrs:{id:"recommendation-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recommendation-2"}},[e._v("#")]),e._v(" Recommendation:")]),e._v(" "),a("p",[e._v("Implement decryption using "),a("code",[e._v("xchacha20poly1305")]),e._v(" and "),a("code",[e._v("x25519")]),e._v(" for key agreement.")]),e._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),a("p",[e._v("This EIP chooses to rely on DIDs and JOSE since there is already support for these standards in many places, by current systems and new systems. By using DIDs and JOSE wallet implementers can also choose which signing and encryption algorithms that they want to support, since these formats are fairly agnostic to specific crypto implementations.")]),e._v(" "),a("h3",{attrs:{id:"permission-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#permission-system"}},[e._v("#")]),e._v(" Permission system")]),e._v(" "),a("p",[e._v("A simple permission system is proposed where clients can request permissions though path prefixes, e.g. "),a("code",[e._v("/some/permission")]),e._v(". When decryption of a JWE is requested the wallet should check if the decrypted payload contains a "),a("code",[e._v("paths")]),e._v(" property. If this property doesn't exist the user may be prompted to confirm that the given rpc connection (app) is allowed to read the decrypted data. If the "),a("code",[e._v("paths")]),e._v(" property is present in the decrypted data it should contain an array of string paths. If one of the these path prefixes matches with one of the path prefixes the user has already granted permission for then decryption should happen automatically without any user confirmation.")]),e._v(" "),a("p",[e._v("This simple permission system was inspired by some previous comments ("),a("a",{attrs:{href:"https://github.com/ethereum/EIPs/issues/130#issuecomment-329770999",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://medium.com/@wighawag/3-proposals-for-making-web3-a-better-experience-974f97765700",target:"_blank",rel:"noopener noreferrer"}},[e._v("2"),a("OutboundLink")],1),e._v(") but avoids data lock in around origins.")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/3box/identity-wallet-js/",target:"_blank",rel:"noopener noreferrer"}},[e._v("IdentityWallet"),a("OutboundLink")],1),e._v(": An implementation of the wallet side "),a("code",[e._v("did_*")]),e._v(" methods using the 3ID DID.")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/ceramicnetwork/key-did-provider-ed25519",target:"_blank",rel:"noopener noreferrer"}},[e._v("key-did-provider-ed25519"),a("OutboundLink")],1),e._v(":  An implementation of the wallet side "),a("code",[e._v("did_*")]),e._v(" methods using the "),a("code",[e._v("did:key")]),e._v(" method.")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/ceramicnetwork/js-did",target:"_blank",rel:"noopener noreferrer"}},[e._v("js-did"),a("OutboundLink")],1),e._v(": A small library which consumes the "),a("code",[e._v("did_*")]),e._v(" methods.")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/digitalbazaar/minimal-cipher",target:"_blank",rel:"noopener noreferrer"}},[e._v("MinimalCipher"),a("OutboundLink")],1),e._v(": An implementation of DID related encryption for JWE.")]),e._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),a("p",[e._v("Both JOSE and DIDs are standards that have gone though a lot of scrutiny. Their security will not be considered in this document. In the specification section, recommendations are given for which algorithms to use. For signatures "),a("code",[e._v("secp256k1")]),e._v(" is already used by ethereum and for decryption "),a("code",[e._v("xchacha20poly1305")]),e._v(" is widely available, very performant, and already used in TLS.")]),e._v(" "),a("p",[e._v("The main security consideration of this EIP is the suggested permission system. Here various threat models could be considered. However, this EIP does not go into details about how it should work other than suggesting an approach. In the end it is up to wallet implementations to choose how to ask their users for consent.")]),e._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),a("p",[e._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),a("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=s.exports}}]);