(window.webpackJsonp=window.webpackJsonp||[]).push([[658],{1077:function(t,e,a){"use strict";a.r(e);var n=a(46),i=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"abstract"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),a("p",[a("code",[t._v("TransactionType || TransactionPayload")]),t._v(" is a valid transaction and "),a("code",[t._v("TransactionType || ReceiptPayload")]),t._v(" is a valid transaction receipt where "),a("code",[t._v("TransactionType")]),t._v(" identifies the format of the transaction and "),a("code",[t._v("*Payload")]),t._v(" is the transaction/receipt contents, which are defined in future EIPs.")]),t._v(" "),a("h2",{attrs:{id:"motivation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[t._v("#")]),t._v(" Motivation")]),t._v(" "),a("p",[t._v("In the past, when we have wanted to add new transaction types we have had to ensure they were backward compatible with all other transactions, meaning that you could differentiate them based only on the encoded payload, and it was not possible to have a transaction that matched both types. This was seen in "),a("RouterLink",{attrs:{to:"/zh/eip-155.html"}},[t._v("EIP-155")]),t._v(" where the new value was bit-packed into one of the encoded fields. There are multiple proposals in discussion that define new transaction types such as one that allows EOA accounts to execute code directly within their context, one that enables someone besides "),a("code",[t._v("msg.sender")]),t._v(" to pay for gas, and proposals related to layer 1 multi-sig transactions. These all need to be defined in a way that is mutually compatible, which quickly becomes burdensome to EIP authors and to clients who now have to follow complex rules for differentiating transaction type.")],1),t._v(" "),a("p",[t._v("By introducing an envolope transaction type, we only need to ensure backward compatibility with existing transactions and from then on we just need to solve the much simpler problem of ensuring there is no numbering conflict between "),a("code",[t._v("TransactionType")]),t._v("s.")]),t._v(" "),a("h2",{attrs:{id:"specification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[t._v("#")]),t._v(" Specification")]),t._v(" "),a("h3",{attrs:{id:"definitions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[t._v("#")]),t._v(" Definitions")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("||")]),t._v(" is the byte/byte-array concatenation operator.")])]),t._v(" "),a("h3",{attrs:{id:"transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactions"}},[t._v("#")]),t._v(" Transactions")]),t._v(" "),a("p",[t._v("As of "),a("code",[t._v("FORK_BLOCK_NUMBER")]),t._v(", the transaction root in the block header "),a("strong",[t._v("MUST")]),t._v(" be the root hash of "),a("code",[t._v("patriciaTrie(rlp(Index) => Transaction)")]),t._v(" where:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Index")]),t._v(" is the index in the block of this transaction")]),t._v(" "),a("li",[a("code",[t._v("Transaction")]),t._v(" is either "),a("code",[t._v("TransactionType || TransactionPayload")]),t._v(" or "),a("code",[t._v("LegacyTransaction")])]),t._v(" "),a("li",[a("code",[t._v("TransactionType")]),t._v(" is a positive unsigned 8-bit number between "),a("code",[t._v("0")]),t._v(" and "),a("code",[t._v("0x7f")]),t._v(" that represents the type of the transcation")]),t._v(" "),a("li",[a("code",[t._v("TransactionPayload")]),t._v(" is an opaque byte array whose interpretation is dependent on the "),a("code",[t._v("TransactionType")]),t._v(" and defined in future EIPs")]),t._v(" "),a("li",[a("code",[t._v("LegacyTransaction")]),t._v(" is "),a("code",[t._v("rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s])")])])]),t._v(" "),a("p",[t._v("All signatures for future transaction types "),a("strong",[t._v("SHOULD")]),t._v(" include the "),a("code",[t._v("TransactionType")]),t._v(" as the first byte of the signed data. This makes it so we do not have to worry about signatures for one transaction type being used as signatures for a different transaction type.")]),t._v(" "),a("h3",{attrs:{id:"receipts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#receipts"}},[t._v("#")]),t._v(" Receipts")]),t._v(" "),a("p",[t._v("As of "),a("code",[t._v("FORK_BLOCK_NUMBER")]),t._v(", the receipt root in the block header "),a("strong",[t._v("MUST")]),t._v(" be the root hash of "),a("code",[t._v("patriciaTrie(rlp(Index) => Receipt)")]),t._v(" where:")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Index")]),t._v(" is the index in the block of the transaction this receipt is for")]),t._v(" "),a("li",[a("code",[t._v("Receipt")]),t._v(" is either "),a("code",[t._v("TransactionType || ReceiptPayload")]),t._v(" or "),a("code",[t._v("LegacyReceipt")])]),t._v(" "),a("li",[a("code",[t._v("TransactionType")]),t._v(" is a positive unsigned 8-bit number between "),a("code",[t._v("0")]),t._v(" and "),a("code",[t._v("0x7f")]),t._v(" that represents the type of the transcation")]),t._v(" "),a("li",[a("code",[t._v("ReceiptPayload")]),t._v(" is an opaque byte array whose interpretation is dependent on the "),a("code",[t._v("TransactionType")]),t._v(" and defined in future EIPs")]),t._v(" "),a("li",[a("code",[t._v("LegacyReceipt")]),t._v(" is "),a("code",[t._v("rlp([status, cumulativeGasUsed, logsBloom, logs])")])])]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("TransactionType")]),t._v(" of the receipt "),a("strong",[t._v("MUST")]),t._v(" match the "),a("code",[t._v("TransactionType")]),t._v(" of the transaction with a matching "),a("code",[t._v("Index")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"rationale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[t._v("#")]),t._v(" Rationale")]),t._v(" "),a("h3",{attrs:{id:"transactiontype-only-goes-up-to-0x7f"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactiontype-only-goes-up-to-0x7f"}},[t._v("#")]),t._v(" TransactionType only goes up to 0x7f")]),t._v(" "),a("p",[t._v("For the forseable future, 0x7f is plenty and it leaves open a number of options for extending the range such as using the high bit as a continuation bit. This also prevents us from colliding with legacy transaction types, which always start with a byte "),a("code",[t._v(">= 0xc0")]),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"should-instead-of-must-for-the-transactiontype-being-first-byte-of-signed-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#should-instead-of-must-for-the-transactiontype-being-first-byte-of-signed-data"}},[t._v("#")]),t._v(" "),a("strong",[t._v("SHOULD")]),t._v(" instead of "),a("strong",[t._v("MUST")]),t._v(" for the TransactionType being first byte of signed data")]),t._v(" "),a("p",[t._v("While it is strongly recommended that all future transactions sign the first byte to ensure that there is no problem with signature reuse, the authors acknowledge that this may not always make sense or be possible. One example where this isn't possible is wrapped legacy transactions that are signature compatible with the legacy signing scheme. Another potential situation is one where transactions don't have a signature in the traditional sense and instead have some other mechanism for determining validity.")]),t._v(" "),a("h3",{attrs:{id:"transactiontype-selection-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transactiontype-selection-algorithm"}},[t._v("#")]),t._v(" TransactionType selection algorithm")]),t._v(" "),a("p",[t._v("There was discussion about defining the "),a("code",[t._v("TransactionType")]),t._v(" identifier assignment/selection algorithm in this standard. While it would be nice to have a standardized mechanism for assignment, at the time of writing of this standard there is not a strong need for it so it was deemed out of scope. A future EIP may introduce a standard for TransactionType identifier assignment if it is deemed necessary.")]),t._v(" "),a("h3",{attrs:{id:"opaque-byte-array-rather-than-an-rlp-array"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#opaque-byte-array-rather-than-an-rlp-array"}},[t._v("#")]),t._v(" Opaque byte array rather than an RLP array")]),t._v(" "),a("p",[t._v("By having the second byte on be opaque bytes, rather than an RLP (or other encoding) list, we can support different encoding formats for the transaction payload in the future such as SSZ, LEB128, or a fixed width format.")]),t._v(" "),a("h3",{attrs:{id:"origin-and-caller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#origin-and-caller"}},[t._v("#")]),t._v(" ORIGIN and CALLER")]),t._v(" "),a("p",[t._v("There was discussion about having ORIGIN and CALLER opcodes become dependent on the transaction type, so that each transaction type could define what those opcodes returned. However, there is a desire to make transaction type opaque to the contracts to discourage contracts treating different types of transactions differently. There also were concerns over backward compatibility with existing contracts which make assumptions about ORIGIN and CALLER opcodes. Going forward, we will assume that all transaction types will have an address that reasonably represents a "),a("code",[t._v("CALLER")]),t._v(" of the first EVM frame and "),a("code",[t._v("ORIGIN")]),t._v(" will be the same address in all cases. If a transaction type needs to supply additional information to contracts, they will need a new opcode.")]),t._v(" "),a("h2",{attrs:{id:"backwards-compatibility"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[t._v("#")]),t._v(" Backwards Compatibility")]),t._v(" "),a("p",[t._v("Clients can differentiate between the legacy transactions and typed transactions by looking at the first byte. If it starts with a value in the range "),a("code",[t._v("[0, 0x7f]")]),t._v(" then it is a new transaction type, if it starts with a value in the range "),a("code",[t._v("[0xc0, 0xfe]")]),t._v(" then it is a legacy transaction type. "),a("code",[t._v("0xff")]),t._v(" is not realistic for an RLP encoded transaction, so it is reserved for future use as an extension sentinel value.")]),t._v(" "),a("h2",{attrs:{id:"security-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[t._v("#")]),t._v(" Security Considerations")]),t._v(" "),a("p",[t._v("When designing a new 2718 transaction type, it is "),a("strong",[t._v("STRONGLY")]),t._v(" recommended to include the transaction type as the first byte of the signed payload.  If you fail to do this, it is possible that your transaction may be signature compatible with transactions of another type which can introduce security vulnerabilities for users.")]),t._v(" "),a("h2",{attrs:{id:"copyright"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[t._v("#")]),t._v(" Copyright")]),t._v(" "),a("p",[t._v("Copyright and related rights waived via "),a("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CC0"),a("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);e.default=i.exports}}]);