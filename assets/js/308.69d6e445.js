(window.webpackJsonp=window.webpackJsonp||[]).push([[308],{709:function(e,n,s){"use strict";s.r(n);var t=s(46),a=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"simple-summary"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#simple-summary"}},[e._v("#")]),e._v(" Simple Summary")]),e._v(" "),s("p",[e._v("This EIP defines a hash-to-curve precompile for use in BN256\nand would allow for cheaper BLS signature verification.")]),e._v(" "),s("h2",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),s("p",[e._v("There is currently no inexpensive way to perform BLS signature\nverification for arbitrary messages.\nThis stems from the fact that there is no precompiled contract\nin the EVM for a hash-to-curve algorithm for the BN256 elliptic curve.\nThe gas cost of calling a deterministic hash-to-curve algorithm\nwritten in Solidity is approximately that of one pairing check,\nalthough the latter requires an order of magnitude\nmore computation.\nThis EIP remedies this by implementing a hash-to-curve algorithm\nfor the BN256 G1 curve, which would reduce the cost of\nsignature verification to essentially that of the pairing check\nprecompiled contract.\nWe also include a hash-to-curve algorithm for the BN256 G2 group.")]),e._v(" "),s("h2",{attrs:{id:"motivation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),s("p",[e._v("The precompiled contracts in\n"),s("RouterLink",{attrs:{to:"/eip-198.html"}},[e._v("EIP-198")]),e._v(" and\n"),s("RouterLink",{attrs:{to:"/eip-1108.html"}},[e._v("EIP-1108")]),e._v("\nincreased usage of cryptographic operations in the EVM\nby reducing the gas costs.\nIn particular, the cost reduction from\n"),s("RouterLink",{attrs:{to:"/eip-1108.html"}},[e._v("EIP-1108")]),e._v("\nhelps increase the use of SNARKs in Ethereum\nvia an elliptic curve pairing check;\nhowever, a hash-to-curve algorithm enabling arbitrary\nBLS signature verification on BN256 in the EVM was noticeably missing.\nThere is interest in having a precompiled contract which would allow\nfor signature verification, as noted\n"),s("a",{attrs:{href:"https://ethereum-magicians.org/t/pre-compile-for-bls/3973",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),s("OutboundLink")],1),e._v(".")],1),e._v(" "),s("p",[e._v("At this time, we are able to perform addition, scalar multiplication,\nand pairing checks in BN256.\nReducing these costs in\n"),s("RouterLink",{attrs:{to:"/eip-1108.html"}},[e._v("EIP-1108")]),e._v("\nmade "),s("a",{attrs:{href:"https://github.com/PhilippSchindler/ethdkg",target:"_blank",rel:"noopener noreferrer"}},[e._v("ETHDKG"),s("OutboundLink")],1),e._v(",\na distributed key generation protocol in Ethereum,\nless expensive.\nETHDKG by itself is useful; however, what it is lacking is\nthe ability to verify arbitrary BLS signatures.\nCreating group signatures by aggregating partial signatures\nis one goal of a DKG protocol.\nThe DKG enables the computation of partial signatures to be\ncombined into a group signature offline, but there is no\neasy way to verify partial signatures or group signatures\nin the EVM.")],1),e._v(" "),s("p",[e._v("In order to perform BLS signature validation, a hash-to-curve\nalgorithm is required.\nWhile the MapToGroup method initially discussed in the original BLS\n"),s("a",{attrs:{href:"../assets/eip-3068/weilsigs.pdf"}},[e._v("paper")]),e._v("\nworks in practice, the nondeterministic nature of the algorithm\nleaves something to be desired as we would like to bound\nthe overall computational cost in the EVM.\nA deterministic method for mapping to BN curves is given\n"),s("a",{attrs:{href:"../assets/eip-3068/latincrypt12.pdf"}},[e._v("here")]),e._v(";\nin the paper, Fouque and Tibouchi proved their mapping\nwas indifferentiable from a random oracle.\nThis gives us the desired algorithm.")]),e._v(" "),s("h2",{attrs:{id:"specification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),s("p",[e._v("Here is the pseudocode for the "),s("code",[e._v("HashToG1")]),e._v(" function:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function HashToG1(msg)\n    fieldElement0 = HashToBase(msg, 0x00, 0x01)\n    fieldElement1 = HashToBase(msg, 0x02, 0x03)\n    curveElement0 = BaseToG1(fieldElement0)\n    curveElement1 = BaseToG1(fieldElement1)\n    g1Element = ECAdd(curveElement0, curveElement1)\n    return g1Element\nend function\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("Here is the pseudocode for "),s("code",[e._v("HashToBase")]),e._v(";\n"),s("code",[e._v("msg")]),e._v(" is the byte slice to be hashed while "),s("code",[e._v("dsp1")]),e._v(" and "),s("code",[e._v("dsp2")]),e._v("\nare domain separation parameters.\n"),s("code",[e._v("fieldPrime")]),e._v(" is the prime of the underlying field.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function HashToBase(msg, dsp1, dsp2)\n    hashResult0 = uint256(Keccak256(dsp1||msg))\n    hashResult1 = uint256(Keccak256(dsp2||msg))\n    constant = 2^256 mod fieldPrime\n    fieldElement0 = hashResult0*constant          mod fieldPrime\n    fieldElement1 = hashResult1                   mod fieldPrime\n    fieldElement  = fieldElement0 + fieldElement1 mod fieldPrime\n    return fieldElement\nend function\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("Here is the pseudocode for "),s("code",[e._v("BaseToG1")]),e._v(".\nAll of these operations are performed in the finite field.\n"),s("code",[e._v("inverse")]),e._v(" computes the multiplicative inverse in the underlying\nfinite field; we have the convention "),s("code",[e._v("inverse(0) == 0")]),e._v(".\n"),s("code",[e._v("is_square(a)")]),e._v(" computes the Legendre symbol of the element,\nreturning 1 if "),s("code",[e._v("a")]),e._v(" is a square, -1 if "),s("code",[e._v("a")]),e._v(" is not a square,\nand 0 if "),s("code",[e._v("a")]),e._v(" is 0.\n"),s("code",[e._v("sqrt")]),e._v(" computes the square root of the element in the finite\nfield; a square root is assumed to exist.\n"),s("code",[e._v("sign0")]),e._v(" returns the sign of the finite field element.")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function BaseToG1(t)\n    # All operations are done in the finite field GF(fieldPrime)\n    # Here, the elliptic curve satisfies the equation\n    #       y^2 == g(x) == x^3 + curveB\n    constant1 = (-1 + sqrt(-3))/2\n    constant2 = -3\n    constant3 = 1/3\n    constant4 = g(1)\n    s = (constant4 + t^2)^3\n    alpha = inverse(t^2*(constant4 + t^2))\n    x1 = constant1 - constant2*t^4*alpha\n    x2 = -1 - x1\n    x3 = 1 - constant3*s*alpha\n    a1 = x1^3 + curveB\n    a2 = x2^3 + curveB\n    residue1 = is_square(a1)\n    residue2 = is_square(a2)\n    index = (residue1 - 1)*(residue2 - 3)/4 + 1\n    coef1 = ConstantTimeEquality(1, index)\n    coef2 = ConstantTimeEquality(2, index)\n    coef3 = ConstantTimeEquality(3, index)\n    x = coef1*x1 + coef2*x2 + coef3*x3\n    y = sign0(t)*sqrt(x^3 + curveB)\n    return (x, y)\nend function\n\nfunction sign0(t)\n    if t <= (fieldPrime-1)/2\n        return 1\n    else\n        return fieldPrime-1\n    end if\nend function\n\nfunction ConstantTimeEquality(a, b)\n    # This function operates in constant time\n    if a == b\n        return 1\n    else\n        return 0\n    end if\nend function\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br"),s("span",{staticClass:"line-number"},[e._v("26")]),s("br"),s("span",{staticClass:"line-number"},[e._v("27")]),s("br"),s("span",{staticClass:"line-number"},[e._v("28")]),s("br"),s("span",{staticClass:"line-number"},[e._v("29")]),s("br"),s("span",{staticClass:"line-number"},[e._v("30")]),s("br"),s("span",{staticClass:"line-number"},[e._v("31")]),s("br"),s("span",{staticClass:"line-number"},[e._v("32")]),s("br"),s("span",{staticClass:"line-number"},[e._v("33")]),s("br"),s("span",{staticClass:"line-number"},[e._v("34")]),s("br"),s("span",{staticClass:"line-number"},[e._v("35")]),s("br"),s("span",{staticClass:"line-number"},[e._v("36")]),s("br"),s("span",{staticClass:"line-number"},[e._v("37")]),s("br"),s("span",{staticClass:"line-number"},[e._v("38")]),s("br"),s("span",{staticClass:"line-number"},[e._v("39")]),s("br"),s("span",{staticClass:"line-number"},[e._v("40")]),s("br"),s("span",{staticClass:"line-number"},[e._v("41")]),s("br"),s("span",{staticClass:"line-number"},[e._v("42")]),s("br")])]),s("p",[e._v("In "),s("code",[e._v("HashToG2")]),e._v(", we first map to the underlying twist curve\nand then clear the cofactor to map to G2.\nHere is the pseudocode for "),s("code",[e._v("HashToG2")]),e._v(":")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function HashToG2(msg)\n    fieldElement00 = HashToBase(msg, 0x04, 0x05)\n    fieldElement01 = HashToBase(msg, 0x06, 0x07)\n    fieldElement10 = HashToBase(msg, 0x08, 0x09)\n    fieldElement11 = HashToBase(msg, 0x0a, 0x0b)\n    fieldElement0 = (fieldElement00, fieldElement01)\n    fieldElement1 = (fieldElement10, fieldElement11)\n    twistElement0 = BaseToTwist(fieldElement0)\n    twistElement1 = BaseToTwist(fieldElement1)\n    twistElement = ECAdd(twistElement0, twistElement1)\n    g2Element = ClearCofactor(twistElement)\n    return g2Element\nend function\n\nfunction ClearCofactor(twistElement)\n    return ECMul(twistElement, cofactor)\nend function\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br")])]),s("p",[e._v("Here is the pseudocode for "),s("code",[e._v("BaseToTwist")]),e._v(".")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function BaseToTwist(t)\n    # All operations are done in the finite field GF(fieldPrime^2)\n    # Here, the twist curve satisfies the equation\n    #       y^2 == g'(x) == x^3 + curveBPrime\n    constant1 = (-1 + sqrt(-3))/2\n    constant2 = -3\n    constant3 = 1/3\n    constant4 = g'(1)\n    s = (constant4 + t^2)^3\n    alpha = inverse(t^2*(constant4 + t^2))\n    x1 = constant1 - constant2*t^4*alpha\n    x2 = -1 - x1\n    x3 = 1 - constant3*s*alpha\n    a1 = x1^3 + curveBPrime\n    a2 = x2^3 + curveBPrime\n    residue1 = is_square(a1)\n    residue2 = is_square(a2)\n    index = (residue1 - 1)*(residue2 - 3)/4 + 1\n    coef1 = ConstantTimeEquality(1, index)\n    coef2 = ConstantTimeEquality(2, index)\n    coef3 = ConstantTimeEquality(3, index)\n    x = coef1*x1 + coef2*x2 + coef3*x3\n    y = sign0(t)*sqrt(x^3 + curveBPrime)\n    return (x, y)\nend function\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br"),s("span",{staticClass:"line-number"},[e._v("23")]),s("br"),s("span",{staticClass:"line-number"},[e._v("24")]),s("br"),s("span",{staticClass:"line-number"},[e._v("25")]),s("br")])]),s("h2",{attrs:{id:"rationale"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),s("p",[e._v("The BaseToG1 algorithm is based on the original Fouque and Tibouchi\n"),s("a",{attrs:{href:"../assets/eip-3068/latincrypt12.pdf"}},[e._v("paper")]),e._v("\nwith modifications based on Wahby and Boneh's\n"),s("a",{attrs:{href:"../assets/eip-3068/2019-403_BLS12_H2C.pdf"}},[e._v("paper")]),e._v(".\nThere is freedom in choosing the HashToBase function\nand this could easily be changed.\nWithin HashToBase, the particular hashing algorithm\n(Keccak256 in our case) could also be modified.\nIt may be desired to change the call to "),s("code",[e._v("sign0")]),e._v("\nat the end of BaseToG1 and BaseToTwist with "),s("code",[e._v("is_square")]),e._v(",\nas this would result in the same deterministic map to curve from the\nFouque and Tibouchi\n"),s("a",{attrs:{href:"../assets/eip-3068/latincrypt12.pdf"}},[e._v("paper")]),e._v("\nand ensure HashToG1 is indifferentiable from a random oracle;\nthey proved this result in their paper.\nIt may be possible to show that switching the "),s("code",[e._v("is_square")]),e._v("\ncall with "),s("code",[e._v("sign0")]),e._v(" does not affect indifferentiability,\nalthough this has not been proven.")]),e._v(" "),s("p",[e._v("The HashToG2 algorithm follows from the Wahby and Boneh\n"),s("a",{attrs:{href:"../assets/eip-3068/2019-403_BLS12_H2C.pdf"}},[e._v("paper")]),e._v(".\nAlgorithms for computing "),s("code",[e._v("inverse")]),e._v(", "),s("code",[e._v("is_square")]),e._v(", and "),s("code",[e._v("sqrt")]),e._v("\nin finite field GF(fieldPrime^2) can be found\n"),s("a",{attrs:{href:"../assets/eip-3068/2012-685_Square_Root_Even_Ext.pdf"}},[e._v("here")]),e._v(".")]),e._v(" "),s("p",[e._v("We now discuss the potential gas cost for the HashToG1\nand HashToG2 operations.\nOn a local machine, ECMul was clocked at 68 microseconds\nper operation.\nThe same machine clocked HashToG1 at 94 microseconds per operation\nwhen hashing 32 bytes into G1 and 105 microseconds per operation\nwhen hashing 1024 bytes into G1.\nGiven that it currently costs 6000 gas for ECMul, this gives us\nan estimated gas cost for HashToG1 at "),s("code",[e._v("8500 + len(bytes)")]),e._v(".\nSimilarly, HashToG2 was clocked at 886 microseconds per operation\nwhen hashing 32 bytes into G2 and 912 microseconds per operation when\nhashing 1024 bytes into G2.\nThis allows us to estimate the gas cost at "),s("code",[e._v("80000 + 3*len(bytes)")]),e._v(".")]),e._v(" "),s("h2",{attrs:{id:"backwards-compatibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility")]),e._v(" "),s("p",[e._v("There are no backward compatibility concerns.")]),e._v(" "),s("h2",{attrs:{id:"test-cases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-cases"}},[e._v("#")]),e._v(" Test Cases")]),e._v(" "),s("p",[e._v("TBD")]),e._v(" "),s("h2",{attrs:{id:"implementation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),s("p",[e._v("TBD")]),e._v(" "),s("h2",{attrs:{id:"security-considerations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#security-considerations"}},[e._v("#")]),e._v(" Security Considerations")]),e._v(" "),s("p",[e._v("Due to recent "),s("a",{attrs:{href:"../assets/eip-3068/2015-1027_exTNFS.pdf"}},[e._v("work")]),e._v(", the\n128-bit security promised by the BN256 elliptic curve no longer applies;\nthis was mentioned in the Cloudflare BN256\n"),s("a",{attrs:{href:"https://github.com/cloudflare/bn256",target:"_blank",rel:"noopener noreferrer"}},[e._v("library"),s("OutboundLink")],1),e._v(".\nThere has been some discussion on the exact security decrease\nfrom this advancement; see these\n"),s("a",{attrs:{href:"../assets/eip-3068/2016-1102_Assessing_NFS_Advances.pdf"}},[e._v("two")]),e._v(" "),s("a",{attrs:{href:"../assets/eip-3068/2017-334.pdf"}},[e._v("papers")]),e._v("\nfor different estimates.\nThe more conservative estimate puts the security of BN256 at\n100-bits.\nWhile this is likely still out of reach for many adversaries,\nit should give us pause.\nThis reduced security was noted in the recent MadNet\n"),s("a",{attrs:{href:"../assets/eip-3068/madnet.pdf"}},[e._v("whitepaper")]),e._v(",\nand this security concern was partially mitigated by\nrequiring Secp256k1 signatures of the partial group signatures\nin order for those partial signatures to be valid.\nFull disclosure: the author of this EIP works for MadHive,\nassisted in the development of MadNet, and\nhelped write the MadNet whitepaper.")]),e._v(" "),s("p",[e._v("The security concerns of the BN256 elliptic curve\naffect any operation using pairing check because it is\nrelated to the elliptic curve pairing;\nthey are independent of this EIP.")]),e._v(" "),s("h2",{attrs:{id:"copyright"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),s("p",[e._v("Copyright and related rights waived via\n"),s("a",{attrs:{href:"https://creativecommons.org/publicdomain/zero/1.0/",target:"_blank",rel:"noopener noreferrer"}},[e._v("CC0"),s("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);n.default=a.exports}}]);